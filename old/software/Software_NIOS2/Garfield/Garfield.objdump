
Garfield.elf:     file format elf32-littlenios2
Garfield.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020254

Program Header:
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00014c8c memsz 0x00018ff8 flags rwx
    LOAD off    0x00016000 vaddr 0x000a0000 paddr 0x000a0000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  000a0000  000a0000  00016000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000234  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00012718  00020254  00020254  00001254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000728  0003296c  0003296c  0001396c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c18  00033094  00033094  00014094  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000436c  00034cac  00034cac  00015cac  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_nios2 00000000  00039018  00039018  00016000  2**0
                  CONTENTS
  7 .shared_memory_master_hps_0 00000000  00060000  00060000  00016000  2**0
                  CONTENTS
  8 .shared_memory_master_nios_0 00000000  00090000  00090000  00016000  2**0
                  CONTENTS
  9 .epcs_flash_controller_0 00000000  000a0020  000a0020  00016000  2**0
                  CONTENTS
 10 .comment      00000023  00000000  00000000  00016000  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000f30  00000000  00000000  00016028  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00023eaa  00000000  00000000  00016f58  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00009b3d  00000000  00000000  0003ae02  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c367  00000000  00000000  0004493f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000397c  00000000  00000000  00050ca8  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00006969  00000000  00000000  00054624  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d1f9  00000000  00000000  0005af8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_alt_sim_info 00000010  00000000  00000000  00068188  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00001358  00000000  00000000  00068198  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .thread_model 00000003  00000000  00000000  0006ef31  2**0
                  CONTENTS, READONLY
 21 .cpu          0000000c  00000000  00000000  0006ef34  2**0
                  CONTENTS, READONLY
 22 .qsys         00000001  00000000  00000000  0006ef40  2**0
                  CONTENTS, READONLY
 23 .simulation_enabled 00000001  00000000  00000000  0006ef41  2**0
                  CONTENTS, READONLY
 24 .sysid_hash   00000004  00000000  00000000  0006ef42  2**0
                  CONTENTS, READONLY
 25 .sysid_base   00000004  00000000  00000000  0006ef46  2**0
                  CONTENTS, READONLY
 26 .sysid_time   00000004  00000000  00000000  0006ef4a  2**0
                  CONTENTS, READONLY
 27 .stderr_dev   0000000f  00000000  00000000  0006ef4e  2**0
                  CONTENTS, READONLY
 28 .stdin_dev    0000000f  00000000  00000000  0006ef5d  2**0
                  CONTENTS, READONLY
 29 .stdout_dev   0000000f  00000000  00000000  0006ef6c  2**0
                  CONTENTS, READONLY
 30 .sopc_system_name 0000000f  00000000  00000000  0006ef7b  2**0
                  CONTENTS, READONLY
 31 .quartus_project_dir 0000007d  00000000  00000000  0006ef8a  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     00328ef3  00000000  00000000  0006f007  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
000a0000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020254 l    d  .text	00000000 .text
0003296c l    d  .rodata	00000000 .rodata
00033094 l    d  .rwdata	00000000 .rwdata
00034cac l    d  .bss	00000000 .bss
00039018 l    d  .onchip_memory2_nios2	00000000 .onchip_memory2_nios2
00060000 l    d  .shared_memory_master_hps_0	00000000 .shared_memory_master_hps_0
00090000 l    d  .shared_memory_master_nios_0	00000000 .shared_memory_master_nios_0
000a0020 l    d  .epcs_flash_controller_0	00000000 .epcs_flash_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Garfield_bsp//obj/HAL/src/crt0.o
00020288 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/os/Source/portable/port_asm.o
00020020 l       .exceptions	00000000 save_context
0002009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
000200ac l       .exceptions	00000000 hw_irq_test
00020150 l       .exceptions	00000000 soft_exceptions
000200c0 l       .exceptions	00000000 hw_irq_handler
000200d4 l       .exceptions	00000000 restore_context
0002016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
0002093c l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 heap_1.c
00034d38 l     O .bss	00004000 ucHeap
00034cac l     O .bss	00000004 xNextFreeByte
00034cb0 l     O .bss	00000004 pucAlignedHeap.2815
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
00020d68 l     F .text	0000002c prvReadGp
00020ecc l     F .text	00000088 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 queue.c
000212c0 l     F .text	00000084 prvInitialiseNewQueue
00021b10 l     F .text	00000160 prvCopyDataToQueue
00021e90 l     F .text	00000058 prvIsQueueFull
00021d0c l     F .text	000000f4 prvUnlockQueue
00021c70 l     F .text	0000009c prvCopyDataFromQueue
00021e00 l     F .text	00000050 prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
00038d38 l     O .bss	00000064 pxReadyTasksLists
00038d9c l     O .bss	00000014 xDelayedTaskList1
00038db0 l     O .bss	00000014 xDelayedTaskList2
00034cb8 l     O .bss	00000004 pxDelayedTaskList
00034cbc l     O .bss	00000004 pxOverflowDelayedTaskList
00038dc4 l     O .bss	00000014 xPendingReadyList
00038dd8 l     O .bss	00000014 xSuspendedTaskList
00034cc0 l     O .bss	00000004 uxCurrentNumberOfTasks
00034cc4 l     O .bss	00000004 xTickCount
00034cc8 l     O .bss	00000004 uxTopReadyPriority
00034ccc l     O .bss	00000004 xSchedulerRunning
00034cd0 l     O .bss	00000004 uxPendedTicks
00034cd4 l     O .bss	00000004 xYieldPending
00034cd8 l     O .bss	00000004 xNumOfOverflows
00034cdc l     O .bss	00000004 uxTaskNumber
00034ce0 l     O .bss	00000004 xNextTaskUnblockTime
00034ce4 l     O .bss	00000004 xIdleTaskHandle
00034ce8 l     O .bss	00000004 uxSchedulerSuspended
00022018 l     F .text	00000198 prvInitialiseNewTask
000221b0 l     F .text	000000fc prvAddNewTaskToReadyList
00022fe8 l     F .text	000000ac prvInitialiseTaskLists
000238d8 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
000230b4 l     F .text	00000068 prvResetNextTaskUnblockTime
000224d8 l     F .text	00000094 prvTaskIsTaskSuspended
00022fb4 l     F .text	00000034 prvIdleTask
00023094 l     F .text	00000020 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 alf_sharedmemory.cpp
00034c44 l     O .rwdata	00000001 _ZStL19piecewise_construct
00034c45 l     O .rwdata	00000001 _ZStL13allocator_arg
00000000 l    df *ABS*	00000000 alf_data_info.cpp
00000000 l    df *ABS*	00000000 Display.cpp
00032985 l     O .rodata	00000500 _ZL4font
00034cf4 l     O .bss	00000002 _ZZN7Display9writeLineEPKcthE8cursor_y
00000000 l    df *ABS*	00000000 Drive.cpp
00000000 l    df *ABS*	00000000 Steering.cpp
00000000 l    df *ABS*	00000000 mpu6050.cpp
00000000 l    df *ABS*	00000000 ultrasonic.cpp
00000000 l    df *ABS*	00000000 main.cpp
00034c49 l     O .rwdata	00000001 _ZStL19piecewise_construct
00034c4a l     O .rwdata	00000001 _ZStL13allocator_arg
00000000 l    df *ABS*	00000000 tasks_nios.cpp
00034c4c l     O .rwdata	00000001 _ZStL19piecewise_construct
00034c4d l     O .rwdata	00000001 _ZStL13allocator_arg
00034c50 l     O .rwdata	00000004 _ZL15pulses_to_meter
00034c54 l     O .rwdata	00000001 _ZL18max_steering_angle
00034c55 l     O .rwdata	00000001 _ZL15max_drive_speed
00034c56 l     O .rwdata	00000001 _ZL23emergency_stop_distance
00034c57 l     O .rwdata	00000001 _ZL20close_range_distance
00034c58 l     O .rwdata	00000001 _ZL17close_range_speed
00034c59 l     O .rwdata	00000001 _ZL7timeout
00038ed8 l     O .bss	0000000c _ZL15global_acc_data
00038ee4 l     O .bss	0000000c _ZL16global_gyro_data
00034d04 l     O .bss	00000004 _ZL16global_temp_data
00034d08 l     O .bss	00000002 _ZL25global_us_front_left_data
00034d0a l     O .bss	00000002 _ZL26global_us_front_right_data
00034d0c l     O .bss	00000002 _ZL24global_us_rear_left_data
00034d0e l     O .bss	00000002 _ZL25global_us_rear_right_data
00027ac0 l     F .text	00000074 _Z41__static_initialization_and_destruction_0ii
00027b34 l     F .text	00000030 _GLOBAL__sub_I_sharedMem
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 subsf3.c
00000000 l    df *ABS*	00000000 fixsfsi.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
0002ba88 l     F .text	00000008 __fp_unlock
0002ba9c l     F .text	0000019c __sinit.part.1
0002bc38 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
00033094 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
0002e2c0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0002e3cc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0002e3f8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
0002e4e4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
0002e5c4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0002e798 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00034c88 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0002e9e4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0002eb18 l     F .text	00000034 alt_dev_reg
0002eb4c l     F .text	0000003c alt_get_errno
0002eb88 l     F .text	00000068 alt_avalon_mutex_reg
00033a68 l     O .rwdata	000000cc epcs_flash_controller_0
00033b34 l     O .rwdata	00001060 jtag_uart_nios2
00034b94 l     O .rwdata	00000048 mailbox_arm2nios_0
00034bdc l     O .rwdata	00000048 mailbox_nios2arm_0
00034c24 l     O .rwdata	00000010 shared_memory_mutex_master_hps_0
00034c34 l     O .rwdata	00000010 shared_memory_mutex_master_nios_0
00000000 l    df *ABS*	00000000 PWM_Generator.c
00000000 l    df *ABS*	00000000 Rotary_Encoder.c
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0002edbc l     F .text	00000034 alt_flash_device_register
0002ee44 l     F .text	000003f8 alt_epcs_flash_query
0002f23c l     F .text	000000ec alt_epcs_flash_memcmp
0002f614 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0002fad0 l     F .text	00000210 altera_avalon_jtag_uart_irq
0002fce0 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mailbox_simple.c
00030318 l     F .text	00000090 altera_avalon_mailbox_identify
000303a8 l     F .text	00000078 altera_avalon_mailbox_post
00030420 l     F .text	0000013c altera_avalon_mailbox_simple_tx_isr
0003055c l     F .text	000000ac altera_avalon_mailbox_simple_rx_isr
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
00030c50 l     F .text	0000003c alt_get_errno
00030c8c l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00031118 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 epcs_commands.c
00031264 l     F .text	00000038 epcs_test_wip
0003129c l     F .text	0000003c epcs_await_wip_released
00000000 l    df *ABS*	00000000 i2c_opencores.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00031be0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00031ecc l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0003200c l     F .text	0000003c alt_get_errno
00032048 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00023c68 g     F .text	0000004c _ZN20Alf_SharedMemoryComm11WaitForLockEPv
00027838 g     F .text	000001c0 _Z21setMotor_and_SteeringPv
000309c4 g     F .text	00000150 altera_avalon_mailbox_send
0002f588 g     F .text	0000008c alt_epcs_flash_get_info
0002e26c g     F .text	00000054 _isatty_r
0002e6d4 g     F .text	0000007c alt_main
0002b91c g     F .text	000000c0 _puts_r
00038f18 g     O .bss	00000100 alt_irq
0002df94 g     F .text	00000060 _lseek_r
000200c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
00022c44 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
00020ab0 g     F .text	00000028 xPortGetFreeHeapSize
00020694 g     F .text	0000003c xEventGroupGetBitsFromISR
00039018 g       *ABS*	00000000 __alt_heap_start
00027b64  w    F .text	0000004c _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EEC1Ev
0002d548 g     F .text	0000005c __sseek
0002bdd8 g     F .text	00000010 __sinit
0002bc40 g     F .text	00000068 __sfmoreglue
0002e774 g     F .text	00000024 __malloc_unlock
00027ea8 g     F .text	00000440 .hidden __divsf3
00020314 g     F .text	0000017c xEventGroupSync
0002cd5c g     F .text	0000015c memmove
0002311c g     F .text	00000054 vTaskEnterCritical
0002bdc0 g     F .text	00000018 _cleanup
0002611c g     F .text	000000ac _ZN8Steering3SetEa
000214f8 g     F .text	000000e8 xQueueGenericSendFromISR
00022918 g     F .text	00000040 pcTaskGetName
00030dc4 g     F .text	00000040 altera_avalon_mutex_trylock
00028c84 g     F .text	00000070 .hidden __fixsfsi
00025cd4 g     F .text	00000038 _ZN7Display5cp437Eb
00025d0c g     F .text	0000012c _ZN7Display11setRotationEh
00027a44 g     F .text	0000007c _Z11Mailbox_isrPvm
0002a09c g     F .text	000000dc .hidden __gtdf2
00032404 g     F .text	00000024 altera_nios2_gen2_irq_init
00024004 g     F .text	000000a8 _ZN20Alf_SharedMemoryComm4ReadER17Alf_Drive_Command
000312d8 g     F .text	000000fc epcs_sector_erase
00023f5c g     F .text	000000a8 _ZN20Alf_SharedMemoryComm4ReadER14Alf_Drive_Info
000a0000 g     F .entry	00000000 __reset
00034cb4 g     O .bss	00000004 pxCurrentTCB
00027194 g     F .text	000000b8 _ZNK16UltraSonicDevice20checkUltraSonicStateERb
00030e58 g     F .text	00000074 altera_avalon_mutex_is_mine
0002028c g     F .text	00000034 main2
000259e8 g     F .text	000001d0 _ZN7Display8fillRectEsssst
0002e210 g     F .text	0000005c _fstat_r
00024568  w    F .text	00000110 _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_
00034d1c g     O .bss	00000004 errno
00026b84 g     F .text	00000080 _ZN7mpu605010readStatusEv
0002d4c4 g     F .text	00000008 __seofread
00034d28 g     O .bss	00000004 alt_argv
00034cf6 g     O .bss	00000001 _ZN5Drive15block_front_dirE
0003cc44 g       *ABS*	00000000 _gp
00030b14 g     F .text	0000013c altera_avalon_mailbox_retrieve_poll
000287a0 g     F .text	000004e4 .hidden __subsf3
00025ff4 g     F .text	00000020 _ZN5Drive20GetMax_Speed_PercentEv
00026cec g     F .text	00000080 _ZNK16UltraSonicDevice17writeGAINRegisterEh
00020490 g     F .text	0000019c xEventGroupWaitBits
00034cf8 g     O .bss	00000001 _ZN5Drive13current_speedE
000338e8 g     O .rwdata	00000180 alt_fd_list
00034cf2 g     O .bss	00000002 _ZN7Display8_bgcolorE
00020e74 g     F .text	00000038 xPortStartScheduler
00025060 g     F .text	00000048 _ZN7Display12writecommandEh
0003151c g     F .text	0000006c epcs_write_status_register
000226d8 g     F .text	00000048 vTaskEndScheduler
00026c04 g     F .text	00000038 _ZN16UltraSonicDeviceC1E17UltraSonicAddress
00031d80 g     F .text	00000090 alt_find_dev
0002b6ac g     F .text	00000148 memcpy
00022bf4 g     F .text	00000050 vTaskPlaceOnEventList
0002ba90 g     F .text	0000000c _cleanup_r
00023cb4 g     F .text	00000048 _ZN20Alf_SharedMemoryComm11ReleaseLockEPv
0002b20c g     F .text	000000dc .hidden __floatsidf
00031f90 g     F .text	0000007c alt_io_redirect
000261c8 g     F .text	00000048 _ZN7mpu6050C1E17MPU6050_Addresses
00021994 g     F .text	0000007c xQueuePeekFromISR
0003296c g       *ABS*	00000000 __DTOR_END__
0002ed10 g     F .text	0000002c ROT_ENC_GetRotations
0002b9dc g     F .text	00000014 puts
00090000 g       *ABS*	00000000 __alt_mem_shared_memory_master_nios_0
000318f8 g     F .text	00000094 I2C_start
000249a0 g     F .text	00000054 _Z8delay_msh
00020a68 g     F .text	00000024 vPortFree
00030608 g     F .text	00000078 altera_avalon_mailbox_simple_init
00038e0c g     O .bss	000000cc sharedMem
0002f720 g     F .text	00000100 alt_epcs_flash_write_block
0002fed8 g     F .text	0000021c altera_avalon_jtag_uart_read
00027dec g     F .text	00000064 .hidden __udivsi3
0002e520 g     F .text	000000a4 isatty
0003094c g     F .text	00000078 altera_avalon_mailbox_status
00030844 g     F .text	00000108 altera_avalon_mailbox_close
00027c80 g     F .text	00000074 .hidden __fixunsdfsi
00020b6c g     F .text	0000008c vListInsertEnd
00034d18 g     O .bss	00000004 __malloc_top_pad
00027518 g     F .text	00000208 _Z14readUltraSonicPv
000202c0 g     F .text	00000054 xEventGroupCreate
0002be28 g     F .text	000004bc __sfvwrite_r
0002d41c g     F .text	00000054 _sbrk_r
000208c4 g     F .text	0000003c vEventGroupSetBitsCallback
00034cf7 g     O .bss	00000001 _ZN5Drive14block_rear_dirE
0002e1b0 g     F .text	00000060 _read_r
00020b40 g     F .text	0000002c vListInitialiseItem
00034c7c g     O .rwdata	00000004 alt_max_fd
00020f54 g     F .text	00000048 vPortSysTickHandler
0002d7b4 g     F .text	000000f0 _fclose_r
00027bb0  w    F .text	00000070 _ZN20Alf_SharedMemoryCommC1Ev
00024828  w    F .text	000000bc _ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_
0002db30 g     F .text	00000030 fflush
00020000 g       *ABS*	00000000 __alt_mem_onchip_memory2_nios2
00034d14 g     O .bss	00000004 __malloc_max_sbrked_mem
00020f9c g     F .text	00000170 alt_irq_register
0002b390 g     F .text	00000110 .hidden __extendsfdf2
00028f08 g     F .text	000008ac .hidden __adddf3
0002f6a8 g     F .text	00000078 alt_epcs_flash_erase_block
0002e600 g     F .text	000000d4 lseek
00030ecc g     F .text	00000050 altera_avalon_mutex_first_lock
000240ac  w    F .text	00000194 _ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_
00034c5c g     O .rwdata	00000004 _global_impure_ptr
000317e8 g     F .text	0000005c epcs_exit_4_bytes_mode
000206d0 g     F .text	00000180 xEventGroupSetBits
0002ceb8 g     F .text	00000564 _realloc_r
00025508 g     F .text	00000464 _ZN7Display9writeLineEPKcth
00039018 g       *ABS*	00000000 __bss_end
000322fc g     F .text	00000108 alt_tick
00025fd4 g     F .text	00000020 _ZN5Drive16GetCurrent_speedEv
000239c0 g     F .text	000001cc _ZN20Alf_SharedMemoryComm4InitEmmmmmmtm
0002b2e8 g     F .text	000000a8 .hidden __floatunsidf
00024b9c g     F .text	00000064 _ZN7DisplayC2Ess
000209ac g     F .text	000000bc pvPortMalloc
0002bdf8 g     F .text	00000018 __fp_lock_all
00021ad4 g     F .text	0000003c vQueueDelete
00023bfc g     F .text	00000034 _ZN20Alf_SharedMemoryComm23DisableMailboxInterruptEv
00020eac g     F .text	00000020 vPortEndScheduler
00020ad8 g     F .text	00000068 vListInitialise
00032260 g     F .text	0000009c alt_alarm_stop
00034cf0 g     O .bss	00000001 _ZN7Display12_currentLineE
00034d20 g     O .bss	00000004 alt_irq_active
0002017c g     F .exceptions	000000d8 alt_irq_handler
000338c0 g     O .rwdata	00000028 alt_dev_null
000228a4 g     F .text	00000028 xTaskGetTickCount
00021344 g     F .text	000001b4 xQueueGenericSend
00030d08 g     F .text	00000054 altera_avalon_mutex_open
000246e0  w    F .text	0000008c _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv
00026054 g     F .text	000000c8 _ZN8Steering4InitEh
000248e4 g     F .text	0000006c _Z10set_tft_dcb
0002b18c g     F .text	00000080 .hidden __fixdfsi
00025bb8 g     F .text	0000011c _ZN7Display13setAddrWindowEtttt
000246a0  w    F .text	00000040 _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3topEv
00034c74 g     O .rwdata	00000008 alt_dev_list
0002ea20 g     F .text	000000f8 write
000282e8 g     F .text	000000bc .hidden __gtsf2
00022ca8 g     F .text	000000f4 xTaskRemoveFromEventList
00034c94 g     O .rwdata	00000008 alt_mutex_list
0002e434 g     F .text	000000b0 fstat
0002062c g     F .text	00000068 xEventGroupClearBits
00023b8c g     F .text	00000070 _ZN20Alf_SharedMemoryComm7TryLockEPv
00027e50 g     F .text	00000058 .hidden __umodsi3
000316a4 g     F .text	00000068 epcs_read_electronic_signature
00039018 g       *ABS*	00000000 end
0002fa1c g     F .text	000000b4 altera_avalon_jtag_uart_init
00026034 g     F .text	00000020 _ZN5Drive13GetBlock_RearEv
0002670c g     F .text	0000030c _ZN7mpu605013ReadGyroscopeERNS_13GyroscopeDataE
00032968 g       *ABS*	00000000 __CTOR_LIST__
00040000 g       *ABS*	00000000 __alt_stack_pointer
00031194 g     F .text	00000074 alt_avalon_timer_sc_init
0002b648 g     F .text	00000064 .hidden __clzsi2
000300f4 g     F .text	00000224 altera_avalon_jtag_uart_write
00027b64  w    F .text	0000004c _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EEC2Ev
0002bde8 g     F .text	00000004 __sfp_lock_acquire
0002cc78 g     F .text	000000e4 memchr
00023e90 g     F .text	000000cc _ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv
00022eb0 g     F .text	000000dc xTaskCheckForTimeOut
0002dc84 g     F .text	00000310 _free_r
00038dec g     O .bss	00000020 global_drive_info
000327b4 g     F .text	00000180 __call_exitprocs
00023214 g     F .text	000000b0 ulTaskNotifyTake
00034c64 g     O .rwdata	00000004 __malloc_sbrk_base
00020254 g     F .text	00000038 _start
00034d30 g     O .bss	00000004 _alt_tick_rate
00022720 g     F .text	0000002c vTaskSuspendAll
000273e4 g     F .text	00000134 _Z7readMPUPv
000228cc g     F .text	0000002c xTaskGetTickCountFromISR
00030f1c g     F .text	000001fc alt_avalon_spi_command
00034d34 g     O .bss	00000004 _alt_nticks
0002e7d4 g     F .text	000000fc read
0002ec28 g     F .text	000000b4 alt_sys_init
00028cf4 g     F .text	00000124 .hidden __floatsisf
00020cd0 g     F .text	00000098 uxListRemove
0003269c g     F .text	00000118 __register_exitproc
000250f0 g     F .text	000000fc _ZN7Display9drawPixelEsst
00030e04 g     F .text	00000054 altera_avalon_mutex_unlock
0002fd80 g     F .text	00000068 altera_avalon_jtag_uart_close
00038ef0 g     O .bss	00000028 __malloc_current_mallinfo
00023860 g     F .text	00000078 xTaskNotifyStateClear
0002256c g     F .text	000000cc vTaskResume
00022b1c g     F .text	000000d8 vTaskSwitchContext
00031208 g     F .text	0000005c epcs_read_status_register
00026c04 g     F .text	00000038 _ZN16UltraSonicDeviceC2E17UltraSonicAddress
0002f8b8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00032530 g     F .text	000000a4 alt_get_fd
0002d760 g     F .text	00000054 _close_r
000232c4 g     F .text	000000f4 xTaskNotifyWait
0002596c g     F .text	0000007c _ZN7Display10fillScreenEt
0003170c g     F .text	00000080 epcs_read_device_id
00032620 g     F .text	0000007c memcmp
0002f978 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0002ecdc g     F .text	00000034 PWMGen_Set_DutyCycle
00039018 g       *ABS*	00000000 __alt_stack_base
0002f9c8 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
000a0000 g       *ABS*	00000000 __alt_mem_epcs_flash_controller_0
0002d60c g     F .text	00000154 __swsetup_r
000223f8 g     F .text	000000e0 vTaskSuspend
000297b4 g     F .text	000008e8 .hidden __divdf3
0002bca8 g     F .text	00000118 __sfp
000250a8 g     F .text	00000048 _ZN7Display9writedataEh
0002476c  w    F .text	000000bc _ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_
000228f8 g     F .text	00000020 uxTaskGetNumberOfTasks
00026a18 g     F .text	0000016c _ZN7mpu605015ReadTemperatureERf
000334b8 g     O .rwdata	00000408 __malloc_av_
0002bdf4 g     F .text	00000004 __sinit_lock_release
0002a178 g     F .text	00000718 .hidden __muldf3
0002d470 g     F .text	00000054 __sread
00032428 g     F .text	00000108 alt_find_file
00031c1c g     F .text	000000a4 alt_dev_llist_insert
0002e750 g     F .text	00000024 __malloc_lock
0002e934 g     F .text	000000b0 sbrk
00023c30 g     F .text	00000038 _ZN20Alf_SharedMemoryComm22EnableMailboxInterruptEv
0002dad4 g     F .text	0000005c _fflush_r
00020850 g     F .text	00000074 vEventGroupDelete
00034c9c g     O .rwdata	00000008 alt_flash_dev_list
000233b8 g     F .text	000001a4 xTaskGenericNotify
00024b9c g     F .text	00000064 _ZN7DisplayC1Ess
00034cac g       *ABS*	00000000 __bss_start
00024aa4 g     F .text	000000f8 _Z8itochptriPc
0002b7f4 g     F .text	00000128 memset
00024678  w    F .text	00000028 _ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE5emptyEv
0002724c g     F .text	00000198 main
00034d2c g     O .bss	00000004 alt_envp
00034d10 g     O .bss	00000004 __malloc_max_total_mem
0002f918 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00020bf8 g     F .text	000000d8 vListInsert
0002d5a4 g     F .text	00000008 __sclose
00040000 g       *ABS*	00000000 __alt_heap_limit
0002d8a4 g     F .text	00000014 fclose
0002b4a0 g     F .text	000001a8 .hidden __truncdfsf2
00030d80 g     F .text	00000044 altera_avalon_mutex_lock
0002c46c g     F .text	0000080c _malloc_r
00034c80 g     O .rwdata	00000004 alt_errno
000222ac g     F .text	000000f0 vTaskDelayUntil
0002c2e4 g     F .text	000000c4 _fwalk
000218b0 g     F .text	000000e4 xQueueReceiveFromISR
00027cf4 g     F .text	00000084 .hidden __divsi3
00021220 g     F .text	000000a0 xQueueGenericCreate
0002db60 g     F .text	00000124 _malloc_trim_r
00025f10 g     F .text	00000044 _ZN5Drive11SetMaxSpeedEh
0003296c g       *ABS*	00000000 __CTOR_END__
000283a4 g     F .text	000003fc .hidden __mulsf3
0003198c g     F .text	0000007c I2C_read
00027bb0  w    F .text	00000070 _ZN20Alf_SharedMemoryCommC2Ev
00023da0 g     F .text	00000054 _ZN20Alf_SharedMemoryComm5WriteERK14Alf_Drive_Info
00034d00 g     O .bss	00000004 writeTask
00025f54 g     F .text	00000030 _ZN5Drive14setBlock_FrontEb
0002f328 g     F .text	00000260 alt_epcs_flash_write
00025fb4 g     F .text	00000020 _ZN5Drive20GetCurrent_directionEv
00034c48 g     O .rwdata	00000001 _ZN8Steering15max_angle_deltaE
0003296c g       *ABS*	00000000 __DTOR_LIST__
0002355c g     F .text	000001e0 xTaskGenericNotifyFromISR
0002ed3c g     F .text	00000038 ROT_ENC_SetNewStatus
0002ebf0 g     F .text	00000038 alt_irq_init
00022d9c g     F .text	000000d8 xTaskRemoveFromUnorderedEventList
0002e8d0 g     F .text	00000064 alt_release_fd
0002274c g     F .text	00000158 xTaskResumeAll
00021a50 g     F .text	00000054 uxQueueSpacesAvailable
00032eae g     O .rodata	00000100 .hidden __clz_tab
00022638 g     F .text	000000a0 vTaskStartScheduler
00024c00 g     F .text	00000460 _ZN7Display4initEt
000251ec g     F .text	0000031c _ZN7Display8drawCharEsshtth
000325d4 g     F .text	00000014 atexit
000282e8 g     F .text	000000bc .hidden __gesf2
0002d5ac g     F .text	00000060 _write_r
00021ee8 g     F .text	00000048 xQueueIsQueueFullFromISR
000279f8 g     F .text	0000004c _Z12setDriveInfoPv
00034c60 g     O .rwdata	00000004 _impure_ptr
00034d24 g     O .bss	00000004 alt_argc
0002d8b8 g     F .text	0000021c __sflush_r
00031d20 g     F .text	00000060 _do_dtors
00024950 g     F .text	00000050 _Z14spi_write_byteh
0002be10 g     F .text	00000018 __fp_unlock_all
00022f8c g     F .text	00000028 vTaskMissedYield
00034c6c g     O .rwdata	00000008 alt_fs_list
00026014 g     F .text	00000020 _ZN5Drive14GetBlock_FrontEv
00021a10 g     F .text	00000040 uxQueueMessagesWaiting
000216bc g     F .text	000001f4 xQueueGenericReceive
00022958 g     F .text	000001c4 xTaskIncrementTick
0002ed74 g     F .text	00000048 ROT_ENC_ClearCounter
00031844 g     F .text	000000b4 I2C_init
000313d4 g     F .text	000000f4 epcs_read_buffer
0002edf0 g     F .text	00000054 alt_epcs_flash_init
00024240  w    F .text	00000194 _ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_
00026f28 g     F .text	00000118 _ZNK16UltraSonicDevice15readMeasurementEPhh
0002110c g     F .text	00000114 xQueueGenericReset
00034cac g       *ABS*	00000000 _edata
00026d6c g     F .text	00000080 _ZNK16UltraSonicDevice18writeRANGERegisterEh
00039018 g       *ABS*	00000000 _end
00031e10 g     F .text	00000068 alt_flash_open_dev
0002fde8 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
00021f30 g     F .text	000000e8 xTaskCreate
00023d4c g     F .text	00000054 _ZN20Alf_SharedMemoryComm5WriteERK17Alf_Drive_Command
00020a8c g     F .text	00000024 vPortInitialiseBlocks
00025e38 g     F .text	000000d8 _ZN5Drive13SetDriveSpeedEhh
0003178c g     F .text	0000005c epcs_enter_4_bytes_mode
00026c3c g     F .text	000000b0 _ZNK16UltraSonicDevice16writeCMDRegisterE18UltraSonicCommandsb
00025f84 g     F .text	00000030 _ZN5Drive13SetBlock_RearEb
00034c8c g     O .rwdata	00000008 alt_mailbox_simple_list
0002d4cc g     F .text	0000007c __swrite
00034c68 g     O .rwdata	00000004 __malloc_trim_threshold
000325e8 g     F .text	00000038 exit
0002c3a8 g     F .text	000000c4 _fwalk_reent
00028e18 g     F .text	000000f0 .hidden __floatunsisf
00031e78 g     F .text	00000054 alt_flash_close_dev
00026210 g     F .text	000001f0 _ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings
00027d78 g     F .text	00000074 .hidden __modsi3
0002239c g     F .text	0000005c vTaskDelay
00040000 g       *ABS*	00000000 __alt_data_end
0002bdec g     F .text	00000004 __sfp_lock_release
00034cfc g     O .bss	00000004 _ZN8Steering11val_per_degE
00034c47 g     O .rwdata	00000001 _ZN5Drive17max_speed_percentE
00060000 g       *ABS*	00000000 __alt_mem_shared_memory_master_hps_0
00027c20 g     F .text	00000060 .hidden __fixunssfsi
00030680 g     F .text	000001c4 altera_avalon_mailbox_open
00032934 g     F .text	00000034 _exit
00031ab4 g     F .text	0000012c alt_alarm_start
0002dff4 g     F .text	000001bc __smakebuf_r
000243d4  w    F .text	00000194 _ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_
00023170 g     F .text	00000060 vTaskExitCritical
0002b9f0 g     F .text	00000098 strlen
000314c8 g     F .text	00000054 epcs_write_enable
00020d94 g     F .text	000000e0 pxPortInitialiseStack
0003210c g     F .text	00000154 open
0002a09c g     F .text	000000dc .hidden __gedf2
000261c8 g     F .text	00000048 _ZN7mpu6050C2E17MPU6050_Addresses
000249f4 g     F .text	000000b0 _Z10reversestrPc
00022e74 g     F .text	0000003c vTaskSetTimeOutState
00034c46 g     O .rwdata	00000001 _ZN5Drive11mot_dir_pinE
00034c84 g     O .rwdata	00000004 alt_priority_mask
00026400 g     F .text	0000030c _ZN7mpu605017ReadAccelerometerERNS_17AccelerometerDataE
00026dec g     F .text	0000013c _ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt
00030d5c g     F .text	00000024 altera_avalon_mutex_close
00021aa4 g     F .text	00000030 uxQueueMessagesWaitingFromISR
00021e50 g     F .text	00000040 xQueueIsQueueEmptyFromISR
0002a890 g     F .text	000008fc .hidden __subdf3
0002f820 g     F .text	00000098 alt_epcs_flash_read
00034ca4 g     O .rwdata	00000008 alt_alarm_list
00031cc0 g     F .text	00000060 _do_ctors
00027040 g     F .text	00000154 _ZN16UltraSonicDevice13changeAddressE17UltraSonicAddress
000231d0 g     F .text	00000044 uxTaskResetEventItemValue
0002e2fc g     F .text	000000d0 close
00023df4 g     F .text	00000048 _ZN20Alf_SharedMemoryComm5WriteERm
00027720 g     F .text	00000118 _Z10readRotaryPv
0002373c g     F .text	00000124 vTaskNotifyGiveFromISR
00034cf9 g     O .bss	00000001 _ZN5Drive17current_directionE
00020900 g     F .text	0000003c vEventGroupClearBitsCallback
00031a08 g     F .text	000000ac I2C_write
00023e3c g     F .text	00000054 _ZN20Alf_SharedMemoryComm15ResetWriteMutexEv
000215e0 g     F .text	000000dc xQueueGiveFromISR
00034cec g     O .bss	00000004 global_drive_command
0002bdf0 g     F .text	00000004 __sinit_lock_acquire
00031588 g     F .text	0000011c epcs_write_buffer
00023cfc g     F .text	00000050 _ZN20Alf_SharedMemoryComm21WriteAndCommitMailboxEPKvmRKm



Disassembly of section .exceptions:

00020020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
   20020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
   20024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
   20028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
   2002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
   20030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
   20034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
   20038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
   2003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
   20040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
   20044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
   20048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
   2004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
   20050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
   20054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
   20058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
   2005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
   20060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
   20064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
   20068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
   2006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
   20070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
   20074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
   20078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
   2007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
   20080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
   20084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
   20088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
   2008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
   20090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
   20094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
   20098:	df001c15 	stw	fp,112(sp)

0002009c <save_sp_to_pxCurrentTCB>:
   2009c:	060000f4 	movhi	et,3

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
   200a0:	c6132d04 	addi	et,et,19636
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
   200a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
   200a8:	c6c00015 	stw	sp,0(et)

000200ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
   200ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
   200b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
   200b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
   200b8:	10002526 	beq	r2,zero,20150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
   200bc:	20002426 	beq	r4,zero,20150 <soft_exceptions>

000200c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
   200c0:	002017c0 	call	2017c <alt_irq_handler>

000200c4 <restore_sp_from_pxCurrentTCB>:
   200c4:	060000f4 	movhi	et,3

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
   200c8:	c6132d04 	addi	et,et,19636
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
   200cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
   200d0:	c6c00017 	ldw	sp,0(et)

000200d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
   200d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
   200d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
   200dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
   200e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
   200e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
   200e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
   200ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
   200f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
   200f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
   200f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
   200fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
   20100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
   20104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
   20108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
   2010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
   20110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
   20114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
   20118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
   2011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
   20120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
   20124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
   20128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
   2012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
   20130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
   20134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
   20138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
   2013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
   20140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
   20144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
   20148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
   2014c:	ef80083a 	eret

00020150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
   20150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
   20154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
   20158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
   2015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
   20160:	c0000226 	beq	et,zero,2016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
   20164:	003da03a 	break	0
  	br		restore_context			# its something else
   20168:	003fda06 	br	200d4 <__reset+0xfff800d4>

0002016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
   2016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
   20170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
   20174:	0022b1c0 	call	22b1c <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
   20178:	003fd206 	br	200c4 <__reset+0xfff800c4>

0002017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   2017c:	defff904 	addi	sp,sp,-28
   20180:	dfc00615 	stw	ra,24(sp)
   20184:	df000515 	stw	fp,20(sp)
   20188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   2018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   20190:	0005313a 	rdctl	r2,ipending
   20194:	e0bffe15 	stw	r2,-8(fp)

  return active;
   20198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   2019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   201a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   201a4:	00800044 	movi	r2,1
   201a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   201ac:	e0fffb17 	ldw	r3,-20(fp)
   201b0:	e0bffc17 	ldw	r2,-16(fp)
   201b4:	1884703a 	and	r2,r3,r2
   201b8:	10001526 	beq	r2,zero,20210 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
   201bc:	00800134 	movhi	r2,4
   201c0:	10a3c604 	addi	r2,r2,-28904
   201c4:	e0fffd17 	ldw	r3,-12(fp)
   201c8:	180690fa 	slli	r3,r3,3
   201cc:	10c5883a 	add	r2,r2,r3
   201d0:	10c00017 	ldw	r3,0(r2)
   201d4:	00800134 	movhi	r2,4
   201d8:	10a3c604 	addi	r2,r2,-28904
   201dc:	e13ffd17 	ldw	r4,-12(fp)
   201e0:	200890fa 	slli	r4,r4,3
   201e4:	1105883a 	add	r2,r2,r4
   201e8:	10800104 	addi	r2,r2,4
   201ec:	10800017 	ldw	r2,0(r2)
   201f0:	e17ffd17 	ldw	r5,-12(fp)
   201f4:	1009883a 	mov	r4,r2
   201f8:	183ee83a 	callr	r3
#endif
        break;
   201fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   20200:	0005313a 	rdctl	r2,ipending
   20204:	e0bfff15 	stw	r2,-4(fp)

  return active;
   20208:	e0bfff17 	ldw	r2,-4(fp)
   2020c:	00000706 	br	2022c <alt_irq_handler+0xb0>
      }
      mask <<= 1;
   20210:	e0bffc17 	ldw	r2,-16(fp)
   20214:	1085883a 	add	r2,r2,r2
   20218:	e0bffc15 	stw	r2,-16(fp)
      i++;
   2021c:	e0bffd17 	ldw	r2,-12(fp)
   20220:	10800044 	addi	r2,r2,1
   20224:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   20228:	003fe006 	br	201ac <__reset+0xfff801ac>

    active = alt_irq_pending ();
   2022c:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   20230:	e0bffb17 	ldw	r2,-20(fp)
   20234:	103fda1e 	bne	r2,zero,201a0 <__reset+0xfff801a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   20238:	0001883a 	nop
}
   2023c:	0001883a 	nop
   20240:	e037883a 	mov	sp,fp
   20244:	dfc00117 	ldw	ra,4(sp)
   20248:	df000017 	ldw	fp,0(sp)
   2024c:	dec00204 	addi	sp,sp,8
   20250:	f800283a 	ret

Disassembly of section .text:

00020254 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20254:	06c00134 	movhi	sp,4
    ori sp, sp, %lo(__alt_stack_pointer)
   20258:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
   2025c:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
   20260:	d6b31114 	ori	gp,gp,52292
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   20264:	008000f4 	movhi	r2,3
    ori r2, r2, %lo(__bss_start)
   20268:	10932b14 	ori	r2,r2,19628

    movhi r3, %hi(__bss_end)
   2026c:	00c000f4 	movhi	r3,3
    ori r3, r3, %lo(__bss_end)
   20270:	18e40614 	ori	r3,r3,36888

    beq r2, r3, 1f
   20274:	10c00326 	beq	r2,r3,20284 <_start+0x30>

0:
    stw zero, (r2)
   20278:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   2027c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   20280:	10fffd36 	bltu	r2,r3,20278 <__reset+0xfff80278>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   20284:	002e6d40 	call	2e6d4 <alt_main>

00020288 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   20288:	003fff06 	br	20288 <__reset+0xfff80288>

0002028c <main2>:
 */

#include <stdio.h>

int main2()
{
   2028c:	defffe04 	addi	sp,sp,-8
   20290:	dfc00115 	stw	ra,4(sp)
   20294:	df000015 	stw	fp,0(sp)
   20298:	d839883a 	mov	fp,sp
  printf("Hello from Nios II!\n");
   2029c:	010000f4 	movhi	r4,3
   202a0:	210a5b04 	addi	r4,r4,10604
   202a4:	002b9dc0 	call	2b9dc <puts>

  return 0;
   202a8:	0005883a 	mov	r2,zero
}
   202ac:	e037883a 	mov	sp,fp
   202b0:	dfc00117 	ldw	ra,4(sp)
   202b4:	df000017 	ldw	fp,0(sp)
   202b8:	dec00204 	addi	sp,sp,8
   202bc:	f800283a 	ret

000202c0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
   202c0:	defffd04 	addi	sp,sp,-12
   202c4:	dfc00215 	stw	ra,8(sp)
   202c8:	df000115 	stw	fp,4(sp)
   202cc:	df000104 	addi	fp,sp,4
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
   202d0:	01000604 	movi	r4,24
   202d4:	00209ac0 	call	209ac <pvPortMalloc>
   202d8:	e0bfff15 	stw	r2,-4(fp)

		if( pxEventBits != NULL )
   202dc:	e0bfff17 	ldw	r2,-4(fp)
   202e0:	10000626 	beq	r2,zero,202fc <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
   202e4:	e0bfff17 	ldw	r2,-4(fp)
   202e8:	10000015 	stw	zero,0(r2)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   202ec:	e0bfff17 	ldw	r2,-4(fp)
   202f0:	10800104 	addi	r2,r2,4
   202f4:	1009883a 	mov	r4,r2
   202f8:	0020ad80 	call	20ad8 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
   202fc:	e0bfff17 	ldw	r2,-4(fp)
	}
   20300:	e037883a 	mov	sp,fp
   20304:	dfc00117 	ldw	ra,4(sp)
   20308:	df000017 	ldw	fp,0(sp)
   2030c:	dec00204 	addi	sp,sp,8
   20310:	f800283a 	ret

00020314 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
   20314:	defff504 	addi	sp,sp,-44
   20318:	dfc00a15 	stw	ra,40(sp)
   2031c:	df000915 	stw	fp,36(sp)
   20320:	df000904 	addi	fp,sp,36
   20324:	e13ffc15 	stw	r4,-16(fp)
   20328:	e17ffd15 	stw	r5,-12(fp)
   2032c:	e1bffe15 	stw	r6,-8(fp)
   20330:	e1ffff15 	stw	r7,-4(fp)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   20334:	e0bffc17 	ldw	r2,-16(fp)
   20338:	e0bff815 	stw	r2,-32(fp)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
   2033c:	e03ff915 	stw	zero,-28(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
   20340:	00227200 	call	22720 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
   20344:	e0bff817 	ldw	r2,-32(fp)
   20348:	10800017 	ldw	r2,0(r2)
   2034c:	e0bffa15 	stw	r2,-24(fp)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   20350:	e17ffd17 	ldw	r5,-12(fp)
   20354:	e13ffc17 	ldw	r4,-16(fp)
   20358:	00206d00 	call	206d0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   2035c:	e0fffa17 	ldw	r3,-24(fp)
   20360:	e0bffd17 	ldw	r2,-12(fp)
   20364:	1886b03a 	or	r3,r3,r2
   20368:	e0bffe17 	ldw	r2,-8(fp)
   2036c:	1886703a 	and	r3,r3,r2
   20370:	e0bffe17 	ldw	r2,-8(fp)
   20374:	18800d1e 	bne	r3,r2,203ac <xEventGroupSync+0x98>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   20378:	e0fffa17 	ldw	r3,-24(fp)
   2037c:	e0bffd17 	ldw	r2,-12(fp)
   20380:	1884b03a 	or	r2,r3,r2
   20384:	e0bff715 	stw	r2,-36(fp)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   20388:	e0bff817 	ldw	r2,-32(fp)
   2038c:	10c00017 	ldw	r3,0(r2)
   20390:	e0bffe17 	ldw	r2,-8(fp)
   20394:	0084303a 	nor	r2,zero,r2
   20398:	1886703a 	and	r3,r3,r2
   2039c:	e0bff817 	ldw	r2,-32(fp)
   203a0:	10c00015 	stw	r3,0(r2)

			xTicksToWait = 0;
   203a4:	e03fff15 	stw	zero,-4(fp)
   203a8:	00000f06 	br	203e8 <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
   203ac:	e0bfff17 	ldw	r2,-4(fp)
   203b0:	10000a26 	beq	r2,zero,203dc <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   203b4:	e0bff817 	ldw	r2,-32(fp)
   203b8:	10c00104 	addi	r3,r2,4
   203bc:	e0bffe17 	ldw	r2,-8(fp)
   203c0:	10814034 	orhi	r2,r2,1280
   203c4:	e1bfff17 	ldw	r6,-4(fp)
   203c8:	100b883a 	mov	r5,r2
   203cc:	1809883a 	mov	r4,r3
   203d0:	0022c440 	call	22c44 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
   203d4:	e03ff715 	stw	zero,-36(fp)
   203d8:	00000306 	br	203e8 <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
   203dc:	e0bff817 	ldw	r2,-32(fp)
   203e0:	10800017 	ldw	r2,0(r2)
   203e4:	e0bff715 	stw	r2,-36(fp)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
   203e8:	002274c0 	call	2274c <xTaskResumeAll>
   203ec:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
   203f0:	e0bfff17 	ldw	r2,-4(fp)
   203f4:	10002026 	beq	r2,zero,20478 <xEventGroupSync+0x164>
	{
		if( xAlreadyYielded == pdFALSE )
   203f8:	e0bffb17 	ldw	r2,-20(fp)
   203fc:	1000011e 	bne	r2,zero,20404 <xEventGroupSync+0xf0>
		{
			portYIELD_WITHIN_API();
   20400:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
   20404:	00231d00 	call	231d0 <uxTaskResetEventItemValue>
   20408:	e0bff715 	stw	r2,-36(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   2040c:	e0bff717 	ldw	r2,-36(fp)
   20410:	1080802c 	andhi	r2,r2,512
   20414:	1000131e 	bne	r2,zero,20464 <xEventGroupSync+0x150>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
   20418:	002311c0 	call	2311c <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
   2041c:	e0bff817 	ldw	r2,-32(fp)
   20420:	10800017 	ldw	r2,0(r2)
   20424:	e0bff715 	stw	r2,-36(fp)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   20428:	e0fff717 	ldw	r3,-36(fp)
   2042c:	e0bffe17 	ldw	r2,-8(fp)
   20430:	1886703a 	and	r3,r3,r2
   20434:	e0bffe17 	ldw	r2,-8(fp)
   20438:	1880071e 	bne	r3,r2,20458 <xEventGroupSync+0x144>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   2043c:	e0bff817 	ldw	r2,-32(fp)
   20440:	10c00017 	ldw	r3,0(r2)
   20444:	e0bffe17 	ldw	r2,-8(fp)
   20448:	0084303a 	nor	r2,zero,r2
   2044c:	1886703a 	and	r3,r3,r2
   20450:	e0bff817 	ldw	r2,-32(fp)
   20454:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   20458:	00231700 	call	23170 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
   2045c:	00800044 	movi	r2,1
   20460:	e0bff915 	stw	r2,-28(fp)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   20464:	e0fff717 	ldw	r3,-36(fp)
   20468:	00804034 	movhi	r2,256
   2046c:	10bfffc4 	addi	r2,r2,-1
   20470:	1884703a 	and	r2,r3,r2
   20474:	e0bff715 	stw	r2,-36(fp)
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
   20478:	e0bff717 	ldw	r2,-36(fp)
}
   2047c:	e037883a 	mov	sp,fp
   20480:	dfc00117 	ldw	ra,4(sp)
   20484:	df000017 	ldw	fp,0(sp)
   20488:	dec00204 	addi	sp,sp,8
   2048c:	f800283a 	ret

00020490 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
   20490:	defff304 	addi	sp,sp,-52
   20494:	dfc00c15 	stw	ra,48(sp)
   20498:	df000b15 	stw	fp,44(sp)
   2049c:	df000b04 	addi	fp,sp,44
   204a0:	e13ffc15 	stw	r4,-16(fp)
   204a4:	e17ffd15 	stw	r5,-12(fp)
   204a8:	e1bffe15 	stw	r6,-8(fp)
   204ac:	e1ffff15 	stw	r7,-4(fp)
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   204b0:	e0bffc17 	ldw	r2,-16(fp)
   204b4:	e0bff715 	stw	r2,-36(fp)
EventBits_t uxReturn, uxControlBits = 0;
   204b8:	e03ff615 	stw	zero,-40(fp)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
   204bc:	e03ff815 	stw	zero,-32(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
   204c0:	00227200 	call	22720 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   204c4:	e0bff717 	ldw	r2,-36(fp)
   204c8:	10800017 	ldw	r2,0(r2)
   204cc:	e0bff915 	stw	r2,-28(fp)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
   204d0:	e1bfff17 	ldw	r6,-4(fp)
   204d4:	e17ffd17 	ldw	r5,-12(fp)
   204d8:	e13ff917 	ldw	r4,-28(fp)
   204dc:	002093c0 	call	2093c <prvTestWaitCondition>
   204e0:	e0bffa15 	stw	r2,-24(fp)

		if( xWaitConditionMet != pdFALSE )
   204e4:	e0bffa17 	ldw	r2,-24(fp)
   204e8:	10000d26 	beq	r2,zero,20520 <xEventGroupWaitBits+0x90>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
   204ec:	e0bff917 	ldw	r2,-28(fp)
   204f0:	e0bff515 	stw	r2,-44(fp)
			xTicksToWait = ( TickType_t ) 0;
   204f4:	e0000215 	stw	zero,8(fp)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
   204f8:	e0bffe17 	ldw	r2,-8(fp)
   204fc:	10002026 	beq	r2,zero,20580 <xEventGroupWaitBits+0xf0>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   20500:	e0bff717 	ldw	r2,-36(fp)
   20504:	10c00017 	ldw	r3,0(r2)
   20508:	e0bffd17 	ldw	r2,-12(fp)
   2050c:	0084303a 	nor	r2,zero,r2
   20510:	1886703a 	and	r3,r3,r2
   20514:	e0bff717 	ldw	r2,-36(fp)
   20518:	10c00015 	stw	r3,0(r2)
   2051c:	00001806 	br	20580 <xEventGroupWaitBits+0xf0>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
   20520:	e0800217 	ldw	r2,8(fp)
   20524:	1000031e 	bne	r2,zero,20534 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
   20528:	e0bff917 	ldw	r2,-28(fp)
   2052c:	e0bff515 	stw	r2,-44(fp)
   20530:	00001306 	br	20580 <xEventGroupWaitBits+0xf0>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
   20534:	e0bffe17 	ldw	r2,-8(fp)
   20538:	10000326 	beq	r2,zero,20548 <xEventGroupWaitBits+0xb8>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   2053c:	e0bff617 	ldw	r2,-40(fp)
   20540:	10804034 	orhi	r2,r2,256
   20544:	e0bff615 	stw	r2,-40(fp)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
   20548:	e0bfff17 	ldw	r2,-4(fp)
   2054c:	10000326 	beq	r2,zero,2055c <xEventGroupWaitBits+0xcc>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   20550:	e0bff617 	ldw	r2,-40(fp)
   20554:	10810034 	orhi	r2,r2,1024
   20558:	e0bff615 	stw	r2,-40(fp)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   2055c:	e0bff717 	ldw	r2,-36(fp)
   20560:	11000104 	addi	r4,r2,4
   20564:	e0fffd17 	ldw	r3,-12(fp)
   20568:	e0bff617 	ldw	r2,-40(fp)
   2056c:	1884b03a 	or	r2,r3,r2
   20570:	e1800217 	ldw	r6,8(fp)
   20574:	100b883a 	mov	r5,r2
   20578:	0022c440 	call	22c44 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
   2057c:	e03ff515 	stw	zero,-44(fp)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
   20580:	002274c0 	call	2274c <xTaskResumeAll>
   20584:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
   20588:	e0800217 	ldw	r2,8(fp)
   2058c:	10002126 	beq	r2,zero,20614 <xEventGroupWaitBits+0x184>
	{
		if( xAlreadyYielded == pdFALSE )
   20590:	e0bffb17 	ldw	r2,-20(fp)
   20594:	1000011e 	bne	r2,zero,2059c <xEventGroupWaitBits+0x10c>
		{
			portYIELD_WITHIN_API();
   20598:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
   2059c:	00231d00 	call	231d0 <uxTaskResetEventItemValue>
   205a0:	e0bff515 	stw	r2,-44(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   205a4:	e0bff517 	ldw	r2,-44(fp)
   205a8:	1080802c 	andhi	r2,r2,512
   205ac:	1000141e 	bne	r2,zero,20600 <xEventGroupWaitBits+0x170>
		{
			taskENTER_CRITICAL();
   205b0:	002311c0 	call	2311c <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
   205b4:	e0bff717 	ldw	r2,-36(fp)
   205b8:	10800017 	ldw	r2,0(r2)
   205bc:	e0bff515 	stw	r2,-44(fp)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   205c0:	e1bfff17 	ldw	r6,-4(fp)
   205c4:	e17ffd17 	ldw	r5,-12(fp)
   205c8:	e13ff517 	ldw	r4,-44(fp)
   205cc:	002093c0 	call	2093c <prvTestWaitCondition>
   205d0:	10000926 	beq	r2,zero,205f8 <xEventGroupWaitBits+0x168>
				{
					if( xClearOnExit != pdFALSE )
   205d4:	e0bffe17 	ldw	r2,-8(fp)
   205d8:	10000726 	beq	r2,zero,205f8 <xEventGroupWaitBits+0x168>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   205dc:	e0bff717 	ldw	r2,-36(fp)
   205e0:	10c00017 	ldw	r3,0(r2)
   205e4:	e0bffd17 	ldw	r2,-12(fp)
   205e8:	0084303a 	nor	r2,zero,r2
   205ec:	1886703a 	and	r3,r3,r2
   205f0:	e0bff717 	ldw	r2,-36(fp)
   205f4:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   205f8:	00231700 	call	23170 <vTaskExitCritical>

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
   205fc:	e03ff815 	stw	zero,-32(fp)
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   20600:	e0fff517 	ldw	r3,-44(fp)
   20604:	00804034 	movhi	r2,256
   20608:	10bfffc4 	addi	r2,r2,-1
   2060c:	1884703a 	and	r2,r3,r2
   20610:	e0bff515 	stw	r2,-44(fp)
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
   20614:	e0bff517 	ldw	r2,-44(fp)
}
   20618:	e037883a 	mov	sp,fp
   2061c:	dfc00117 	ldw	ra,4(sp)
   20620:	df000017 	ldw	fp,0(sp)
   20624:	dec00204 	addi	sp,sp,8
   20628:	f800283a 	ret

0002062c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
   2062c:	defffa04 	addi	sp,sp,-24
   20630:	dfc00515 	stw	ra,20(sp)
   20634:	df000415 	stw	fp,16(sp)
   20638:	df000404 	addi	fp,sp,16
   2063c:	e13ffe15 	stw	r4,-8(fp)
   20640:	e17fff15 	stw	r5,-4(fp)
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   20644:	e0bffe17 	ldw	r2,-8(fp)
   20648:	e0bffc15 	stw	r2,-16(fp)
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
   2064c:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
   20650:	e0bffc17 	ldw	r2,-16(fp)
   20654:	10800017 	ldw	r2,0(r2)
   20658:	e0bffd15 	stw	r2,-12(fp)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
   2065c:	e0bffc17 	ldw	r2,-16(fp)
   20660:	10c00017 	ldw	r3,0(r2)
   20664:	e0bfff17 	ldw	r2,-4(fp)
   20668:	0084303a 	nor	r2,zero,r2
   2066c:	1886703a 	and	r3,r3,r2
   20670:	e0bffc17 	ldw	r2,-16(fp)
   20674:	10c00015 	stw	r3,0(r2)
	}
	taskEXIT_CRITICAL();
   20678:	00231700 	call	23170 <vTaskExitCritical>

	return uxReturn;
   2067c:	e0bffd17 	ldw	r2,-12(fp)
}
   20680:	e037883a 	mov	sp,fp
   20684:	dfc00117 	ldw	ra,4(sp)
   20688:	df000017 	ldw	fp,0(sp)
   2068c:	dec00204 	addi	sp,sp,8
   20690:	f800283a 	ret

00020694 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
   20694:	defffb04 	addi	sp,sp,-20
   20698:	df000415 	stw	fp,16(sp)
   2069c:	df000404 	addi	fp,sp,16
   206a0:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   206a4:	e0bfff17 	ldw	r2,-4(fp)
   206a8:	e0bffc15 	stw	r2,-16(fp)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   206ac:	e03ffd15 	stw	zero,-12(fp)
	{
		uxReturn = pxEventBits->uxEventBits;
   206b0:	e0bffc17 	ldw	r2,-16(fp)
   206b4:	10800017 	ldw	r2,0(r2)
   206b8:	e0bffe15 	stw	r2,-8(fp)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
   206bc:	e0bffe17 	ldw	r2,-8(fp)
}
   206c0:	e037883a 	mov	sp,fp
   206c4:	df000017 	ldw	fp,0(sp)
   206c8:	dec00104 	addi	sp,sp,4
   206cc:	f800283a 	ret

000206d0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
   206d0:	defff304 	addi	sp,sp,-52
   206d4:	dfc00c15 	stw	ra,48(sp)
   206d8:	df000b15 	stw	fp,44(sp)
   206dc:	df000b04 	addi	fp,sp,44
   206e0:	e13ffe15 	stw	r4,-8(fp)
   206e4:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   206e8:	e03ff615 	stw	zero,-40(fp)
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   206ec:	e0bffe17 	ldw	r2,-8(fp)
   206f0:	e0bff815 	stw	r2,-32(fp)
BaseType_t xMatchFound = pdFALSE;
   206f4:	e03ff715 	stw	zero,-36(fp)
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
   206f8:	e0bff817 	ldw	r2,-32(fp)
   206fc:	10800104 	addi	r2,r2,4
   20700:	e0bff915 	stw	r2,-28(fp)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   20704:	e0bff917 	ldw	r2,-28(fp)
   20708:	10800204 	addi	r2,r2,8
   2070c:	e0bffa15 	stw	r2,-24(fp)
	vTaskSuspendAll();
   20710:	00227200 	call	22720 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
   20714:	e0bff917 	ldw	r2,-28(fp)
   20718:	10800317 	ldw	r2,12(r2)
   2071c:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
   20720:	e0bff817 	ldw	r2,-32(fp)
   20724:	10c00017 	ldw	r3,0(r2)
   20728:	e0bfff17 	ldw	r2,-4(fp)
   2072c:	1886b03a 	or	r3,r3,r2
   20730:	e0bff817 	ldw	r2,-32(fp)
   20734:	10c00015 	stw	r3,0(r2)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
   20738:	00003306 	br	20808 <xEventGroupSetBits+0x138>
		{
			pxNext = listGET_NEXT( pxListItem );
   2073c:	e0bff517 	ldw	r2,-44(fp)
   20740:	10800117 	ldw	r2,4(r2)
   20744:	e0bffb15 	stw	r2,-20(fp)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   20748:	e0bff517 	ldw	r2,-44(fp)
   2074c:	10800017 	ldw	r2,0(r2)
   20750:	e0bffc15 	stw	r2,-16(fp)
			xMatchFound = pdFALSE;
   20754:	e03ff715 	stw	zero,-36(fp)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   20758:	e0bffc17 	ldw	r2,-16(fp)
   2075c:	10bfc02c 	andhi	r2,r2,65280
   20760:	e0bffd15 	stw	r2,-12(fp)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   20764:	e0fffc17 	ldw	r3,-16(fp)
   20768:	00804034 	movhi	r2,256
   2076c:	10bfffc4 	addi	r2,r2,-1
   20770:	1884703a 	and	r2,r3,r2
   20774:	e0bffc15 	stw	r2,-16(fp)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   20778:	e0bffd17 	ldw	r2,-12(fp)
   2077c:	1081002c 	andhi	r2,r2,1024
   20780:	1000081e 	bne	r2,zero,207a4 <xEventGroupSetBits+0xd4>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
   20784:	e0bff817 	ldw	r2,-32(fp)
   20788:	10c00017 	ldw	r3,0(r2)
   2078c:	e0bffc17 	ldw	r2,-16(fp)
   20790:	1884703a 	and	r2,r3,r2
   20794:	10000b26 	beq	r2,zero,207c4 <xEventGroupSetBits+0xf4>
				{
					xMatchFound = pdTRUE;
   20798:	00800044 	movi	r2,1
   2079c:	e0bff715 	stw	r2,-36(fp)
   207a0:	00000806 	br	207c4 <xEventGroupSetBits+0xf4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   207a4:	e0bff817 	ldw	r2,-32(fp)
   207a8:	10c00017 	ldw	r3,0(r2)
   207ac:	e0bffc17 	ldw	r2,-16(fp)
   207b0:	1886703a 	and	r3,r3,r2
   207b4:	e0bffc17 	ldw	r2,-16(fp)
   207b8:	1880021e 	bne	r3,r2,207c4 <xEventGroupSetBits+0xf4>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
   207bc:	00800044 	movi	r2,1
   207c0:	e0bff715 	stw	r2,-36(fp)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
   207c4:	e0bff717 	ldw	r2,-36(fp)
   207c8:	10000d26 	beq	r2,zero,20800 <xEventGroupSetBits+0x130>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   207cc:	e0bffd17 	ldw	r2,-12(fp)
   207d0:	1080402c 	andhi	r2,r2,256
   207d4:	10000426 	beq	r2,zero,207e8 <xEventGroupSetBits+0x118>
				{
					uxBitsToClear |= uxBitsWaitedFor;
   207d8:	e0fff617 	ldw	r3,-40(fp)
   207dc:	e0bffc17 	ldw	r2,-16(fp)
   207e0:	1884b03a 	or	r2,r3,r2
   207e4:	e0bff615 	stw	r2,-40(fp)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   207e8:	e0bff817 	ldw	r2,-32(fp)
   207ec:	10800017 	ldw	r2,0(r2)
   207f0:	10808034 	orhi	r2,r2,512
   207f4:	100b883a 	mov	r5,r2
   207f8:	e13ff517 	ldw	r4,-44(fp)
   207fc:	0022d9c0 	call	22d9c <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
   20800:	e0bffb17 	ldw	r2,-20(fp)
   20804:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
   20808:	e0fff517 	ldw	r3,-44(fp)
   2080c:	e0bffa17 	ldw	r2,-24(fp)
   20810:	18bfca1e 	bne	r3,r2,2073c <__reset+0xfff8073c>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
   20814:	e0bff817 	ldw	r2,-32(fp)
   20818:	10c00017 	ldw	r3,0(r2)
   2081c:	e0bff617 	ldw	r2,-40(fp)
   20820:	0084303a 	nor	r2,zero,r2
   20824:	1886703a 	and	r3,r3,r2
   20828:	e0bff817 	ldw	r2,-32(fp)
   2082c:	10c00015 	stw	r3,0(r2)
	}
	( void ) xTaskResumeAll();
   20830:	002274c0 	call	2274c <xTaskResumeAll>

	return pxEventBits->uxEventBits;
   20834:	e0bff817 	ldw	r2,-32(fp)
   20838:	10800017 	ldw	r2,0(r2)
}
   2083c:	e037883a 	mov	sp,fp
   20840:	dfc00117 	ldw	ra,4(sp)
   20844:	df000017 	ldw	fp,0(sp)
   20848:	dec00204 	addi	sp,sp,8
   2084c:	f800283a 	ret

00020850 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
   20850:	defffb04 	addi	sp,sp,-20
   20854:	dfc00415 	stw	ra,16(sp)
   20858:	df000315 	stw	fp,12(sp)
   2085c:	df000304 	addi	fp,sp,12
   20860:	e13fff15 	stw	r4,-4(fp)
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   20864:	e0bfff17 	ldw	r2,-4(fp)
   20868:	e0bffd15 	stw	r2,-12(fp)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   2086c:	e0bffd17 	ldw	r2,-12(fp)
   20870:	10800104 	addi	r2,r2,4
   20874:	e0bffe15 	stw	r2,-8(fp)

	vTaskSuspendAll();
   20878:	00227200 	call	22720 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
   2087c:	00000506 	br	20894 <vEventGroupDelete+0x44>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   20880:	e0bffe17 	ldw	r2,-8(fp)
   20884:	10800317 	ldw	r2,12(r2)
   20888:	01408034 	movhi	r5,512
   2088c:	1009883a 	mov	r4,r2
   20890:	0022d9c0 	call	22d9c <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
   20894:	e0bffe17 	ldw	r2,-8(fp)
   20898:	10800017 	ldw	r2,0(r2)
   2089c:	103ff81e 	bne	r2,zero,20880 <__reset+0xfff80880>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
   208a0:	e13ffd17 	ldw	r4,-12(fp)
   208a4:	0020a680 	call	20a68 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
   208a8:	002274c0 	call	2274c <xTaskResumeAll>
}
   208ac:	0001883a 	nop
   208b0:	e037883a 	mov	sp,fp
   208b4:	dfc00117 	ldw	ra,4(sp)
   208b8:	df000017 	ldw	fp,0(sp)
   208bc:	dec00204 	addi	sp,sp,8
   208c0:	f800283a 	ret

000208c4 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
   208c4:	defffc04 	addi	sp,sp,-16
   208c8:	dfc00315 	stw	ra,12(sp)
   208cc:	df000215 	stw	fp,8(sp)
   208d0:	df000204 	addi	fp,sp,8
   208d4:	e13ffe15 	stw	r4,-8(fp)
   208d8:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
   208dc:	e17fff17 	ldw	r5,-4(fp)
   208e0:	e13ffe17 	ldw	r4,-8(fp)
   208e4:	00206d00 	call	206d0 <xEventGroupSetBits>
}
   208e8:	0001883a 	nop
   208ec:	e037883a 	mov	sp,fp
   208f0:	dfc00117 	ldw	ra,4(sp)
   208f4:	df000017 	ldw	fp,0(sp)
   208f8:	dec00204 	addi	sp,sp,8
   208fc:	f800283a 	ret

00020900 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
   20900:	defffc04 	addi	sp,sp,-16
   20904:	dfc00315 	stw	ra,12(sp)
   20908:	df000215 	stw	fp,8(sp)
   2090c:	df000204 	addi	fp,sp,8
   20910:	e13ffe15 	stw	r4,-8(fp)
   20914:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   20918:	e17fff17 	ldw	r5,-4(fp)
   2091c:	e13ffe17 	ldw	r4,-8(fp)
   20920:	002062c0 	call	2062c <xEventGroupClearBits>
}
   20924:	0001883a 	nop
   20928:	e037883a 	mov	sp,fp
   2092c:	dfc00117 	ldw	ra,4(sp)
   20930:	df000017 	ldw	fp,0(sp)
   20934:	dec00204 	addi	sp,sp,8
   20938:	f800283a 	ret

0002093c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
   2093c:	defffb04 	addi	sp,sp,-20
   20940:	df000415 	stw	fp,16(sp)
   20944:	df000404 	addi	fp,sp,16
   20948:	e13ffd15 	stw	r4,-12(fp)
   2094c:	e17ffe15 	stw	r5,-8(fp)
   20950:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xWaitConditionMet = pdFALSE;
   20954:	e03ffc15 	stw	zero,-16(fp)

	if( xWaitForAllBits == pdFALSE )
   20958:	e0bfff17 	ldw	r2,-4(fp)
   2095c:	1000071e 	bne	r2,zero,2097c <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   20960:	e0fffd17 	ldw	r3,-12(fp)
   20964:	e0bffe17 	ldw	r2,-8(fp)
   20968:	1884703a 	and	r2,r3,r2
   2096c:	10000a26 	beq	r2,zero,20998 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
   20970:	00800044 	movi	r2,1
   20974:	e0bffc15 	stw	r2,-16(fp)
   20978:	00000706 	br	20998 <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   2097c:	e0fffd17 	ldw	r3,-12(fp)
   20980:	e0bffe17 	ldw	r2,-8(fp)
   20984:	1886703a 	and	r3,r3,r2
   20988:	e0bffe17 	ldw	r2,-8(fp)
   2098c:	1880021e 	bne	r3,r2,20998 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
   20990:	00800044 	movi	r2,1
   20994:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
   20998:	e0bffc17 	ldw	r2,-16(fp)
}
   2099c:	e037883a 	mov	sp,fp
   209a0:	df000017 	ldw	fp,0(sp)
   209a4:	dec00104 	addi	sp,sp,4
   209a8:	f800283a 	ret

000209ac <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   209ac:	defffc04 	addi	sp,sp,-16
   209b0:	dfc00315 	stw	ra,12(sp)
   209b4:	df000215 	stw	fp,8(sp)
   209b8:	df000204 	addi	fp,sp,8
   209bc:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
   209c0:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   209c4:	e0bfff17 	ldw	r2,-4(fp)
   209c8:	108000cc 	andi	r2,r2,3
   209cc:	10000526 	beq	r2,zero,209e4 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   209d0:	e0ffff17 	ldw	r3,-4(fp)
   209d4:	00bfff04 	movi	r2,-4
   209d8:	1884703a 	and	r2,r3,r2
   209dc:	10800104 	addi	r2,r2,4
   209e0:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
   209e4:	00227200 	call	22720 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
   209e8:	d0a01b17 	ldw	r2,-32660(gp)
   209ec:	1000051e 	bne	r2,zero,20a04 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   209f0:	008000f4 	movhi	r2,3
   209f4:	10934f04 	addi	r2,r2,19772
   209f8:	00ffff04 	movi	r3,-4
   209fc:	10c4703a 	and	r2,r2,r3
   20a00:	d0a01b15 	stw	r2,-32660(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   20a04:	d0e01a17 	ldw	r3,-32664(gp)
   20a08:	e0bfff17 	ldw	r2,-4(fp)
   20a0c:	1885883a 	add	r2,r3,r2
   20a10:	108fff28 	cmpgeui	r2,r2,16380
   20a14:	10000d1e 	bne	r2,zero,20a4c <pvPortMalloc+0xa0>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
   20a18:	d0e01a17 	ldw	r3,-32664(gp)
   20a1c:	e0bfff17 	ldw	r2,-4(fp)
   20a20:	1885883a 	add	r2,r3,r2
   20a24:	d0e01a17 	ldw	r3,-32664(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   20a28:	1880082e 	bgeu	r3,r2,20a4c <pvPortMalloc+0xa0>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
   20a2c:	d0e01b17 	ldw	r3,-32660(gp)
   20a30:	d0a01a17 	ldw	r2,-32664(gp)
   20a34:	1885883a 	add	r2,r3,r2
   20a38:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
   20a3c:	d0e01a17 	ldw	r3,-32664(gp)
   20a40:	e0bfff17 	ldw	r2,-4(fp)
   20a44:	1885883a 	add	r2,r3,r2
   20a48:	d0a01a15 	stw	r2,-32664(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   20a4c:	002274c0 	call	2274c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   20a50:	e0bffe17 	ldw	r2,-8(fp)
}
   20a54:	e037883a 	mov	sp,fp
   20a58:	dfc00117 	ldw	ra,4(sp)
   20a5c:	df000017 	ldw	fp,0(sp)
   20a60:	dec00204 	addi	sp,sp,8
   20a64:	f800283a 	ret

00020a68 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   20a68:	defffe04 	addi	sp,sp,-8
   20a6c:	df000115 	stw	fp,4(sp)
   20a70:	df000104 	addi	fp,sp,4
   20a74:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
   20a78:	0001883a 	nop
   20a7c:	e037883a 	mov	sp,fp
   20a80:	df000017 	ldw	fp,0(sp)
   20a84:	dec00104 	addi	sp,sp,4
   20a88:	f800283a 	ret

00020a8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
   20a8c:	deffff04 	addi	sp,sp,-4
   20a90:	df000015 	stw	fp,0(sp)
   20a94:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
   20a98:	d0201a15 	stw	zero,-32664(gp)
}
   20a9c:	0001883a 	nop
   20aa0:	e037883a 	mov	sp,fp
   20aa4:	df000017 	ldw	fp,0(sp)
   20aa8:	dec00104 	addi	sp,sp,4
   20aac:	f800283a 	ret

00020ab0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
   20ab0:	deffff04 	addi	sp,sp,-4
   20ab4:	df000015 	stw	fp,0(sp)
   20ab8:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
   20abc:	d0a01a17 	ldw	r2,-32664(gp)
   20ac0:	00cfff04 	movi	r3,16380
   20ac4:	1885c83a 	sub	r2,r3,r2
}
   20ac8:	e037883a 	mov	sp,fp
   20acc:	df000017 	ldw	fp,0(sp)
   20ad0:	dec00104 	addi	sp,sp,4
   20ad4:	f800283a 	ret

00020ad8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   20ad8:	defffe04 	addi	sp,sp,-8
   20adc:	df000115 	stw	fp,4(sp)
   20ae0:	df000104 	addi	fp,sp,4
   20ae4:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   20ae8:	e0bfff17 	ldw	r2,-4(fp)
   20aec:	10c00204 	addi	r3,r2,8
   20af0:	e0bfff17 	ldw	r2,-4(fp)
   20af4:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   20af8:	e0bfff17 	ldw	r2,-4(fp)
   20afc:	00ffffc4 	movi	r3,-1
   20b00:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   20b04:	e0bfff17 	ldw	r2,-4(fp)
   20b08:	10c00204 	addi	r3,r2,8
   20b0c:	e0bfff17 	ldw	r2,-4(fp)
   20b10:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   20b14:	e0bfff17 	ldw	r2,-4(fp)
   20b18:	10c00204 	addi	r3,r2,8
   20b1c:	e0bfff17 	ldw	r2,-4(fp)
   20b20:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   20b24:	e0bfff17 	ldw	r2,-4(fp)
   20b28:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   20b2c:	0001883a 	nop
   20b30:	e037883a 	mov	sp,fp
   20b34:	df000017 	ldw	fp,0(sp)
   20b38:	dec00104 	addi	sp,sp,4
   20b3c:	f800283a 	ret

00020b40 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   20b40:	defffe04 	addi	sp,sp,-8
   20b44:	df000115 	stw	fp,4(sp)
   20b48:	df000104 	addi	fp,sp,4
   20b4c:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   20b50:	e0bfff17 	ldw	r2,-4(fp)
   20b54:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   20b58:	0001883a 	nop
   20b5c:	e037883a 	mov	sp,fp
   20b60:	df000017 	ldw	fp,0(sp)
   20b64:	dec00104 	addi	sp,sp,4
   20b68:	f800283a 	ret

00020b6c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   20b6c:	defffc04 	addi	sp,sp,-16
   20b70:	df000315 	stw	fp,12(sp)
   20b74:	df000304 	addi	fp,sp,12
   20b78:	e13ffe15 	stw	r4,-8(fp)
   20b7c:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
   20b80:	e0bffe17 	ldw	r2,-8(fp)
   20b84:	10800117 	ldw	r2,4(r2)
   20b88:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   20b8c:	e0bfff17 	ldw	r2,-4(fp)
   20b90:	e0fffd17 	ldw	r3,-12(fp)
   20b94:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   20b98:	e0bffd17 	ldw	r2,-12(fp)
   20b9c:	10c00217 	ldw	r3,8(r2)
   20ba0:	e0bfff17 	ldw	r2,-4(fp)
   20ba4:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   20ba8:	e0bffd17 	ldw	r2,-12(fp)
   20bac:	10800217 	ldw	r2,8(r2)
   20bb0:	e0ffff17 	ldw	r3,-4(fp)
   20bb4:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
   20bb8:	e0bffd17 	ldw	r2,-12(fp)
   20bbc:	e0ffff17 	ldw	r3,-4(fp)
   20bc0:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   20bc4:	e0bfff17 	ldw	r2,-4(fp)
   20bc8:	e0fffe17 	ldw	r3,-8(fp)
   20bcc:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
   20bd0:	e0bffe17 	ldw	r2,-8(fp)
   20bd4:	10800017 	ldw	r2,0(r2)
   20bd8:	10c00044 	addi	r3,r2,1
   20bdc:	e0bffe17 	ldw	r2,-8(fp)
   20be0:	10c00015 	stw	r3,0(r2)
}
   20be4:	0001883a 	nop
   20be8:	e037883a 	mov	sp,fp
   20bec:	df000017 	ldw	fp,0(sp)
   20bf0:	dec00104 	addi	sp,sp,4
   20bf4:	f800283a 	ret

00020bf8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   20bf8:	defffb04 	addi	sp,sp,-20
   20bfc:	df000415 	stw	fp,16(sp)
   20c00:	df000404 	addi	fp,sp,16
   20c04:	e13ffe15 	stw	r4,-8(fp)
   20c08:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   20c0c:	e0bfff17 	ldw	r2,-4(fp)
   20c10:	10800017 	ldw	r2,0(r2)
   20c14:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   20c18:	e0bffd17 	ldw	r2,-12(fp)
   20c1c:	10bfffd8 	cmpnei	r2,r2,-1
   20c20:	1000041e 	bne	r2,zero,20c34 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   20c24:	e0bffe17 	ldw	r2,-8(fp)
   20c28:	10800417 	ldw	r2,16(r2)
   20c2c:	e0bffc15 	stw	r2,-16(fp)
   20c30:	00000c06 	br	20c64 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   20c34:	e0bffe17 	ldw	r2,-8(fp)
   20c38:	10800204 	addi	r2,r2,8
   20c3c:	e0bffc15 	stw	r2,-16(fp)
   20c40:	00000306 	br	20c50 <vListInsert+0x58>
   20c44:	e0bffc17 	ldw	r2,-16(fp)
   20c48:	10800117 	ldw	r2,4(r2)
   20c4c:	e0bffc15 	stw	r2,-16(fp)
   20c50:	e0bffc17 	ldw	r2,-16(fp)
   20c54:	10800117 	ldw	r2,4(r2)
   20c58:	10800017 	ldw	r2,0(r2)
   20c5c:	e0fffd17 	ldw	r3,-12(fp)
   20c60:	18bff82e 	bgeu	r3,r2,20c44 <__reset+0xfff80c44>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   20c64:	e0bffc17 	ldw	r2,-16(fp)
   20c68:	10c00117 	ldw	r3,4(r2)
   20c6c:	e0bfff17 	ldw	r2,-4(fp)
   20c70:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   20c74:	e0bfff17 	ldw	r2,-4(fp)
   20c78:	10800117 	ldw	r2,4(r2)
   20c7c:	e0ffff17 	ldw	r3,-4(fp)
   20c80:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
   20c84:	e0bfff17 	ldw	r2,-4(fp)
   20c88:	e0fffc17 	ldw	r3,-16(fp)
   20c8c:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
   20c90:	e0bffc17 	ldw	r2,-16(fp)
   20c94:	e0ffff17 	ldw	r3,-4(fp)
   20c98:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   20c9c:	e0bfff17 	ldw	r2,-4(fp)
   20ca0:	e0fffe17 	ldw	r3,-8(fp)
   20ca4:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
   20ca8:	e0bffe17 	ldw	r2,-8(fp)
   20cac:	10800017 	ldw	r2,0(r2)
   20cb0:	10c00044 	addi	r3,r2,1
   20cb4:	e0bffe17 	ldw	r2,-8(fp)
   20cb8:	10c00015 	stw	r3,0(r2)
}
   20cbc:	0001883a 	nop
   20cc0:	e037883a 	mov	sp,fp
   20cc4:	df000017 	ldw	fp,0(sp)
   20cc8:	dec00104 	addi	sp,sp,4
   20ccc:	f800283a 	ret

00020cd0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   20cd0:	defffd04 	addi	sp,sp,-12
   20cd4:	df000215 	stw	fp,8(sp)
   20cd8:	df000204 	addi	fp,sp,8
   20cdc:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   20ce0:	e0bfff17 	ldw	r2,-4(fp)
   20ce4:	10800417 	ldw	r2,16(r2)
   20ce8:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   20cec:	e0bfff17 	ldw	r2,-4(fp)
   20cf0:	10800117 	ldw	r2,4(r2)
   20cf4:	e0ffff17 	ldw	r3,-4(fp)
   20cf8:	18c00217 	ldw	r3,8(r3)
   20cfc:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   20d00:	e0bfff17 	ldw	r2,-4(fp)
   20d04:	10800217 	ldw	r2,8(r2)
   20d08:	e0ffff17 	ldw	r3,-4(fp)
   20d0c:	18c00117 	ldw	r3,4(r3)
   20d10:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   20d14:	e0bffe17 	ldw	r2,-8(fp)
   20d18:	10c00117 	ldw	r3,4(r2)
   20d1c:	e0bfff17 	ldw	r2,-4(fp)
   20d20:	1880041e 	bne	r3,r2,20d34 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   20d24:	e0bfff17 	ldw	r2,-4(fp)
   20d28:	10c00217 	ldw	r3,8(r2)
   20d2c:	e0bffe17 	ldw	r2,-8(fp)
   20d30:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   20d34:	e0bfff17 	ldw	r2,-4(fp)
   20d38:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
   20d3c:	e0bffe17 	ldw	r2,-8(fp)
   20d40:	10800017 	ldw	r2,0(r2)
   20d44:	10ffffc4 	addi	r3,r2,-1
   20d48:	e0bffe17 	ldw	r2,-8(fp)
   20d4c:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
   20d50:	e0bffe17 	ldw	r2,-8(fp)
   20d54:	10800017 	ldw	r2,0(r2)
}
   20d58:	e037883a 	mov	sp,fp
   20d5c:	df000017 	ldw	fp,0(sp)
   20d60:	dec00104 	addi	sp,sp,4
   20d64:	f800283a 	ret

00020d68 <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
   20d68:	defffe04 	addi	sp,sp,-8
   20d6c:	df000115 	stw	fp,4(sp)
   20d70:	df000104 	addi	fp,sp,4
   20d74:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
   20d78:	e0bfff17 	ldw	r2,-4(fp)
   20d7c:	16800015 	stw	gp,0(r2)
}
   20d80:	0001883a 	nop
   20d84:	e037883a 	mov	sp,fp
   20d88:	df000017 	ldw	fp,0(sp)
   20d8c:	dec00104 	addi	sp,sp,4
   20d90:	f800283a 	ret

00020d94 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
   20d94:	defff904 	addi	sp,sp,-28
   20d98:	dfc00615 	stw	ra,24(sp)
   20d9c:	df000515 	stw	fp,20(sp)
   20da0:	df000504 	addi	fp,sp,20
   20da4:	e13ffd15 	stw	r4,-12(fp)
   20da8:	e17ffe15 	stw	r5,-8(fp)
   20dac:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
   20db0:	e0bffd17 	ldw	r2,-12(fp)
   20db4:	10bfff04 	addi	r2,r2,-4
   20db8:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
   20dbc:	e0bffc04 	addi	r2,fp,-16
   20dc0:	1009883a 	mov	r4,r2
   20dc4:	0020d680 	call	20d68 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
   20dc8:	e0fffd17 	ldw	r3,-12(fp)
   20dcc:	00b7abb4 	movhi	r2,57006
   20dd0:	10afbbc4 	addi	r2,r2,-16657
   20dd4:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
   20dd8:	e0bffd17 	ldw	r2,-12(fp)
   20ddc:	10bfff04 	addi	r2,r2,-4
   20de0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
   20de4:	e0fffb17 	ldw	r3,-20(fp)
   20de8:	e0bffd17 	ldw	r2,-12(fp)
   20dec:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
   20df0:	e0bffd17 	ldw	r2,-12(fp)
   20df4:	10bfff04 	addi	r2,r2,-4
   20df8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
   20dfc:	e0fffc17 	ldw	r3,-16(fp)
   20e00:	e0bffd17 	ldw	r2,-12(fp)
   20e04:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
   20e08:	e0bffd17 	ldw	r2,-12(fp)
   20e0c:	10bff704 	addi	r2,r2,-36
   20e10:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
   20e14:	e0fffe17 	ldw	r3,-8(fp)
   20e18:	e0bffd17 	ldw	r2,-12(fp)
   20e1c:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
   20e20:	e0bffd17 	ldw	r2,-12(fp)
   20e24:	10bfff04 	addi	r2,r2,-4
   20e28:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
   20e2c:	e0bffd17 	ldw	r2,-12(fp)
   20e30:	00c00044 	movi	r3,1
   20e34:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
   20e38:	e0bffd17 	ldw	r2,-12(fp)
   20e3c:	10bff404 	addi	r2,r2,-48
   20e40:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
   20e44:	e0ffff17 	ldw	r3,-4(fp)
   20e48:	e0bffd17 	ldw	r2,-12(fp)
   20e4c:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
   20e50:	e0bffd17 	ldw	r2,-12(fp)
   20e54:	10bffb04 	addi	r2,r2,-20
   20e58:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
   20e5c:	e0bffd17 	ldw	r2,-12(fp)
}
   20e60:	e037883a 	mov	sp,fp
   20e64:	dfc00117 	ldw	ra,4(sp)
   20e68:	df000017 	ldw	fp,0(sp)
   20e6c:	dec00204 	addi	sp,sp,8
   20e70:	f800283a 	ret

00020e74 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
   20e74:	defffe04 	addi	sp,sp,-8
   20e78:	dfc00115 	stw	ra,4(sp)
   20e7c:	df000015 	stw	fp,0(sp)
   20e80:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
   20e84:	0020ecc0 	call	20ecc <prvSetupTimerInterrupt>
   20e88:	008000b4 	movhi	r2,2
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
   20e8c:	10803104 	addi	r2,r2,196
   20e90:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
   20e94:	0005883a 	mov	r2,zero
}
   20e98:	e037883a 	mov	sp,fp
   20e9c:	dfc00117 	ldw	ra,4(sp)
   20ea0:	df000017 	ldw	fp,0(sp)
   20ea4:	dec00204 	addi	sp,sp,8
   20ea8:	f800283a 	ret

00020eac <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   20eac:	deffff04 	addi	sp,sp,-4
   20eb0:	df000015 	stw	fp,0(sp)
   20eb4:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
   20eb8:	0001883a 	nop
   20ebc:	e037883a 	mov	sp,fp
   20ec0:	df000017 	ldw	fp,0(sp)
   20ec4:	dec00104 	addi	sp,sp,4
   20ec8:	f800283a 	ret

00020ecc <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
   20ecc:	defffe04 	addi	sp,sp,-8
   20ed0:	dfc00115 	stw	ra,4(sp)
   20ed4:	df000015 	stw	fp,0(sp)
   20ed8:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( TIMER_0_NIOS2_IRQ, 0x0, vPortSysTickHandler ) )
   20edc:	018000b4 	movhi	r6,2
   20ee0:	3183d504 	addi	r6,r6,3924
   20ee4:	000b883a 	mov	r5,zero
   20ee8:	01000084 	movi	r4,2
   20eec:	0020f9c0 	call	20f9c <alt_irq_register>
   20ef0:	10bffa98 	cmpnei	r2,r2,-22
   20ef4:	1000021e 	bne	r2,zero,20f00 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
   20ef8:	003da03a 	break	0
   20efc:	00000c06 	br	20f30 <prvSetupTimerInterrupt+0x64>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_NIOS2_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
   20f00:	00c00204 	movi	r3,8
   20f04:	00800104 	movi	r2,4
   20f08:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( TIMER_0_NIOS2_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
   20f0c:	00f42414 	movui	r3,53392
   20f10:	00800204 	movi	r2,8
   20f14:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( TIMER_0_NIOS2_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
   20f18:	00c000c4 	movi	r3,3
   20f1c:	00800304 	movi	r2,12
   20f20:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_NIOS2_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
   20f24:	00c001c4 	movi	r3,7
   20f28:	00800104 	movi	r2,4
   20f2c:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_NIOS2_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
   20f30:	00bfff84 	movi	r2,-2
   20f34:	0007883a 	mov	r3,zero
   20f38:	18800035 	stwio	r2,0(r3)
}
   20f3c:	0001883a 	nop
   20f40:	e037883a 	mov	sp,fp
   20f44:	dfc00117 	ldw	ra,4(sp)
   20f48:	df000017 	ldw	fp,0(sp)
   20f4c:	dec00204 	addi	sp,sp,8
   20f50:	f800283a 	ret

00020f54 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
   20f54:	defffc04 	addi	sp,sp,-16
   20f58:	dfc00315 	stw	ra,12(sp)
   20f5c:	df000215 	stw	fp,8(sp)
   20f60:	df000204 	addi	fp,sp,8
   20f64:	e13ffe15 	stw	r4,-8(fp)
   20f68:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
   20f6c:	00229580 	call	22958 <xTaskIncrementTick>
   20f70:	10000126 	beq	r2,zero,20f78 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
   20f74:	0022b1c0 	call	22b1c <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_NIOS2_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
   20f78:	00bfff84 	movi	r2,-2
   20f7c:	0007883a 	mov	r3,zero
   20f80:	18800035 	stwio	r2,0(r3)
}
   20f84:	0001883a 	nop
   20f88:	e037883a 	mov	sp,fp
   20f8c:	dfc00117 	ldw	ra,4(sp)
   20f90:	df000017 	ldw	fp,0(sp)
   20f94:	dec00204 	addi	sp,sp,8
   20f98:	f800283a 	ret

00020f9c <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
{
   20f9c:	defff104 	addi	sp,sp,-60
   20fa0:	df000e15 	stw	fp,56(sp)
   20fa4:	df000e04 	addi	fp,sp,56
   20fa8:	e13ffd15 	stw	r4,-12(fp)
   20fac:	e17ffe15 	stw	r5,-8(fp)
   20fb0:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
   20fb4:	00bffa84 	movi	r2,-22
   20fb8:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
   20fbc:	e0bffd17 	ldw	r2,-12(fp)
   20fc0:	10800828 	cmpgeui	r2,r2,32
   20fc4:	10004c1e 	bne	r2,zero,210f8 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   20fc8:	0005303a 	rdctl	r2,status
   20fcc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20fd0:	e0fff617 	ldw	r3,-40(fp)
   20fd4:	00bfff84 	movi	r2,-2
   20fd8:	1884703a 	and	r2,r3,r2
   20fdc:	1001703a 	wrctl	status,r2
  
  return context;
   20fe0:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all ();
   20fe4:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
   20fe8:	00800134 	movhi	r2,4
   20fec:	10a3c604 	addi	r2,r2,-28904
   20ff0:	e0fffd17 	ldw	r3,-12(fp)
   20ff4:	180690fa 	slli	r3,r3,3
   20ff8:	10c5883a 	add	r2,r2,r3
   20ffc:	e0ffff17 	ldw	r3,-4(fp)
   21000:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
   21004:	00800134 	movhi	r2,4
   21008:	10a3c604 	addi	r2,r2,-28904
   2100c:	e0fffd17 	ldw	r3,-12(fp)
   21010:	180690fa 	slli	r3,r3,3
   21014:	10c5883a 	add	r2,r2,r3
   21018:	10800104 	addi	r2,r2,4
   2101c:	e0fffe17 	ldw	r3,-8(fp)
   21020:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
   21024:	e0bfff17 	ldw	r2,-4(fp)
   21028:	10001926 	beq	r2,zero,21090 <alt_irq_register+0xf4>
   2102c:	e0bffd17 	ldw	r2,-12(fp)
   21030:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   21034:	0005303a 	rdctl	r2,status
   21038:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2103c:	e0fff717 	ldw	r3,-36(fp)
   21040:	00bfff84 	movi	r2,-2
   21044:	1884703a 	and	r2,r3,r2
   21048:	1001703a 	wrctl	status,r2
  
  return context;
   2104c:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   21050:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
   21054:	00c00044 	movi	r3,1
   21058:	e0bff317 	ldw	r2,-52(fp)
   2105c:	1884983a 	sll	r2,r3,r2
   21060:	1007883a 	mov	r3,r2
   21064:	d0a03717 	ldw	r2,-32548(gp)
   21068:	1884b03a 	or	r2,r3,r2
   2106c:	d0a03715 	stw	r2,-32548(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   21070:	d0a03717 	ldw	r2,-32548(gp)
   21074:	100170fa 	wrctl	ienable,r2
   21078:	e0bff817 	ldw	r2,-32(fp)
   2107c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   21080:	e0bff917 	ldw	r2,-28(fp)
   21084:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   21088:	0005883a 	mov	r2,zero
   2108c:	00001906 	br	210f4 <alt_irq_register+0x158>
   21090:	e0bffd17 	ldw	r2,-12(fp)
   21094:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   21098:	0005303a 	rdctl	r2,status
   2109c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   210a0:	e0fffa17 	ldw	r3,-24(fp)
   210a4:	00bfff84 	movi	r2,-2
   210a8:	1884703a 	and	r2,r3,r2
   210ac:	1001703a 	wrctl	status,r2
  
  return context;
   210b0:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   210b4:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
   210b8:	00c00044 	movi	r3,1
   210bc:	e0bff517 	ldw	r2,-44(fp)
   210c0:	1884983a 	sll	r2,r3,r2
   210c4:	0084303a 	nor	r2,zero,r2
   210c8:	1007883a 	mov	r3,r2
   210cc:	d0a03717 	ldw	r2,-32548(gp)
   210d0:	1884703a 	and	r2,r3,r2
   210d4:	d0a03715 	stw	r2,-32548(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   210d8:	d0a03717 	ldw	r2,-32548(gp)
   210dc:	100170fa 	wrctl	ienable,r2
   210e0:	e0bffb17 	ldw	r2,-20(fp)
   210e4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   210e8:	e0bffc17 	ldw	r2,-16(fp)
   210ec:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   210f0:	0005883a 	mov	r2,zero
   210f4:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
   210f8:	e0bff217 	ldw	r2,-56(fp)
}
   210fc:	e037883a 	mov	sp,fp
   21100:	df000017 	ldw	fp,0(sp)
   21104:	dec00104 	addi	sp,sp,4
   21108:	f800283a 	ret

0002110c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   2110c:	defffb04 	addi	sp,sp,-20
   21110:	dfc00415 	stw	ra,16(sp)
   21114:	df000315 	stw	fp,12(sp)
   21118:	df000304 	addi	fp,sp,12
   2111c:	e13ffe15 	stw	r4,-8(fp)
   21120:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   21124:	e0bffe17 	ldw	r2,-8(fp)
   21128:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   2112c:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   21130:	e0bffd17 	ldw	r2,-12(fp)
   21134:	10c00017 	ldw	r3,0(r2)
   21138:	e0bffd17 	ldw	r2,-12(fp)
   2113c:	11000f17 	ldw	r4,60(r2)
   21140:	e0bffd17 	ldw	r2,-12(fp)
   21144:	10801017 	ldw	r2,64(r2)
   21148:	2085383a 	mul	r2,r4,r2
   2114c:	1887883a 	add	r3,r3,r2
   21150:	e0bffd17 	ldw	r2,-12(fp)
   21154:	10c00115 	stw	r3,4(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   21158:	e0bffd17 	ldw	r2,-12(fp)
   2115c:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
   21160:	e0bffd17 	ldw	r2,-12(fp)
   21164:	10c00017 	ldw	r3,0(r2)
   21168:	e0bffd17 	ldw	r2,-12(fp)
   2116c:	10c00215 	stw	r3,8(r2)
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   21170:	e0bffd17 	ldw	r2,-12(fp)
   21174:	10c00017 	ldw	r3,0(r2)
   21178:	e0bffd17 	ldw	r2,-12(fp)
   2117c:	10800f17 	ldw	r2,60(r2)
   21180:	113fffc4 	addi	r4,r2,-1
   21184:	e0bffd17 	ldw	r2,-12(fp)
   21188:	10801017 	ldw	r2,64(r2)
   2118c:	2085383a 	mul	r2,r4,r2
   21190:	1887883a 	add	r3,r3,r2
   21194:	e0bffd17 	ldw	r2,-12(fp)
   21198:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
   2119c:	e0bffd17 	ldw	r2,-12(fp)
   211a0:	00ffffc4 	movi	r3,-1
   211a4:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
   211a8:	e0bffd17 	ldw	r2,-12(fp)
   211ac:	00ffffc4 	movi	r3,-1
   211b0:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
   211b4:	e0bfff17 	ldw	r2,-4(fp)
   211b8:	10000a1e 	bne	r2,zero,211e4 <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   211bc:	e0bffd17 	ldw	r2,-12(fp)
   211c0:	10800417 	ldw	r2,16(r2)
   211c4:	10000f26 	beq	r2,zero,21204 <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   211c8:	e0bffd17 	ldw	r2,-12(fp)
   211cc:	10800404 	addi	r2,r2,16
   211d0:	1009883a 	mov	r4,r2
   211d4:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   211d8:	10000a26 	beq	r2,zero,21204 <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
   211dc:	003b683a 	trap	0
   211e0:	00000806 	br	21204 <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   211e4:	e0bffd17 	ldw	r2,-12(fp)
   211e8:	10800404 	addi	r2,r2,16
   211ec:	1009883a 	mov	r4,r2
   211f0:	0020ad80 	call	20ad8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   211f4:	e0bffd17 	ldw	r2,-12(fp)
   211f8:	10800904 	addi	r2,r2,36
   211fc:	1009883a 	mov	r4,r2
   21200:	0020ad80 	call	20ad8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   21204:	00231700 	call	23170 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   21208:	00800044 	movi	r2,1
}
   2120c:	e037883a 	mov	sp,fp
   21210:	dfc00117 	ldw	ra,4(sp)
   21214:	df000017 	ldw	fp,0(sp)
   21218:	dec00204 	addi	sp,sp,8
   2121c:	f800283a 	ret

00021220 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   21220:	defff704 	addi	sp,sp,-36
   21224:	dfc00815 	stw	ra,32(sp)
   21228:	df000715 	stw	fp,28(sp)
   2122c:	df000704 	addi	fp,sp,28
   21230:	e13ffd15 	stw	r4,-12(fp)
   21234:	e17ffe15 	stw	r5,-8(fp)
   21238:	3005883a 	mov	r2,r6
   2123c:	e0bfff05 	stb	r2,-4(fp)
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   21240:	e0bffe17 	ldw	r2,-8(fp)
   21244:	1000021e 	bne	r2,zero,21250 <xQueueGenericCreate+0x30>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   21248:	e03ffa15 	stw	zero,-24(fp)
   2124c:	00000406 	br	21260 <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   21250:	e0fffd17 	ldw	r3,-12(fp)
   21254:	e0bffe17 	ldw	r2,-8(fp)
   21258:	1885383a 	mul	r2,r3,r2
   2125c:	e0bffa15 	stw	r2,-24(fp)
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   21260:	e0bffa17 	ldw	r2,-24(fp)
   21264:	10801204 	addi	r2,r2,72
   21268:	1009883a 	mov	r4,r2
   2126c:	00209ac0 	call	209ac <pvPortMalloc>
   21270:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
   21274:	e0bffb17 	ldw	r2,-20(fp)
   21278:	10000b26 	beq	r2,zero,212a8 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   2127c:	e0bffb17 	ldw	r2,-20(fp)
   21280:	10801204 	addi	r2,r2,72
   21284:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   21288:	e0ffff03 	ldbu	r3,-4(fp)
   2128c:	e0bffb17 	ldw	r2,-20(fp)
   21290:	d8800015 	stw	r2,0(sp)
   21294:	180f883a 	mov	r7,r3
   21298:	e1bffc17 	ldw	r6,-16(fp)
   2129c:	e17ffe17 	ldw	r5,-8(fp)
   212a0:	e13ffd17 	ldw	r4,-12(fp)
   212a4:	00212c00 	call	212c0 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
   212a8:	e0bffb17 	ldw	r2,-20(fp)
	}
   212ac:	e037883a 	mov	sp,fp
   212b0:	dfc00117 	ldw	ra,4(sp)
   212b4:	df000017 	ldw	fp,0(sp)
   212b8:	dec00204 	addi	sp,sp,8
   212bc:	f800283a 	ret

000212c0 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   212c0:	defffa04 	addi	sp,sp,-24
   212c4:	dfc00515 	stw	ra,20(sp)
   212c8:	df000415 	stw	fp,16(sp)
   212cc:	df000404 	addi	fp,sp,16
   212d0:	e13ffc15 	stw	r4,-16(fp)
   212d4:	e17ffd15 	stw	r5,-12(fp)
   212d8:	e1bffe15 	stw	r6,-8(fp)
   212dc:	3805883a 	mov	r2,r7
   212e0:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   212e4:	e0bffd17 	ldw	r2,-12(fp)
   212e8:	1000041e 	bne	r2,zero,212fc <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   212ec:	e0800217 	ldw	r2,8(fp)
   212f0:	e0c00217 	ldw	r3,8(fp)
   212f4:	10c00015 	stw	r3,0(r2)
   212f8:	00000306 	br	21308 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   212fc:	e0800217 	ldw	r2,8(fp)
   21300:	e0fffe17 	ldw	r3,-8(fp)
   21304:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   21308:	e0800217 	ldw	r2,8(fp)
   2130c:	e0fffc17 	ldw	r3,-16(fp)
   21310:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
   21314:	e0800217 	ldw	r2,8(fp)
   21318:	e0fffd17 	ldw	r3,-12(fp)
   2131c:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   21320:	01400044 	movi	r5,1
   21324:	e1000217 	ldw	r4,8(fp)
   21328:	002110c0 	call	2110c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   2132c:	0001883a 	nop
   21330:	e037883a 	mov	sp,fp
   21334:	dfc00117 	ldw	ra,4(sp)
   21338:	df000017 	ldw	fp,0(sp)
   2133c:	dec00204 	addi	sp,sp,8
   21340:	f800283a 	ret

00021344 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   21344:	defff504 	addi	sp,sp,-44
   21348:	dfc00a15 	stw	ra,40(sp)
   2134c:	df000915 	stw	fp,36(sp)
   21350:	df000904 	addi	fp,sp,36
   21354:	e13ffc15 	stw	r4,-16(fp)
   21358:	e17ffd15 	stw	r5,-12(fp)
   2135c:	e1bffe15 	stw	r6,-8(fp)
   21360:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   21364:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   21368:	e0bffc17 	ldw	r2,-16(fp)
   2136c:	e0bff815 	stw	r2,-32(fp)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   21370:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   21374:	e0bff817 	ldw	r2,-32(fp)
   21378:	10c00e17 	ldw	r3,56(r2)
   2137c:	e0bff817 	ldw	r2,-32(fp)
   21380:	10800f17 	ldw	r2,60(r2)
   21384:	18800336 	bltu	r3,r2,21394 <xQueueGenericSend+0x50>
   21388:	e0bfff17 	ldw	r2,-4(fp)
   2138c:	10800098 	cmpnei	r2,r2,2
   21390:	1000151e 	bne	r2,zero,213e8 <xQueueGenericSend+0xa4>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   21394:	e1bfff17 	ldw	r6,-4(fp)
   21398:	e17ffd17 	ldw	r5,-12(fp)
   2139c:	e13ff817 	ldw	r4,-32(fp)
   213a0:	0021b100 	call	21b10 <prvCopyDataToQueue>
   213a4:	e0bff915 	stw	r2,-28(fp)
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   213a8:	e0bff817 	ldw	r2,-32(fp)
   213ac:	10800917 	ldw	r2,36(r2)
   213b0:	10000726 	beq	r2,zero,213d0 <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   213b4:	e0bff817 	ldw	r2,-32(fp)
   213b8:	10800904 	addi	r2,r2,36
   213bc:	1009883a 	mov	r4,r2
   213c0:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   213c4:	10000526 	beq	r2,zero,213dc <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   213c8:	003b683a 	trap	0
   213cc:	00000306 	br	213dc <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   213d0:	e0bff917 	ldw	r2,-28(fp)
   213d4:	10000126 	beq	r2,zero,213dc <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   213d8:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   213dc:	00231700 	call	23170 <vTaskExitCritical>
				return pdPASS;
   213e0:	00800044 	movi	r2,1
   213e4:	00003f06 	br	214e4 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   213e8:	e0bffe17 	ldw	r2,-8(fp)
   213ec:	1000031e 	bne	r2,zero,213fc <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   213f0:	00231700 	call	23170 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   213f4:	0005883a 	mov	r2,zero
   213f8:	00003a06 	br	214e4 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
   213fc:	e0bff717 	ldw	r2,-36(fp)
   21400:	1000051e 	bne	r2,zero,21418 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   21404:	e0bffa04 	addi	r2,fp,-24
   21408:	1009883a 	mov	r4,r2
   2140c:	0022e740 	call	22e74 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   21410:	00800044 	movi	r2,1
   21414:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   21418:	00231700 	call	23170 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   2141c:	00227200 	call	22720 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   21420:	002311c0 	call	2311c <vTaskEnterCritical>
   21424:	e0bff817 	ldw	r2,-32(fp)
   21428:	10801103 	ldbu	r2,68(r2)
   2142c:	10803fcc 	andi	r2,r2,255
   21430:	1080201c 	xori	r2,r2,128
   21434:	10bfe004 	addi	r2,r2,-128
   21438:	10bfffd8 	cmpnei	r2,r2,-1
   2143c:	1000021e 	bne	r2,zero,21448 <xQueueGenericSend+0x104>
   21440:	e0bff817 	ldw	r2,-32(fp)
   21444:	10001105 	stb	zero,68(r2)
   21448:	e0bff817 	ldw	r2,-32(fp)
   2144c:	10801143 	ldbu	r2,69(r2)
   21450:	10803fcc 	andi	r2,r2,255
   21454:	1080201c 	xori	r2,r2,128
   21458:	10bfe004 	addi	r2,r2,-128
   2145c:	10bfffd8 	cmpnei	r2,r2,-1
   21460:	1000021e 	bne	r2,zero,2146c <xQueueGenericSend+0x128>
   21464:	e0bff817 	ldw	r2,-32(fp)
   21468:	10001145 	stb	zero,69(r2)
   2146c:	00231700 	call	23170 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   21470:	e0fffe04 	addi	r3,fp,-8
   21474:	e0bffa04 	addi	r2,fp,-24
   21478:	180b883a 	mov	r5,r3
   2147c:	1009883a 	mov	r4,r2
   21480:	0022eb00 	call	22eb0 <xTaskCheckForTimeOut>
   21484:	1000131e 	bne	r2,zero,214d4 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   21488:	e13ff817 	ldw	r4,-32(fp)
   2148c:	0021e900 	call	21e90 <prvIsQueueFull>
   21490:	10000c26 	beq	r2,zero,214c4 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   21494:	e0bff817 	ldw	r2,-32(fp)
   21498:	10800404 	addi	r2,r2,16
   2149c:	e0fffe17 	ldw	r3,-8(fp)
   214a0:	180b883a 	mov	r5,r3
   214a4:	1009883a 	mov	r4,r2
   214a8:	0022bf40 	call	22bf4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   214ac:	e13ff817 	ldw	r4,-32(fp)
   214b0:	0021d0c0 	call	21d0c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   214b4:	002274c0 	call	2274c <xTaskResumeAll>
   214b8:	103fad1e 	bne	r2,zero,21370 <__reset+0xfff81370>
				{
					portYIELD_WITHIN_API();
   214bc:	003b683a 	trap	0
   214c0:	003fab06 	br	21370 <__reset+0xfff81370>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   214c4:	e13ff817 	ldw	r4,-32(fp)
   214c8:	0021d0c0 	call	21d0c <prvUnlockQueue>
				( void ) xTaskResumeAll();
   214cc:	002274c0 	call	2274c <xTaskResumeAll>
   214d0:	003fa706 	br	21370 <__reset+0xfff81370>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   214d4:	e13ff817 	ldw	r4,-32(fp)
   214d8:	0021d0c0 	call	21d0c <prvUnlockQueue>
			( void ) xTaskResumeAll();
   214dc:	002274c0 	call	2274c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   214e0:	0005883a 	mov	r2,zero
		}
	}
}
   214e4:	e037883a 	mov	sp,fp
   214e8:	dfc00117 	ldw	ra,4(sp)
   214ec:	df000017 	ldw	fp,0(sp)
   214f0:	dec00204 	addi	sp,sp,8
   214f4:	f800283a 	ret

000214f8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   214f8:	defff604 	addi	sp,sp,-40
   214fc:	dfc00915 	stw	ra,36(sp)
   21500:	df000815 	stw	fp,32(sp)
   21504:	df000804 	addi	fp,sp,32
   21508:	e13ffc15 	stw	r4,-16(fp)
   2150c:	e17ffd15 	stw	r5,-12(fp)
   21510:	e1bffe15 	stw	r6,-8(fp)
   21514:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   21518:	e0bffc17 	ldw	r2,-16(fp)
   2151c:	e0bff915 	stw	r2,-28(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   21520:	e03ffa15 	stw	zero,-24(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   21524:	e0bff917 	ldw	r2,-28(fp)
   21528:	10c00e17 	ldw	r3,56(r2)
   2152c:	e0bff917 	ldw	r2,-28(fp)
   21530:	10800f17 	ldw	r2,60(r2)
   21534:	18800336 	bltu	r3,r2,21544 <xQueueGenericSendFromISR+0x4c>
   21538:	e0bfff17 	ldw	r2,-4(fp)
   2153c:	10800098 	cmpnei	r2,r2,2
   21540:	1000201e 	bne	r2,zero,215c4 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   21544:	e0bff917 	ldw	r2,-28(fp)
   21548:	10801143 	ldbu	r2,69(r2)
   2154c:	e0bffb05 	stb	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   21550:	e1bfff17 	ldw	r6,-4(fp)
   21554:	e17ffd17 	ldw	r5,-12(fp)
   21558:	e13ff917 	ldw	r4,-28(fp)
   2155c:	0021b100 	call	21b10 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   21560:	e0bffb07 	ldb	r2,-20(fp)
   21564:	10bfffd8 	cmpnei	r2,r2,-1
   21568:	10000e1e 	bne	r2,zero,215a4 <xQueueGenericSendFromISR+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2156c:	e0bff917 	ldw	r2,-28(fp)
   21570:	10800917 	ldw	r2,36(r2)
   21574:	10001026 	beq	r2,zero,215b8 <xQueueGenericSendFromISR+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   21578:	e0bff917 	ldw	r2,-28(fp)
   2157c:	10800904 	addi	r2,r2,36
   21580:	1009883a 	mov	r4,r2
   21584:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   21588:	10000b26 	beq	r2,zero,215b8 <xQueueGenericSendFromISR+0xc0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   2158c:	e0bffe17 	ldw	r2,-8(fp)
   21590:	10000926 	beq	r2,zero,215b8 <xQueueGenericSendFromISR+0xc0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   21594:	e0bffe17 	ldw	r2,-8(fp)
   21598:	00c00044 	movi	r3,1
   2159c:	10c00015 	stw	r3,0(r2)
   215a0:	00000506 	br	215b8 <xQueueGenericSendFromISR+0xc0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   215a4:	e0bffb03 	ldbu	r2,-20(fp)
   215a8:	10800044 	addi	r2,r2,1
   215ac:	1007883a 	mov	r3,r2
   215b0:	e0bff917 	ldw	r2,-28(fp)
   215b4:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
   215b8:	00800044 	movi	r2,1
   215bc:	e0bff815 	stw	r2,-32(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
   215c0:	00000106 	br	215c8 <xQueueGenericSendFromISR+0xd0>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   215c4:	e03ff815 	stw	zero,-32(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   215c8:	e0bff817 	ldw	r2,-32(fp)
}
   215cc:	e037883a 	mov	sp,fp
   215d0:	dfc00117 	ldw	ra,4(sp)
   215d4:	df000017 	ldw	fp,0(sp)
   215d8:	dec00204 	addi	sp,sp,8
   215dc:	f800283a 	ret

000215e0 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
   215e0:	defff704 	addi	sp,sp,-36
   215e4:	dfc00815 	stw	ra,32(sp)
   215e8:	df000715 	stw	fp,28(sp)
   215ec:	df000704 	addi	fp,sp,28
   215f0:	e13ffe15 	stw	r4,-8(fp)
   215f4:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   215f8:	e0bffe17 	ldw	r2,-8(fp)
   215fc:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   21600:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   21604:	e0bffa17 	ldw	r2,-24(fp)
   21608:	10800e17 	ldw	r2,56(r2)
   2160c:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
   21610:	e0bffa17 	ldw	r2,-24(fp)
   21614:	10800f17 	ldw	r2,60(r2)
   21618:	e0fffc17 	ldw	r3,-16(fp)
   2161c:	1880202e 	bgeu	r3,r2,216a0 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   21620:	e0bffa17 	ldw	r2,-24(fp)
   21624:	10801143 	ldbu	r2,69(r2)
   21628:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
   2162c:	e0bffc17 	ldw	r2,-16(fp)
   21630:	10c00044 	addi	r3,r2,1
   21634:	e0bffa17 	ldw	r2,-24(fp)
   21638:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   2163c:	e0bffd07 	ldb	r2,-12(fp)
   21640:	10bfffd8 	cmpnei	r2,r2,-1
   21644:	10000e1e 	bne	r2,zero,21680 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   21648:	e0bffa17 	ldw	r2,-24(fp)
   2164c:	10800917 	ldw	r2,36(r2)
   21650:	10001026 	beq	r2,zero,21694 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   21654:	e0bffa17 	ldw	r2,-24(fp)
   21658:	10800904 	addi	r2,r2,36
   2165c:	1009883a 	mov	r4,r2
   21660:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   21664:	10000b26 	beq	r2,zero,21694 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   21668:	e0bfff17 	ldw	r2,-4(fp)
   2166c:	10000926 	beq	r2,zero,21694 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   21670:	e0bfff17 	ldw	r2,-4(fp)
   21674:	00c00044 	movi	r3,1
   21678:	10c00015 	stw	r3,0(r2)
   2167c:	00000506 	br	21694 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   21680:	e0bffd03 	ldbu	r2,-12(fp)
   21684:	10800044 	addi	r2,r2,1
   21688:	1007883a 	mov	r3,r2
   2168c:	e0bffa17 	ldw	r2,-24(fp)
   21690:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
   21694:	00800044 	movi	r2,1
   21698:	e0bff915 	stw	r2,-28(fp)
   2169c:	00000106 	br	216a4 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   216a0:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   216a4:	e0bff917 	ldw	r2,-28(fp)
}
   216a8:	e037883a 	mov	sp,fp
   216ac:	dfc00117 	ldw	ra,4(sp)
   216b0:	df000017 	ldw	fp,0(sp)
   216b4:	dec00204 	addi	sp,sp,8
   216b8:	f800283a 	ret

000216bc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
   216bc:	defff404 	addi	sp,sp,-48
   216c0:	dfc00b15 	stw	ra,44(sp)
   216c4:	df000a15 	stw	fp,40(sp)
   216c8:	df000a04 	addi	fp,sp,40
   216cc:	e13ffc15 	stw	r4,-16(fp)
   216d0:	e17ffd15 	stw	r5,-12(fp)
   216d4:	e1bffe15 	stw	r6,-8(fp)
   216d8:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
   216dc:	e03ff615 	stw	zero,-40(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   216e0:	e0bffc17 	ldw	r2,-16(fp)
   216e4:	e0bff715 	stw	r2,-36(fp)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   216e8:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   216ec:	e0bff717 	ldw	r2,-36(fp)
   216f0:	10800e17 	ldw	r2,56(r2)
   216f4:	e0bff815 	stw	r2,-32(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   216f8:	e0bff817 	ldw	r2,-32(fp)
   216fc:	10002526 	beq	r2,zero,21794 <xQueueGenericReceive+0xd8>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   21700:	e0bff717 	ldw	r2,-36(fp)
   21704:	10800317 	ldw	r2,12(r2)
   21708:	e0bff915 	stw	r2,-28(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   2170c:	e17ffd17 	ldw	r5,-12(fp)
   21710:	e13ff717 	ldw	r4,-36(fp)
   21714:	0021c700 	call	21c70 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
   21718:	e0bfff17 	ldw	r2,-4(fp)
   2171c:	10000e1e 	bne	r2,zero,21758 <xQueueGenericReceive+0x9c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
   21720:	e0bff817 	ldw	r2,-32(fp)
   21724:	10ffffc4 	addi	r3,r2,-1
   21728:	e0bff717 	ldw	r2,-36(fp)
   2172c:	10c00e15 	stw	r3,56(r2)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   21730:	e0bff717 	ldw	r2,-36(fp)
   21734:	10800417 	ldw	r2,16(r2)
   21738:	10001326 	beq	r2,zero,21788 <xQueueGenericReceive+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2173c:	e0bff717 	ldw	r2,-36(fp)
   21740:	10800404 	addi	r2,r2,16
   21744:	1009883a 	mov	r4,r2
   21748:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   2174c:	10000e26 	beq	r2,zero,21788 <xQueueGenericReceive+0xcc>
						{
							queueYIELD_IF_USING_PREEMPTION();
   21750:	003b683a 	trap	0
   21754:	00000c06 	br	21788 <xQueueGenericReceive+0xcc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   21758:	e0bff717 	ldw	r2,-36(fp)
   2175c:	e0fff917 	ldw	r3,-28(fp)
   21760:	10c00315 	stw	r3,12(r2)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   21764:	e0bff717 	ldw	r2,-36(fp)
   21768:	10800917 	ldw	r2,36(r2)
   2176c:	10000626 	beq	r2,zero,21788 <xQueueGenericReceive+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   21770:	e0bff717 	ldw	r2,-36(fp)
   21774:	10800904 	addi	r2,r2,36
   21778:	1009883a 	mov	r4,r2
   2177c:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   21780:	10000126 	beq	r2,zero,21788 <xQueueGenericReceive+0xcc>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
   21784:	003b683a 	trap	0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
   21788:	00231700 	call	23170 <vTaskExitCritical>
				return pdPASS;
   2178c:	00800044 	movi	r2,1
   21790:	00004206 	br	2189c <xQueueGenericReceive+0x1e0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   21794:	e0bffe17 	ldw	r2,-8(fp)
   21798:	1000031e 	bne	r2,zero,217a8 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   2179c:	00231700 	call	23170 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   217a0:	0005883a 	mov	r2,zero
   217a4:	00003d06 	br	2189c <xQueueGenericReceive+0x1e0>
				}
				else if( xEntryTimeSet == pdFALSE )
   217a8:	e0bff617 	ldw	r2,-40(fp)
   217ac:	1000051e 	bne	r2,zero,217c4 <xQueueGenericReceive+0x108>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   217b0:	e0bffa04 	addi	r2,fp,-24
   217b4:	1009883a 	mov	r4,r2
   217b8:	0022e740 	call	22e74 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   217bc:	00800044 	movi	r2,1
   217c0:	e0bff615 	stw	r2,-40(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   217c4:	00231700 	call	23170 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   217c8:	00227200 	call	22720 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   217cc:	002311c0 	call	2311c <vTaskEnterCritical>
   217d0:	e0bff717 	ldw	r2,-36(fp)
   217d4:	10801103 	ldbu	r2,68(r2)
   217d8:	10803fcc 	andi	r2,r2,255
   217dc:	1080201c 	xori	r2,r2,128
   217e0:	10bfe004 	addi	r2,r2,-128
   217e4:	10bfffd8 	cmpnei	r2,r2,-1
   217e8:	1000021e 	bne	r2,zero,217f4 <xQueueGenericReceive+0x138>
   217ec:	e0bff717 	ldw	r2,-36(fp)
   217f0:	10001105 	stb	zero,68(r2)
   217f4:	e0bff717 	ldw	r2,-36(fp)
   217f8:	10801143 	ldbu	r2,69(r2)
   217fc:	10803fcc 	andi	r2,r2,255
   21800:	1080201c 	xori	r2,r2,128
   21804:	10bfe004 	addi	r2,r2,-128
   21808:	10bfffd8 	cmpnei	r2,r2,-1
   2180c:	1000021e 	bne	r2,zero,21818 <xQueueGenericReceive+0x15c>
   21810:	e0bff717 	ldw	r2,-36(fp)
   21814:	10001145 	stb	zero,69(r2)
   21818:	00231700 	call	23170 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   2181c:	e0fffe04 	addi	r3,fp,-8
   21820:	e0bffa04 	addi	r2,fp,-24
   21824:	180b883a 	mov	r5,r3
   21828:	1009883a 	mov	r4,r2
   2182c:	0022eb00 	call	22eb0 <xTaskCheckForTimeOut>
   21830:	1000131e 	bne	r2,zero,21880 <xQueueGenericReceive+0x1c4>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   21834:	e13ff717 	ldw	r4,-36(fp)
   21838:	0021e000 	call	21e00 <prvIsQueueEmpty>
   2183c:	10000c26 	beq	r2,zero,21870 <xQueueGenericReceive+0x1b4>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   21840:	e0bff717 	ldw	r2,-36(fp)
   21844:	10800904 	addi	r2,r2,36
   21848:	e0fffe17 	ldw	r3,-8(fp)
   2184c:	180b883a 	mov	r5,r3
   21850:	1009883a 	mov	r4,r2
   21854:	0022bf40 	call	22bf4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   21858:	e13ff717 	ldw	r4,-36(fp)
   2185c:	0021d0c0 	call	21d0c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   21860:	002274c0 	call	2274c <xTaskResumeAll>
   21864:	103fa01e 	bne	r2,zero,216e8 <__reset+0xfff816e8>
				{
					portYIELD_WITHIN_API();
   21868:	003b683a 	trap	0
   2186c:	003f9e06 	br	216e8 <__reset+0xfff816e8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   21870:	e13ff717 	ldw	r4,-36(fp)
   21874:	0021d0c0 	call	21d0c <prvUnlockQueue>
				( void ) xTaskResumeAll();
   21878:	002274c0 	call	2274c <xTaskResumeAll>
   2187c:	003f9a06 	br	216e8 <__reset+0xfff816e8>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
   21880:	e13ff717 	ldw	r4,-36(fp)
   21884:	0021d0c0 	call	21d0c <prvUnlockQueue>
			( void ) xTaskResumeAll();
   21888:	002274c0 	call	2274c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   2188c:	e13ff717 	ldw	r4,-36(fp)
   21890:	0021e000 	call	21e00 <prvIsQueueEmpty>
   21894:	103f9426 	beq	r2,zero,216e8 <__reset+0xfff816e8>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   21898:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   2189c:	e037883a 	mov	sp,fp
   218a0:	dfc00117 	ldw	ra,4(sp)
   218a4:	df000017 	ldw	fp,0(sp)
   218a8:	dec00204 	addi	sp,sp,8
   218ac:	f800283a 	ret

000218b0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
   218b0:	defff604 	addi	sp,sp,-40
   218b4:	dfc00915 	stw	ra,36(sp)
   218b8:	df000815 	stw	fp,32(sp)
   218bc:	df000804 	addi	fp,sp,32
   218c0:	e13ffd15 	stw	r4,-12(fp)
   218c4:	e17ffe15 	stw	r5,-8(fp)
   218c8:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   218cc:	e0bffd17 	ldw	r2,-12(fp)
   218d0:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   218d4:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   218d8:	e0bff917 	ldw	r2,-28(fp)
   218dc:	10800e17 	ldw	r2,56(r2)
   218e0:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   218e4:	e0bffb17 	ldw	r2,-20(fp)
   218e8:	10002326 	beq	r2,zero,21978 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
   218ec:	e0bff917 	ldw	r2,-28(fp)
   218f0:	10801103 	ldbu	r2,68(r2)
   218f4:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   218f8:	e17ffe17 	ldw	r5,-8(fp)
   218fc:	e13ff917 	ldw	r4,-28(fp)
   21900:	0021c700 	call	21c70 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
   21904:	e0bffb17 	ldw	r2,-20(fp)
   21908:	10ffffc4 	addi	r3,r2,-1
   2190c:	e0bff917 	ldw	r2,-28(fp)
   21910:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
   21914:	e0bffc07 	ldb	r2,-16(fp)
   21918:	10bfffd8 	cmpnei	r2,r2,-1
   2191c:	10000e1e 	bne	r2,zero,21958 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   21920:	e0bff917 	ldw	r2,-28(fp)
   21924:	10800417 	ldw	r2,16(r2)
   21928:	10001026 	beq	r2,zero,2196c <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2192c:	e0bff917 	ldw	r2,-28(fp)
   21930:	10800404 	addi	r2,r2,16
   21934:	1009883a 	mov	r4,r2
   21938:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   2193c:	10000b26 	beq	r2,zero,2196c <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   21940:	e0bfff17 	ldw	r2,-4(fp)
   21944:	10000926 	beq	r2,zero,2196c <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   21948:	e0bfff17 	ldw	r2,-4(fp)
   2194c:	00c00044 	movi	r3,1
   21950:	10c00015 	stw	r3,0(r2)
   21954:	00000506 	br	2196c <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   21958:	e0bffc03 	ldbu	r2,-16(fp)
   2195c:	10800044 	addi	r2,r2,1
   21960:	1007883a 	mov	r3,r2
   21964:	e0bff917 	ldw	r2,-28(fp)
   21968:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
   2196c:	00800044 	movi	r2,1
   21970:	e0bff815 	stw	r2,-32(fp)
   21974:	00000106 	br	2197c <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
   21978:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   2197c:	e0bff817 	ldw	r2,-32(fp)
}
   21980:	e037883a 	mov	sp,fp
   21984:	dfc00117 	ldw	ra,4(sp)
   21988:	df000017 	ldw	fp,0(sp)
   2198c:	dec00204 	addi	sp,sp,8
   21990:	f800283a 	ret

00021994 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
   21994:	defff804 	addi	sp,sp,-32
   21998:	dfc00715 	stw	ra,28(sp)
   2199c:	df000615 	stw	fp,24(sp)
   219a0:	df000604 	addi	fp,sp,24
   219a4:	e13ffe15 	stw	r4,-8(fp)
   219a8:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   219ac:	e0bffe17 	ldw	r2,-8(fp)
   219b0:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   219b4:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   219b8:	e0bffb17 	ldw	r2,-20(fp)
   219bc:	10800e17 	ldw	r2,56(r2)
   219c0:	10000c26 	beq	r2,zero,219f4 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   219c4:	e0bffb17 	ldw	r2,-20(fp)
   219c8:	10800317 	ldw	r2,12(r2)
   219cc:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
   219d0:	e17fff17 	ldw	r5,-4(fp)
   219d4:	e13ffb17 	ldw	r4,-20(fp)
   219d8:	0021c700 	call	21c70 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   219dc:	e0bffb17 	ldw	r2,-20(fp)
   219e0:	e0fffd17 	ldw	r3,-12(fp)
   219e4:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
   219e8:	00800044 	movi	r2,1
   219ec:	e0bffa15 	stw	r2,-24(fp)
   219f0:	00000106 	br	219f8 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
   219f4:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   219f8:	e0bffa17 	ldw	r2,-24(fp)
}
   219fc:	e037883a 	mov	sp,fp
   21a00:	dfc00117 	ldw	ra,4(sp)
   21a04:	df000017 	ldw	fp,0(sp)
   21a08:	dec00204 	addi	sp,sp,8
   21a0c:	f800283a 	ret

00021a10 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
   21a10:	defffc04 	addi	sp,sp,-16
   21a14:	dfc00315 	stw	ra,12(sp)
   21a18:	df000215 	stw	fp,8(sp)
   21a1c:	df000204 	addi	fp,sp,8
   21a20:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
   21a24:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   21a28:	e0bfff17 	ldw	r2,-4(fp)
   21a2c:	10800e17 	ldw	r2,56(r2)
   21a30:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
   21a34:	00231700 	call	23170 <vTaskExitCritical>

	return uxReturn;
   21a38:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   21a3c:	e037883a 	mov	sp,fp
   21a40:	dfc00117 	ldw	ra,4(sp)
   21a44:	df000017 	ldw	fp,0(sp)
   21a48:	dec00204 	addi	sp,sp,8
   21a4c:	f800283a 	ret

00021a50 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
   21a50:	defffb04 	addi	sp,sp,-20
   21a54:	dfc00415 	stw	ra,16(sp)
   21a58:	df000315 	stw	fp,12(sp)
   21a5c:	df000304 	addi	fp,sp,12
   21a60:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
   21a64:	e0bfff17 	ldw	r2,-4(fp)
   21a68:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   21a6c:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   21a70:	e0bffd17 	ldw	r2,-12(fp)
   21a74:	10c00f17 	ldw	r3,60(r2)
   21a78:	e0bffd17 	ldw	r2,-12(fp)
   21a7c:	10800e17 	ldw	r2,56(r2)
   21a80:	1885c83a 	sub	r2,r3,r2
   21a84:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
   21a88:	00231700 	call	23170 <vTaskExitCritical>

	return uxReturn;
   21a8c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   21a90:	e037883a 	mov	sp,fp
   21a94:	dfc00117 	ldw	ra,4(sp)
   21a98:	df000017 	ldw	fp,0(sp)
   21a9c:	dec00204 	addi	sp,sp,8
   21aa0:	f800283a 	ret

00021aa4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
   21aa4:	defffd04 	addi	sp,sp,-12
   21aa8:	df000215 	stw	fp,8(sp)
   21aac:	df000204 	addi	fp,sp,8
   21ab0:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   21ab4:	e0bfff17 	ldw	r2,-4(fp)
   21ab8:	10800e17 	ldw	r2,56(r2)
   21abc:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
   21ac0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   21ac4:	e037883a 	mov	sp,fp
   21ac8:	df000017 	ldw	fp,0(sp)
   21acc:	dec00104 	addi	sp,sp,4
   21ad0:	f800283a 	ret

00021ad4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
   21ad4:	defffc04 	addi	sp,sp,-16
   21ad8:	dfc00315 	stw	ra,12(sp)
   21adc:	df000215 	stw	fp,8(sp)
   21ae0:	df000204 	addi	fp,sp,8
   21ae4:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   21ae8:	e0bfff17 	ldw	r2,-4(fp)
   21aec:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
   21af0:	e13ffe17 	ldw	r4,-8(fp)
   21af4:	0020a680 	call	20a68 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
   21af8:	0001883a 	nop
   21afc:	e037883a 	mov	sp,fp
   21b00:	dfc00117 	ldw	ra,4(sp)
   21b04:	df000017 	ldw	fp,0(sp)
   21b08:	dec00204 	addi	sp,sp,8
   21b0c:	f800283a 	ret

00021b10 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   21b10:	defff904 	addi	sp,sp,-28
   21b14:	dfc00615 	stw	ra,24(sp)
   21b18:	df000515 	stw	fp,20(sp)
   21b1c:	df000504 	addi	fp,sp,20
   21b20:	e13ffd15 	stw	r4,-12(fp)
   21b24:	e17ffe15 	stw	r5,-8(fp)
   21b28:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
   21b2c:	e03ffc15 	stw	zero,-16(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   21b30:	e0bffd17 	ldw	r2,-12(fp)
   21b34:	10800e17 	ldw	r2,56(r2)
   21b38:	e0bffb15 	stw	r2,-20(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   21b3c:	e0bffd17 	ldw	r2,-12(fp)
   21b40:	10801017 	ldw	r2,64(r2)
   21b44:	10004026 	beq	r2,zero,21c48 <prvCopyDataToQueue+0x138>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   21b48:	e0bfff17 	ldw	r2,-4(fp)
   21b4c:	1000191e 	bne	r2,zero,21bb4 <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   21b50:	e0bffd17 	ldw	r2,-12(fp)
   21b54:	10c00217 	ldw	r3,8(r2)
   21b58:	e0bffd17 	ldw	r2,-12(fp)
   21b5c:	10801017 	ldw	r2,64(r2)
   21b60:	100d883a 	mov	r6,r2
   21b64:	e17ffe17 	ldw	r5,-8(fp)
   21b68:	1809883a 	mov	r4,r3
   21b6c:	002b6ac0 	call	2b6ac <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   21b70:	e0bffd17 	ldw	r2,-12(fp)
   21b74:	10c00217 	ldw	r3,8(r2)
   21b78:	e0bffd17 	ldw	r2,-12(fp)
   21b7c:	10801017 	ldw	r2,64(r2)
   21b80:	1887883a 	add	r3,r3,r2
   21b84:	e0bffd17 	ldw	r2,-12(fp)
   21b88:	10c00215 	stw	r3,8(r2)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   21b8c:	e0bffd17 	ldw	r2,-12(fp)
   21b90:	10c00217 	ldw	r3,8(r2)
   21b94:	e0bffd17 	ldw	r2,-12(fp)
   21b98:	10800117 	ldw	r2,4(r2)
   21b9c:	18802a36 	bltu	r3,r2,21c48 <prvCopyDataToQueue+0x138>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   21ba0:	e0bffd17 	ldw	r2,-12(fp)
   21ba4:	10c00017 	ldw	r3,0(r2)
   21ba8:	e0bffd17 	ldw	r2,-12(fp)
   21bac:	10c00215 	stw	r3,8(r2)
   21bb0:	00002506 	br	21c48 <prvCopyDataToQueue+0x138>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   21bb4:	e0bffd17 	ldw	r2,-12(fp)
   21bb8:	10c00317 	ldw	r3,12(r2)
   21bbc:	e0bffd17 	ldw	r2,-12(fp)
   21bc0:	10801017 	ldw	r2,64(r2)
   21bc4:	100d883a 	mov	r6,r2
   21bc8:	e17ffe17 	ldw	r5,-8(fp)
   21bcc:	1809883a 	mov	r4,r3
   21bd0:	002b6ac0 	call	2b6ac <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   21bd4:	e0bffd17 	ldw	r2,-12(fp)
   21bd8:	10c00317 	ldw	r3,12(r2)
   21bdc:	e0bffd17 	ldw	r2,-12(fp)
   21be0:	10801017 	ldw	r2,64(r2)
   21be4:	0085c83a 	sub	r2,zero,r2
   21be8:	1887883a 	add	r3,r3,r2
   21bec:	e0bffd17 	ldw	r2,-12(fp)
   21bf0:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   21bf4:	e0bffd17 	ldw	r2,-12(fp)
   21bf8:	10c00317 	ldw	r3,12(r2)
   21bfc:	e0bffd17 	ldw	r2,-12(fp)
   21c00:	10800017 	ldw	r2,0(r2)
   21c04:	1880082e 	bgeu	r3,r2,21c28 <prvCopyDataToQueue+0x118>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   21c08:	e0bffd17 	ldw	r2,-12(fp)
   21c0c:	10c00117 	ldw	r3,4(r2)
   21c10:	e0bffd17 	ldw	r2,-12(fp)
   21c14:	10801017 	ldw	r2,64(r2)
   21c18:	0085c83a 	sub	r2,zero,r2
   21c1c:	1887883a 	add	r3,r3,r2
   21c20:	e0bffd17 	ldw	r2,-12(fp)
   21c24:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   21c28:	e0bfff17 	ldw	r2,-4(fp)
   21c2c:	10800098 	cmpnei	r2,r2,2
   21c30:	1000051e 	bne	r2,zero,21c48 <prvCopyDataToQueue+0x138>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   21c34:	e0bffb17 	ldw	r2,-20(fp)
   21c38:	10000326 	beq	r2,zero,21c48 <prvCopyDataToQueue+0x138>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   21c3c:	e0bffb17 	ldw	r2,-20(fp)
   21c40:	10bfffc4 	addi	r2,r2,-1
   21c44:	e0bffb15 	stw	r2,-20(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
   21c48:	e0bffb17 	ldw	r2,-20(fp)
   21c4c:	10c00044 	addi	r3,r2,1
   21c50:	e0bffd17 	ldw	r2,-12(fp)
   21c54:	10c00e15 	stw	r3,56(r2)

	return xReturn;
   21c58:	e0bffc17 	ldw	r2,-16(fp)
}
   21c5c:	e037883a 	mov	sp,fp
   21c60:	dfc00117 	ldw	ra,4(sp)
   21c64:	df000017 	ldw	fp,0(sp)
   21c68:	dec00204 	addi	sp,sp,8
   21c6c:	f800283a 	ret

00021c70 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   21c70:	defffc04 	addi	sp,sp,-16
   21c74:	dfc00315 	stw	ra,12(sp)
   21c78:	df000215 	stw	fp,8(sp)
   21c7c:	df000204 	addi	fp,sp,8
   21c80:	e13ffe15 	stw	r4,-8(fp)
   21c84:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   21c88:	e0bffe17 	ldw	r2,-8(fp)
   21c8c:	10801017 	ldw	r2,64(r2)
   21c90:	10001826 	beq	r2,zero,21cf4 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   21c94:	e0bffe17 	ldw	r2,-8(fp)
   21c98:	10c00317 	ldw	r3,12(r2)
   21c9c:	e0bffe17 	ldw	r2,-8(fp)
   21ca0:	10801017 	ldw	r2,64(r2)
   21ca4:	1887883a 	add	r3,r3,r2
   21ca8:	e0bffe17 	ldw	r2,-8(fp)
   21cac:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   21cb0:	e0bffe17 	ldw	r2,-8(fp)
   21cb4:	10c00317 	ldw	r3,12(r2)
   21cb8:	e0bffe17 	ldw	r2,-8(fp)
   21cbc:	10800117 	ldw	r2,4(r2)
   21cc0:	18800436 	bltu	r3,r2,21cd4 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   21cc4:	e0bffe17 	ldw	r2,-8(fp)
   21cc8:	10c00017 	ldw	r3,0(r2)
   21ccc:	e0bffe17 	ldw	r2,-8(fp)
   21cd0:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   21cd4:	e0bffe17 	ldw	r2,-8(fp)
   21cd8:	10c00317 	ldw	r3,12(r2)
   21cdc:	e0bffe17 	ldw	r2,-8(fp)
   21ce0:	10801017 	ldw	r2,64(r2)
   21ce4:	100d883a 	mov	r6,r2
   21ce8:	180b883a 	mov	r5,r3
   21cec:	e13fff17 	ldw	r4,-4(fp)
   21cf0:	002b6ac0 	call	2b6ac <memcpy>
	}
}
   21cf4:	0001883a 	nop
   21cf8:	e037883a 	mov	sp,fp
   21cfc:	dfc00117 	ldw	ra,4(sp)
   21d00:	df000017 	ldw	fp,0(sp)
   21d04:	dec00204 	addi	sp,sp,8
   21d08:	f800283a 	ret

00021d0c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   21d0c:	defffc04 	addi	sp,sp,-16
   21d10:	dfc00315 	stw	ra,12(sp)
   21d14:	df000215 	stw	fp,8(sp)
   21d18:	df000204 	addi	fp,sp,8
   21d1c:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   21d20:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   21d24:	e0bfff17 	ldw	r2,-4(fp)
   21d28:	10801143 	ldbu	r2,69(r2)
   21d2c:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   21d30:	00000c06 	br	21d64 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   21d34:	e0bfff17 	ldw	r2,-4(fp)
   21d38:	10800917 	ldw	r2,36(r2)
   21d3c:	10000c26 	beq	r2,zero,21d70 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   21d40:	e0bfff17 	ldw	r2,-4(fp)
   21d44:	10800904 	addi	r2,r2,36
   21d48:	1009883a 	mov	r4,r2
   21d4c:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   21d50:	10000126 	beq	r2,zero,21d58 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   21d54:	0022f8c0 	call	22f8c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   21d58:	e0bffe03 	ldbu	r2,-8(fp)
   21d5c:	10bfffc4 	addi	r2,r2,-1
   21d60:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   21d64:	e0bffe07 	ldb	r2,-8(fp)
   21d68:	00bff216 	blt	zero,r2,21d34 <__reset+0xfff81d34>
   21d6c:	00000106 	br	21d74 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
   21d70:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
   21d74:	e0bfff17 	ldw	r2,-4(fp)
   21d78:	00ffffc4 	movi	r3,-1
   21d7c:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
   21d80:	00231700 	call	23170 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   21d84:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   21d88:	e0bfff17 	ldw	r2,-4(fp)
   21d8c:	10801103 	ldbu	r2,68(r2)
   21d90:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
   21d94:	00000c06 	br	21dc8 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   21d98:	e0bfff17 	ldw	r2,-4(fp)
   21d9c:	10800417 	ldw	r2,16(r2)
   21da0:	10000c26 	beq	r2,zero,21dd4 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   21da4:	e0bfff17 	ldw	r2,-4(fp)
   21da8:	10800404 	addi	r2,r2,16
   21dac:	1009883a 	mov	r4,r2
   21db0:	0022ca80 	call	22ca8 <xTaskRemoveFromEventList>
   21db4:	10000126 	beq	r2,zero,21dbc <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
   21db8:	0022f8c0 	call	22f8c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   21dbc:	e0bffe43 	ldbu	r2,-7(fp)
   21dc0:	10bfffc4 	addi	r2,r2,-1
   21dc4:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
   21dc8:	e0bffe47 	ldb	r2,-7(fp)
   21dcc:	00bff216 	blt	zero,r2,21d98 <__reset+0xfff81d98>
   21dd0:	00000106 	br	21dd8 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
   21dd4:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   21dd8:	e0bfff17 	ldw	r2,-4(fp)
   21ddc:	00ffffc4 	movi	r3,-1
   21de0:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
   21de4:	00231700 	call	23170 <vTaskExitCritical>
}
   21de8:	0001883a 	nop
   21dec:	e037883a 	mov	sp,fp
   21df0:	dfc00117 	ldw	ra,4(sp)
   21df4:	df000017 	ldw	fp,0(sp)
   21df8:	dec00204 	addi	sp,sp,8
   21dfc:	f800283a 	ret

00021e00 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   21e00:	defffc04 	addi	sp,sp,-16
   21e04:	dfc00315 	stw	ra,12(sp)
   21e08:	df000215 	stw	fp,8(sp)
   21e0c:	df000204 	addi	fp,sp,8
   21e10:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
   21e14:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   21e18:	e0bfff17 	ldw	r2,-4(fp)
   21e1c:	10800e17 	ldw	r2,56(r2)
   21e20:	1000031e 	bne	r2,zero,21e30 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
   21e24:	00800044 	movi	r2,1
   21e28:	e0bffe15 	stw	r2,-8(fp)
   21e2c:	00000106 	br	21e34 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
   21e30:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
   21e34:	00231700 	call	23170 <vTaskExitCritical>

	return xReturn;
   21e38:	e0bffe17 	ldw	r2,-8(fp)
}
   21e3c:	e037883a 	mov	sp,fp
   21e40:	dfc00117 	ldw	ra,4(sp)
   21e44:	df000017 	ldw	fp,0(sp)
   21e48:	dec00204 	addi	sp,sp,8
   21e4c:	f800283a 	ret

00021e50 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
   21e50:	defffd04 	addi	sp,sp,-12
   21e54:	df000215 	stw	fp,8(sp)
   21e58:	df000204 	addi	fp,sp,8
   21e5c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
   21e60:	e0bfff17 	ldw	r2,-4(fp)
   21e64:	10800e17 	ldw	r2,56(r2)
   21e68:	1000031e 	bne	r2,zero,21e78 <xQueueIsQueueEmptyFromISR+0x28>
	{
		xReturn = pdTRUE;
   21e6c:	00800044 	movi	r2,1
   21e70:	e0bffe15 	stw	r2,-8(fp)
   21e74:	00000106 	br	21e7c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
   21e78:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
   21e7c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   21e80:	e037883a 	mov	sp,fp
   21e84:	df000017 	ldw	fp,0(sp)
   21e88:	dec00104 	addi	sp,sp,4
   21e8c:	f800283a 	ret

00021e90 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   21e90:	defffc04 	addi	sp,sp,-16
   21e94:	dfc00315 	stw	ra,12(sp)
   21e98:	df000215 	stw	fp,8(sp)
   21e9c:	df000204 	addi	fp,sp,8
   21ea0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
   21ea4:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   21ea8:	e0bfff17 	ldw	r2,-4(fp)
   21eac:	10c00e17 	ldw	r3,56(r2)
   21eb0:	e0bfff17 	ldw	r2,-4(fp)
   21eb4:	10800f17 	ldw	r2,60(r2)
   21eb8:	1880031e 	bne	r3,r2,21ec8 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
   21ebc:	00800044 	movi	r2,1
   21ec0:	e0bffe15 	stw	r2,-8(fp)
   21ec4:	00000106 	br	21ecc <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
   21ec8:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
   21ecc:	00231700 	call	23170 <vTaskExitCritical>

	return xReturn;
   21ed0:	e0bffe17 	ldw	r2,-8(fp)
}
   21ed4:	e037883a 	mov	sp,fp
   21ed8:	dfc00117 	ldw	ra,4(sp)
   21edc:	df000017 	ldw	fp,0(sp)
   21ee0:	dec00204 	addi	sp,sp,8
   21ee4:	f800283a 	ret

00021ee8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
   21ee8:	defffd04 	addi	sp,sp,-12
   21eec:	df000215 	stw	fp,8(sp)
   21ef0:	df000204 	addi	fp,sp,8
   21ef4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
   21ef8:	e0bfff17 	ldw	r2,-4(fp)
   21efc:	10c00e17 	ldw	r3,56(r2)
   21f00:	e0bfff17 	ldw	r2,-4(fp)
   21f04:	10800f17 	ldw	r2,60(r2)
   21f08:	1880031e 	bne	r3,r2,21f18 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
   21f0c:	00800044 	movi	r2,1
   21f10:	e0bffe15 	stw	r2,-8(fp)
   21f14:	00000106 	br	21f1c <xQueueIsQueueFullFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
   21f18:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
   21f1c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   21f20:	e037883a 	mov	sp,fp
   21f24:	df000017 	ldw	fp,0(sp)
   21f28:	dec00104 	addi	sp,sp,4
   21f2c:	f800283a 	ret

00021f30 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
   21f30:	defff304 	addi	sp,sp,-52
   21f34:	dfc00c15 	stw	ra,48(sp)
   21f38:	df000b15 	stw	fp,44(sp)
   21f3c:	df000b04 	addi	fp,sp,44
   21f40:	e13ffc15 	stw	r4,-16(fp)
   21f44:	e17ffd15 	stw	r5,-12(fp)
   21f48:	3005883a 	mov	r2,r6
   21f4c:	e1ffff15 	stw	r7,-4(fp)
   21f50:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   21f54:	e0bffe0b 	ldhu	r2,-8(fp)
   21f58:	1085883a 	add	r2,r2,r2
   21f5c:	1085883a 	add	r2,r2,r2
   21f60:	1009883a 	mov	r4,r2
   21f64:	00209ac0 	call	209ac <pvPortMalloc>
   21f68:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
   21f6c:	e0bffb17 	ldw	r2,-20(fp)
   21f70:	10000c26 	beq	r2,zero,21fa4 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   21f74:	01001204 	movi	r4,72
   21f78:	00209ac0 	call	209ac <pvPortMalloc>
   21f7c:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
   21f80:	e0bff917 	ldw	r2,-28(fp)
   21f84:	10000426 	beq	r2,zero,21f98 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   21f88:	e0bff917 	ldw	r2,-28(fp)
   21f8c:	e0fffb17 	ldw	r3,-20(fp)
   21f90:	10c00c15 	stw	r3,48(r2)
   21f94:	00000406 	br	21fa8 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   21f98:	e13ffb17 	ldw	r4,-20(fp)
   21f9c:	0020a680 	call	20a68 <vPortFree>
   21fa0:	00000106 	br	21fa8 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
   21fa4:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   21fa8:	e0bff917 	ldw	r2,-28(fp)
   21fac:	10001226 	beq	r2,zero,21ff8 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   21fb0:	e0fffe0b 	ldhu	r3,-8(fp)
   21fb4:	d8000315 	stw	zero,12(sp)
   21fb8:	e0bff917 	ldw	r2,-28(fp)
   21fbc:	d8800215 	stw	r2,8(sp)
   21fc0:	e0800317 	ldw	r2,12(fp)
   21fc4:	d8800115 	stw	r2,4(sp)
   21fc8:	e0800217 	ldw	r2,8(fp)
   21fcc:	d8800015 	stw	r2,0(sp)
   21fd0:	e1ffff17 	ldw	r7,-4(fp)
   21fd4:	180d883a 	mov	r6,r3
   21fd8:	e17ffd17 	ldw	r5,-12(fp)
   21fdc:	e13ffc17 	ldw	r4,-16(fp)
   21fe0:	00220180 	call	22018 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   21fe4:	e13ff917 	ldw	r4,-28(fp)
   21fe8:	00221b00 	call	221b0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   21fec:	00800044 	movi	r2,1
   21ff0:	e0bffa15 	stw	r2,-24(fp)
   21ff4:	00000206 	br	22000 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   21ff8:	00bfffc4 	movi	r2,-1
   21ffc:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
   22000:	e0bffa17 	ldw	r2,-24(fp)
	}
   22004:	e037883a 	mov	sp,fp
   22008:	dfc00117 	ldw	ra,4(sp)
   2200c:	df000017 	ldw	fp,0(sp)
   22010:	dec00204 	addi	sp,sp,8
   22014:	f800283a 	ret

00022018 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   22018:	defff804 	addi	sp,sp,-32
   2201c:	dfc00715 	stw	ra,28(sp)
   22020:	df000615 	stw	fp,24(sp)
   22024:	df000604 	addi	fp,sp,24
   22028:	e13ffc15 	stw	r4,-16(fp)
   2202c:	e17ffd15 	stw	r5,-12(fp)
   22030:	e1bffe15 	stw	r6,-8(fp)
   22034:	e1ffff15 	stw	r7,-4(fp)
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   22038:	e0800417 	ldw	r2,16(fp)
   2203c:	10c00c17 	ldw	r3,48(r2)
   22040:	e13ffe17 	ldw	r4,-8(fp)
   22044:	00900034 	movhi	r2,16384
   22048:	10bfffc4 	addi	r2,r2,-1
   2204c:	2085883a 	add	r2,r4,r2
   22050:	1085883a 	add	r2,r2,r2
   22054:	1085883a 	add	r2,r2,r2
   22058:	1885883a 	add	r2,r3,r2
   2205c:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   22060:	e0fffb17 	ldw	r3,-20(fp)
   22064:	00bfff04 	movi	r2,-4
   22068:	1884703a 	and	r2,r3,r2
   2206c:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   22070:	e03ffa15 	stw	zero,-24(fp)
   22074:	00001406 	br	220c8 <prvInitialiseNewTask+0xb0>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   22078:	e0fffd17 	ldw	r3,-12(fp)
   2207c:	e0bffa17 	ldw	r2,-24(fp)
   22080:	1885883a 	add	r2,r3,r2
   22084:	10c00003 	ldbu	r3,0(r2)
   22088:	e1000417 	ldw	r4,16(fp)
   2208c:	e0bffa17 	ldw	r2,-24(fp)
   22090:	2085883a 	add	r2,r4,r2
   22094:	10800d04 	addi	r2,r2,52
   22098:	10c00005 	stb	r3,0(r2)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   2209c:	e0fffd17 	ldw	r3,-12(fp)
   220a0:	e0bffa17 	ldw	r2,-24(fp)
   220a4:	1885883a 	add	r2,r3,r2
   220a8:	10800003 	ldbu	r2,0(r2)
   220ac:	10803fcc 	andi	r2,r2,255
   220b0:	1080201c 	xori	r2,r2,128
   220b4:	10bfe004 	addi	r2,r2,-128
   220b8:	10000726 	beq	r2,zero,220d8 <prvInitialiseNewTask+0xc0>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   220bc:	e0bffa17 	ldw	r2,-24(fp)
   220c0:	10800044 	addi	r2,r2,1
   220c4:	e0bffa15 	stw	r2,-24(fp)
   220c8:	e0bffa17 	ldw	r2,-24(fp)
   220cc:	10800230 	cmpltui	r2,r2,8
   220d0:	103fe91e 	bne	r2,zero,22078 <__reset+0xfff82078>
   220d4:	00000106 	br	220dc <prvInitialiseNewTask+0xc4>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
   220d8:	0001883a 	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   220dc:	e0800417 	ldw	r2,16(fp)
   220e0:	10000ec5 	stb	zero,59(r2)

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   220e4:	e0800217 	ldw	r2,8(fp)
   220e8:	10800170 	cmpltui	r2,r2,5
   220ec:	1000021e 	bne	r2,zero,220f8 <prvInitialiseNewTask+0xe0>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   220f0:	00800104 	movi	r2,4
   220f4:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   220f8:	e0800417 	ldw	r2,16(fp)
   220fc:	e0c00217 	ldw	r3,8(fp)
   22100:	10c00b15 	stw	r3,44(r2)
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   22104:	e0800417 	ldw	r2,16(fp)
   22108:	10800104 	addi	r2,r2,4
   2210c:	1009883a 	mov	r4,r2
   22110:	0020b400 	call	20b40 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   22114:	e0800417 	ldw	r2,16(fp)
   22118:	10800604 	addi	r2,r2,24
   2211c:	1009883a 	mov	r4,r2
   22120:	0020b400 	call	20b40 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   22124:	e0800417 	ldw	r2,16(fp)
   22128:	e0c00417 	ldw	r3,16(fp)
   2212c:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   22130:	00c00144 	movi	r3,5
   22134:	e0800217 	ldw	r2,8(fp)
   22138:	1887c83a 	sub	r3,r3,r2
   2213c:	e0800417 	ldw	r2,16(fp)
   22140:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   22144:	e0800417 	ldw	r2,16(fp)
   22148:	e0c00417 	ldw	r3,16(fp)
   2214c:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   22150:	e0800417 	ldw	r2,16(fp)
   22154:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   22158:	e0800417 	ldw	r2,16(fp)
   2215c:	10001015 	stw	zero,64(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   22160:	e0800417 	ldw	r2,16(fp)
   22164:	10001105 	stb	zero,68(r2)
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   22168:	e1bfff17 	ldw	r6,-4(fp)
   2216c:	e17ffc17 	ldw	r5,-16(fp)
   22170:	e13ffb17 	ldw	r4,-20(fp)
   22174:	0020d940 	call	20d94 <pxPortInitialiseStack>
   22178:	1007883a 	mov	r3,r2
   2217c:	e0800417 	ldw	r2,16(fp)
   22180:	10c00015 	stw	r3,0(r2)
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   22184:	e0800317 	ldw	r2,12(fp)
   22188:	10000326 	beq	r2,zero,22198 <prvInitialiseNewTask+0x180>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   2218c:	e0800317 	ldw	r2,12(fp)
   22190:	e0c00417 	ldw	r3,16(fp)
   22194:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   22198:	0001883a 	nop
   2219c:	e037883a 	mov	sp,fp
   221a0:	dfc00117 	ldw	ra,4(sp)
   221a4:	df000017 	ldw	fp,0(sp)
   221a8:	dec00204 	addi	sp,sp,8
   221ac:	f800283a 	ret

000221b0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   221b0:	defffd04 	addi	sp,sp,-12
   221b4:	dfc00215 	stw	ra,8(sp)
   221b8:	df000115 	stw	fp,4(sp)
   221bc:	df000104 	addi	fp,sp,4
   221c0:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   221c4:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   221c8:	d0a01f17 	ldw	r2,-32644(gp)
   221cc:	10800044 	addi	r2,r2,1
   221d0:	d0a01f15 	stw	r2,-32644(gp)
		if( pxCurrentTCB == NULL )
   221d4:	d0a01c17 	ldw	r2,-32656(gp)
   221d8:	1000071e 	bne	r2,zero,221f8 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   221dc:	e0bfff17 	ldw	r2,-4(fp)
   221e0:	d0a01c15 	stw	r2,-32656(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   221e4:	d0a01f17 	ldw	r2,-32644(gp)
   221e8:	10800058 	cmpnei	r2,r2,1
   221ec:	10000b1e 	bne	r2,zero,2221c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   221f0:	0022fe80 	call	22fe8 <prvInitialiseTaskLists>
   221f4:	00000906 	br	2221c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   221f8:	d0a02217 	ldw	r2,-32632(gp)
   221fc:	1000071e 	bne	r2,zero,2221c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   22200:	d0a01c17 	ldw	r2,-32656(gp)
   22204:	10800b17 	ldw	r2,44(r2)
   22208:	e0ffff17 	ldw	r3,-4(fp)
   2220c:	18c00b17 	ldw	r3,44(r3)
   22210:	18800236 	bltu	r3,r2,2221c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
   22214:	e0bfff17 	ldw	r2,-4(fp)
   22218:	d0a01c15 	stw	r2,-32656(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   2221c:	d0a02617 	ldw	r2,-32616(gp)
   22220:	10800044 	addi	r2,r2,1
   22224:	d0a02615 	stw	r2,-32616(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   22228:	e0bfff17 	ldw	r2,-4(fp)
   2222c:	10800b17 	ldw	r2,44(r2)
   22230:	d0e02117 	ldw	r3,-32636(gp)
   22234:	1880032e 	bgeu	r3,r2,22244 <prvAddNewTaskToReadyList+0x94>
   22238:	e0bfff17 	ldw	r2,-4(fp)
   2223c:	10800b17 	ldw	r2,44(r2)
   22240:	d0a02115 	stw	r2,-32636(gp)
   22244:	e0bfff17 	ldw	r2,-4(fp)
   22248:	10800b17 	ldw	r2,44(r2)
   2224c:	10c00524 	muli	r3,r2,20
   22250:	00800134 	movhi	r2,4
   22254:	10a34e04 	addi	r2,r2,-29384
   22258:	1887883a 	add	r3,r3,r2
   2225c:	e0bfff17 	ldw	r2,-4(fp)
   22260:	10800104 	addi	r2,r2,4
   22264:	100b883a 	mov	r5,r2
   22268:	1809883a 	mov	r4,r3
   2226c:	0020b6c0 	call	20b6c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   22270:	00231700 	call	23170 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
   22274:	d0a02217 	ldw	r2,-32632(gp)
   22278:	10000626 	beq	r2,zero,22294 <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   2227c:	d0a01c17 	ldw	r2,-32656(gp)
   22280:	10c00b17 	ldw	r3,44(r2)
   22284:	e0bfff17 	ldw	r2,-4(fp)
   22288:	10800b17 	ldw	r2,44(r2)
   2228c:	1880012e 	bgeu	r3,r2,22294 <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
   22290:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   22294:	0001883a 	nop
   22298:	e037883a 	mov	sp,fp
   2229c:	dfc00117 	ldw	ra,4(sp)
   222a0:	df000017 	ldw	fp,0(sp)
   222a4:	dec00204 	addi	sp,sp,8
   222a8:	f800283a 	ret

000222ac <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
   222ac:	defff804 	addi	sp,sp,-32
   222b0:	dfc00715 	stw	ra,28(sp)
   222b4:	df000615 	stw	fp,24(sp)
   222b8:	df000604 	addi	fp,sp,24
   222bc:	e13ffe15 	stw	r4,-8(fp)
   222c0:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   222c4:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
   222c8:	00227200 	call	22720 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   222cc:	d0a02017 	ldw	r2,-32640(gp)
   222d0:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   222d4:	e0bffe17 	ldw	r2,-8(fp)
   222d8:	10c00017 	ldw	r3,0(r2)
   222dc:	e0bfff17 	ldw	r2,-4(fp)
   222e0:	1885883a 	add	r2,r3,r2
   222e4:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
   222e8:	e0bffe17 	ldw	r2,-8(fp)
   222ec:	10800017 	ldw	r2,0(r2)
   222f0:	e0fffb17 	ldw	r3,-20(fp)
   222f4:	18800a2e 	bgeu	r3,r2,22320 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   222f8:	e0bffe17 	ldw	r2,-8(fp)
   222fc:	10800017 	ldw	r2,0(r2)
   22300:	e0fffc17 	ldw	r3,-16(fp)
   22304:	18800f2e 	bgeu	r3,r2,22344 <vTaskDelayUntil+0x98>
   22308:	e0bffc17 	ldw	r2,-16(fp)
   2230c:	e0fffb17 	ldw	r3,-20(fp)
   22310:	18800c2e 	bgeu	r3,r2,22344 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
   22314:	00800044 	movi	r2,1
   22318:	e0bffa15 	stw	r2,-24(fp)
   2231c:	00000906 	br	22344 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   22320:	e0bffe17 	ldw	r2,-8(fp)
   22324:	10800017 	ldw	r2,0(r2)
   22328:	e0fffc17 	ldw	r3,-16(fp)
   2232c:	18800336 	bltu	r3,r2,2233c <vTaskDelayUntil+0x90>
   22330:	e0bffc17 	ldw	r2,-16(fp)
   22334:	e0fffb17 	ldw	r3,-20(fp)
   22338:	1880022e 	bgeu	r3,r2,22344 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
   2233c:	00800044 	movi	r2,1
   22340:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   22344:	e0bffe17 	ldw	r2,-8(fp)
   22348:	e0fffc17 	ldw	r3,-16(fp)
   2234c:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
   22350:	e0bffa17 	ldw	r2,-24(fp)
   22354:	10000626 	beq	r2,zero,22370 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   22358:	e0fffc17 	ldw	r3,-16(fp)
   2235c:	e0bffb17 	ldw	r2,-20(fp)
   22360:	1885c83a 	sub	r2,r3,r2
   22364:	000b883a 	mov	r5,zero
   22368:	1009883a 	mov	r4,r2
   2236c:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   22370:	002274c0 	call	2274c <xTaskResumeAll>
   22374:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   22378:	e0bffd17 	ldw	r2,-12(fp)
   2237c:	1000011e 	bne	r2,zero,22384 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
   22380:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   22384:	0001883a 	nop
   22388:	e037883a 	mov	sp,fp
   2238c:	dfc00117 	ldw	ra,4(sp)
   22390:	df000017 	ldw	fp,0(sp)
   22394:	dec00204 	addi	sp,sp,8
   22398:	f800283a 	ret

0002239c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   2239c:	defffc04 	addi	sp,sp,-16
   223a0:	dfc00315 	stw	ra,12(sp)
   223a4:	df000215 	stw	fp,8(sp)
   223a8:	df000204 	addi	fp,sp,8
   223ac:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
   223b0:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   223b4:	e0bfff17 	ldw	r2,-4(fp)
   223b8:	10000626 	beq	r2,zero,223d4 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
   223bc:	00227200 	call	22720 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   223c0:	000b883a 	mov	r5,zero
   223c4:	e13fff17 	ldw	r4,-4(fp)
   223c8:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
   223cc:	002274c0 	call	2274c <xTaskResumeAll>
   223d0:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   223d4:	e0bffe17 	ldw	r2,-8(fp)
   223d8:	1000011e 	bne	r2,zero,223e0 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
   223dc:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   223e0:	0001883a 	nop
   223e4:	e037883a 	mov	sp,fp
   223e8:	dfc00117 	ldw	ra,4(sp)
   223ec:	df000017 	ldw	fp,0(sp)
   223f0:	dec00204 	addi	sp,sp,8
   223f4:	f800283a 	ret

000223f8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
   223f8:	defffc04 	addi	sp,sp,-16
   223fc:	dfc00315 	stw	ra,12(sp)
   22400:	df000215 	stw	fp,8(sp)
   22404:	df000204 	addi	fp,sp,8
   22408:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
   2240c:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   22410:	e0bfff17 	ldw	r2,-4(fp)
   22414:	1000021e 	bne	r2,zero,22420 <vTaskSuspend+0x28>
   22418:	d0a01c17 	ldw	r2,-32656(gp)
   2241c:	00000106 	br	22424 <vTaskSuspend+0x2c>
   22420:	e0bfff17 	ldw	r2,-4(fp)
   22424:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   22428:	e0bffe17 	ldw	r2,-8(fp)
   2242c:	10800104 	addi	r2,r2,4
   22430:	1009883a 	mov	r4,r2
   22434:	0020cd00 	call	20cd0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   22438:	e0bffe17 	ldw	r2,-8(fp)
   2243c:	10800a17 	ldw	r2,40(r2)
   22440:	10000426 	beq	r2,zero,22454 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   22444:	e0bffe17 	ldw	r2,-8(fp)
   22448:	10800604 	addi	r2,r2,24
   2244c:	1009883a 	mov	r4,r2
   22450:	0020cd00 	call	20cd0 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   22454:	e0bffe17 	ldw	r2,-8(fp)
   22458:	10800104 	addi	r2,r2,4
   2245c:	100b883a 	mov	r5,r2
   22460:	01000134 	movhi	r4,4
   22464:	21237604 	addi	r4,r4,-29224
   22468:	0020b6c0 	call	20b6c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
   2246c:	00231700 	call	23170 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
   22470:	d0a02217 	ldw	r2,-32632(gp)
   22474:	10000326 	beq	r2,zero,22484 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
   22478:	002311c0 	call	2311c <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
   2247c:	00230b40 	call	230b4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
   22480:	00231700 	call	23170 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
   22484:	d0a01c17 	ldw	r2,-32656(gp)
   22488:	e0fffe17 	ldw	r3,-8(fp)
   2248c:	18800c1e 	bne	r3,r2,224c0 <vTaskSuspend+0xc8>
		{
			if( xSchedulerRunning != pdFALSE )
   22490:	d0a02217 	ldw	r2,-32632(gp)
   22494:	10000226 	beq	r2,zero,224a0 <vTaskSuspend+0xa8>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
   22498:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   2249c:	00000806 	br	224c0 <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   224a0:	00800134 	movhi	r2,4
   224a4:	10a37604 	addi	r2,r2,-29224
   224a8:	10c00017 	ldw	r3,0(r2)
   224ac:	d0a01f17 	ldw	r2,-32644(gp)
   224b0:	1880021e 	bne	r3,r2,224bc <vTaskSuspend+0xc4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
   224b4:	d0201c15 	stw	zero,-32656(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   224b8:	00000106 	br	224c0 <vTaskSuspend+0xc8>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
   224bc:	0022b1c0 	call	22b1c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   224c0:	0001883a 	nop
   224c4:	e037883a 	mov	sp,fp
   224c8:	dfc00117 	ldw	ra,4(sp)
   224cc:	df000017 	ldw	fp,0(sp)
   224d0:	dec00204 	addi	sp,sp,8
   224d4:	f800283a 	ret

000224d8 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
   224d8:	defffc04 	addi	sp,sp,-16
   224dc:	df000315 	stw	fp,12(sp)
   224e0:	df000304 	addi	fp,sp,12
   224e4:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
   224e8:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   224ec:	e0bfff17 	ldw	r2,-4(fp)
   224f0:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   224f4:	e0bffe17 	ldw	r2,-8(fp)
   224f8:	10c00517 	ldw	r3,20(r2)
   224fc:	00800134 	movhi	r2,4
   22500:	10a37604 	addi	r2,r2,-29224
   22504:	1880021e 	bne	r3,r2,22510 <prvTaskIsTaskSuspended+0x38>
   22508:	00800044 	movi	r2,1
   2250c:	00000106 	br	22514 <prvTaskIsTaskSuspended+0x3c>
   22510:	0005883a 	mov	r2,zero
   22514:	10803fcc 	andi	r2,r2,255
   22518:	10000f26 	beq	r2,zero,22558 <prvTaskIsTaskSuspended+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   2251c:	e0bffe17 	ldw	r2,-8(fp)
   22520:	10c00a17 	ldw	r3,40(r2)
   22524:	00800134 	movhi	r2,4
   22528:	10a37104 	addi	r2,r2,-29244
   2252c:	18800a26 	beq	r3,r2,22558 <prvTaskIsTaskSuspended+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   22530:	e0bffe17 	ldw	r2,-8(fp)
   22534:	10800a17 	ldw	r2,40(r2)
   22538:	1000021e 	bne	r2,zero,22544 <prvTaskIsTaskSuspended+0x6c>
   2253c:	00800044 	movi	r2,1
   22540:	00000106 	br	22548 <prvTaskIsTaskSuspended+0x70>
   22544:	0005883a 	mov	r2,zero
   22548:	10803fcc 	andi	r2,r2,255
   2254c:	10000226 	beq	r2,zero,22558 <prvTaskIsTaskSuspended+0x80>
				{
					xReturn = pdTRUE;
   22550:	00800044 	movi	r2,1
   22554:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   22558:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   2255c:	e037883a 	mov	sp,fp
   22560:	df000017 	ldw	fp,0(sp)
   22564:	dec00104 	addi	sp,sp,4
   22568:	f800283a 	ret

0002256c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
   2256c:	defffc04 	addi	sp,sp,-16
   22570:	dfc00315 	stw	ra,12(sp)
   22574:	df000215 	stw	fp,8(sp)
   22578:	df000204 	addi	fp,sp,8
   2257c:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   22580:	e0bfff17 	ldw	r2,-4(fp)
   22584:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   22588:	e0bffe17 	ldw	r2,-8(fp)
   2258c:	10002426 	beq	r2,zero,22620 <vTaskResume+0xb4>
   22590:	d0a01c17 	ldw	r2,-32656(gp)
   22594:	e0fffe17 	ldw	r3,-8(fp)
   22598:	18802126 	beq	r3,r2,22620 <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
   2259c:	002311c0 	call	2311c <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   225a0:	e13ffe17 	ldw	r4,-8(fp)
   225a4:	00224d80 	call	224d8 <prvTaskIsTaskSuspended>
   225a8:	10001c26 	beq	r2,zero,2261c <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   225ac:	e0bffe17 	ldw	r2,-8(fp)
   225b0:	10800104 	addi	r2,r2,4
   225b4:	1009883a 	mov	r4,r2
   225b8:	0020cd00 	call	20cd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   225bc:	e0bffe17 	ldw	r2,-8(fp)
   225c0:	10800b17 	ldw	r2,44(r2)
   225c4:	d0e02117 	ldw	r3,-32636(gp)
   225c8:	1880032e 	bgeu	r3,r2,225d8 <vTaskResume+0x6c>
   225cc:	e0bffe17 	ldw	r2,-8(fp)
   225d0:	10800b17 	ldw	r2,44(r2)
   225d4:	d0a02115 	stw	r2,-32636(gp)
   225d8:	e0bffe17 	ldw	r2,-8(fp)
   225dc:	10800b17 	ldw	r2,44(r2)
   225e0:	10c00524 	muli	r3,r2,20
   225e4:	00800134 	movhi	r2,4
   225e8:	10a34e04 	addi	r2,r2,-29384
   225ec:	1887883a 	add	r3,r3,r2
   225f0:	e0bffe17 	ldw	r2,-8(fp)
   225f4:	10800104 	addi	r2,r2,4
   225f8:	100b883a 	mov	r5,r2
   225fc:	1809883a 	mov	r4,r3
   22600:	0020b6c0 	call	20b6c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   22604:	e0bffe17 	ldw	r2,-8(fp)
   22608:	10c00b17 	ldw	r3,44(r2)
   2260c:	d0a01c17 	ldw	r2,-32656(gp)
   22610:	10800b17 	ldw	r2,44(r2)
   22614:	18800136 	bltu	r3,r2,2261c <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
   22618:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
   2261c:	00231700 	call	23170 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   22620:	0001883a 	nop
   22624:	e037883a 	mov	sp,fp
   22628:	dfc00117 	ldw	ra,4(sp)
   2262c:	df000017 	ldw	fp,0(sp)
   22630:	dec00204 	addi	sp,sp,8
   22634:	f800283a 	ret

00022638 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   22638:	defffa04 	addi	sp,sp,-24
   2263c:	dfc00515 	stw	ra,20(sp)
   22640:	df000415 	stw	fp,16(sp)
   22644:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   22648:	d0a02804 	addi	r2,gp,-32608
   2264c:	d8800115 	stw	r2,4(sp)
   22650:	d8000015 	stw	zero,0(sp)
   22654:	000f883a 	mov	r7,zero
   22658:	01804004 	movi	r6,256
   2265c:	014000f4 	movhi	r5,3
   22660:	294a6004 	addi	r5,r5,10624
   22664:	010000b4 	movhi	r4,2
   22668:	210bed04 	addi	r4,r4,12212
   2266c:	0021f300 	call	21f30 <xTaskCreate>
   22670:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   22674:	e0bffe17 	ldw	r2,-8(fp)
   22678:	10800058 	cmpnei	r2,r2,1
   2267c:	1000101e 	bne	r2,zero,226c0 <vTaskStartScheduler+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   22680:	0005303a 	rdctl	r2,status
   22684:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   22688:	e0ffff17 	ldw	r3,-4(fp)
   2268c:	00bfff84 	movi	r2,-2
   22690:	1884703a 	and	r2,r3,r2
   22694:	1001703a 	wrctl	status,r2
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   22698:	00bfffc4 	movi	r2,-1
   2269c:	d0a02715 	stw	r2,-32612(gp)
		xSchedulerRunning = pdTRUE;
   226a0:	00800044 	movi	r2,1
   226a4:	d0a02215 	stw	r2,-32632(gp)
		xTickCount = ( TickType_t ) 0U;
   226a8:	d0202015 	stw	zero,-32640(gp)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		IOWR_ALTERA_AVALON_PIO_DATA(ONBOARD_LED_BASE, 0xFF);
   226ac:	00c03fc4 	movi	r3,255
   226b0:	00800074 	movhi	r2,1
   226b4:	10801404 	addi	r2,r2,80
   226b8:	10c00035 	stwio	r3,0(r2)
		if( xPortStartScheduler() != pdFALSE )
   226bc:	0020e740 	call	20e74 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   226c0:	0001883a 	nop
   226c4:	e037883a 	mov	sp,fp
   226c8:	dfc00117 	ldw	ra,4(sp)
   226cc:	df000017 	ldw	fp,0(sp)
   226d0:	dec00204 	addi	sp,sp,8
   226d4:	f800283a 	ret

000226d8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
   226d8:	defffd04 	addi	sp,sp,-12
   226dc:	dfc00215 	stw	ra,8(sp)
   226e0:	df000115 	stw	fp,4(sp)
   226e4:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   226e8:	0005303a 	rdctl	r2,status
   226ec:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   226f0:	e0ffff17 	ldw	r3,-4(fp)
   226f4:	00bfff84 	movi	r2,-2
   226f8:	1884703a 	and	r2,r3,r2
   226fc:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
   22700:	d0202215 	stw	zero,-32632(gp)
	vPortEndScheduler();
   22704:	0020eac0 	call	20eac <vPortEndScheduler>
}
   22708:	0001883a 	nop
   2270c:	e037883a 	mov	sp,fp
   22710:	dfc00117 	ldw	ra,4(sp)
   22714:	df000017 	ldw	fp,0(sp)
   22718:	dec00204 	addi	sp,sp,8
   2271c:	f800283a 	ret

00022720 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   22720:	deffff04 	addi	sp,sp,-4
   22724:	df000015 	stw	fp,0(sp)
   22728:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   2272c:	d0a02917 	ldw	r2,-32604(gp)
   22730:	10800044 	addi	r2,r2,1
   22734:	d0a02915 	stw	r2,-32604(gp)
}
   22738:	0001883a 	nop
   2273c:	e037883a 	mov	sp,fp
   22740:	df000017 	ldw	fp,0(sp)
   22744:	dec00104 	addi	sp,sp,4
   22748:	f800283a 	ret

0002274c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   2274c:	defffb04 	addi	sp,sp,-20
   22750:	dfc00415 	stw	ra,16(sp)
   22754:	df000315 	stw	fp,12(sp)
   22758:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
   2275c:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
   22760:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   22764:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
   22768:	d0a02917 	ldw	r2,-32604(gp)
   2276c:	10bfffc4 	addi	r2,r2,-1
   22770:	d0a02915 	stw	r2,-32604(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   22774:	d0a02917 	ldw	r2,-32604(gp)
   22778:	1000431e 	bne	r2,zero,22888 <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   2277c:	d0a01f17 	ldw	r2,-32644(gp)
   22780:	10004126 	beq	r2,zero,22888 <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   22784:	00002606 	br	22820 <xTaskResumeAll+0xd4>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   22788:	00800134 	movhi	r2,4
   2278c:	10a37104 	addi	r2,r2,-29244
   22790:	10800317 	ldw	r2,12(r2)
   22794:	10800317 	ldw	r2,12(r2)
   22798:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2279c:	e0bffd17 	ldw	r2,-12(fp)
   227a0:	10800604 	addi	r2,r2,24
   227a4:	1009883a 	mov	r4,r2
   227a8:	0020cd00 	call	20cd0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   227ac:	e0bffd17 	ldw	r2,-12(fp)
   227b0:	10800104 	addi	r2,r2,4
   227b4:	1009883a 	mov	r4,r2
   227b8:	0020cd00 	call	20cd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   227bc:	e0bffd17 	ldw	r2,-12(fp)
   227c0:	10800b17 	ldw	r2,44(r2)
   227c4:	d0e02117 	ldw	r3,-32636(gp)
   227c8:	1880032e 	bgeu	r3,r2,227d8 <xTaskResumeAll+0x8c>
   227cc:	e0bffd17 	ldw	r2,-12(fp)
   227d0:	10800b17 	ldw	r2,44(r2)
   227d4:	d0a02115 	stw	r2,-32636(gp)
   227d8:	e0bffd17 	ldw	r2,-12(fp)
   227dc:	10800b17 	ldw	r2,44(r2)
   227e0:	10c00524 	muli	r3,r2,20
   227e4:	00800134 	movhi	r2,4
   227e8:	10a34e04 	addi	r2,r2,-29384
   227ec:	1887883a 	add	r3,r3,r2
   227f0:	e0bffd17 	ldw	r2,-12(fp)
   227f4:	10800104 	addi	r2,r2,4
   227f8:	100b883a 	mov	r5,r2
   227fc:	1809883a 	mov	r4,r3
   22800:	0020b6c0 	call	20b6c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   22804:	e0bffd17 	ldw	r2,-12(fp)
   22808:	10c00b17 	ldw	r3,44(r2)
   2280c:	d0a01c17 	ldw	r2,-32656(gp)
   22810:	10800b17 	ldw	r2,44(r2)
   22814:	18800236 	bltu	r3,r2,22820 <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
   22818:	00800044 	movi	r2,1
   2281c:	d0a02415 	stw	r2,-32624(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   22820:	00800134 	movhi	r2,4
   22824:	10a37104 	addi	r2,r2,-29244
   22828:	10800017 	ldw	r2,0(r2)
   2282c:	103fd61e 	bne	r2,zero,22788 <__reset+0xfff82788>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   22830:	e0bffd17 	ldw	r2,-12(fp)
   22834:	10000126 	beq	r2,zero,2283c <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   22838:	00230b40 	call	230b4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   2283c:	d0a02317 	ldw	r2,-32628(gp)
   22840:	e0bfff15 	stw	r2,-4(fp)

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   22844:	e0bfff17 	ldw	r2,-4(fp)
   22848:	10000a26 	beq	r2,zero,22874 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   2284c:	00229580 	call	22958 <xTaskIncrementTick>
   22850:	10000226 	beq	r2,zero,2285c <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
   22854:	00800044 	movi	r2,1
   22858:	d0a02415 	stw	r2,-32624(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   2285c:	e0bfff17 	ldw	r2,-4(fp)
   22860:	10bfffc4 	addi	r2,r2,-1
   22864:	e0bfff15 	stw	r2,-4(fp)
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   22868:	e0bfff17 	ldw	r2,-4(fp)
   2286c:	103ff71e 	bne	r2,zero,2284c <__reset+0xfff8284c>

						uxPendedTicks = 0;
   22870:	d0202315 	stw	zero,-32628(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   22874:	d0a02417 	ldw	r2,-32624(gp)
   22878:	10000326 	beq	r2,zero,22888 <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   2287c:	00800044 	movi	r2,1
   22880:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   22884:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   22888:	00231700 	call	23170 <vTaskExitCritical>

	return xAlreadyYielded;
   2288c:	e0bffe17 	ldw	r2,-8(fp)
}
   22890:	e037883a 	mov	sp,fp
   22894:	dfc00117 	ldw	ra,4(sp)
   22898:	df000017 	ldw	fp,0(sp)
   2289c:	dec00204 	addi	sp,sp,8
   228a0:	f800283a 	ret

000228a4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   228a4:	defffe04 	addi	sp,sp,-8
   228a8:	df000115 	stw	fp,4(sp)
   228ac:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
   228b0:	d0a02017 	ldw	r2,-32640(gp)
   228b4:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
   228b8:	e0bfff17 	ldw	r2,-4(fp)
}
   228bc:	e037883a 	mov	sp,fp
   228c0:	df000017 	ldw	fp,0(sp)
   228c4:	dec00104 	addi	sp,sp,4
   228c8:	f800283a 	ret

000228cc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
   228cc:	defffd04 	addi	sp,sp,-12
   228d0:	df000215 	stw	fp,8(sp)
   228d4:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   228d8:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
   228dc:	d0a02017 	ldw	r2,-32640(gp)
   228e0:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   228e4:	e0bfff17 	ldw	r2,-4(fp)
}
   228e8:	e037883a 	mov	sp,fp
   228ec:	df000017 	ldw	fp,0(sp)
   228f0:	dec00104 	addi	sp,sp,4
   228f4:	f800283a 	ret

000228f8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
   228f8:	deffff04 	addi	sp,sp,-4
   228fc:	df000015 	stw	fp,0(sp)
   22900:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
   22904:	d0a01f17 	ldw	r2,-32644(gp)
}
   22908:	e037883a 	mov	sp,fp
   2290c:	df000017 	ldw	fp,0(sp)
   22910:	dec00104 	addi	sp,sp,4
   22914:	f800283a 	ret

00022918 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   22918:	defffd04 	addi	sp,sp,-12
   2291c:	df000215 	stw	fp,8(sp)
   22920:	df000204 	addi	fp,sp,8
   22924:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   22928:	e0bfff17 	ldw	r2,-4(fp)
   2292c:	1000021e 	bne	r2,zero,22938 <pcTaskGetName+0x20>
   22930:	d0a01c17 	ldw	r2,-32656(gp)
   22934:	00000106 	br	2293c <pcTaskGetName+0x24>
   22938:	e0bfff17 	ldw	r2,-4(fp)
   2293c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
   22940:	e0bffe17 	ldw	r2,-8(fp)
   22944:	10800d04 	addi	r2,r2,52
}
   22948:	e037883a 	mov	sp,fp
   2294c:	df000017 	ldw	fp,0(sp)
   22950:	dec00104 	addi	sp,sp,4
   22954:	f800283a 	ret

00022958 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   22958:	defff904 	addi	sp,sp,-28
   2295c:	dfc00615 	stw	ra,24(sp)
   22960:	df000515 	stw	fp,20(sp)
   22964:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   22968:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2296c:	d0a02917 	ldw	r2,-32604(gp)
   22970:	10005d1e 	bne	r2,zero,22ae8 <xTaskIncrementTick+0x190>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
   22974:	d0a02017 	ldw	r2,-32640(gp)
   22978:	10800044 	addi	r2,r2,1
   2297c:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   22980:	e0bffc17 	ldw	r2,-16(fp)
   22984:	d0a02015 	stw	r2,-32640(gp)

		if( xConstTickCount == ( TickType_t ) 0U )
   22988:	e0bffc17 	ldw	r2,-16(fp)
   2298c:	10000a1e 	bne	r2,zero,229b8 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
   22990:	d0a01d17 	ldw	r2,-32652(gp)
   22994:	e0bffd15 	stw	r2,-12(fp)
   22998:	d0a01e17 	ldw	r2,-32648(gp)
   2299c:	d0a01d15 	stw	r2,-32652(gp)
   229a0:	e0bffd17 	ldw	r2,-12(fp)
   229a4:	d0a01e15 	stw	r2,-32648(gp)
   229a8:	d0a02517 	ldw	r2,-32620(gp)
   229ac:	10800044 	addi	r2,r2,1
   229b0:	d0a02515 	stw	r2,-32620(gp)
   229b4:	00230b40 	call	230b4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   229b8:	d0a02717 	ldw	r2,-32612(gp)
   229bc:	e0fffc17 	ldw	r3,-16(fp)
   229c0:	18803d36 	bltu	r3,r2,22ab8 <xTaskIncrementTick+0x160>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   229c4:	d0a01d17 	ldw	r2,-32652(gp)
   229c8:	10800017 	ldw	r2,0(r2)
   229cc:	1000021e 	bne	r2,zero,229d8 <xTaskIncrementTick+0x80>
   229d0:	00800044 	movi	r2,1
   229d4:	00000106 	br	229dc <xTaskIncrementTick+0x84>
   229d8:	0005883a 	mov	r2,zero
   229dc:	10803fcc 	andi	r2,r2,255
   229e0:	10000326 	beq	r2,zero,229f0 <xTaskIncrementTick+0x98>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   229e4:	00bfffc4 	movi	r2,-1
   229e8:	d0a02715 	stw	r2,-32612(gp)
					break;
   229ec:	00003206 	br	22ab8 <xTaskIncrementTick+0x160>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   229f0:	d0a01d17 	ldw	r2,-32652(gp)
   229f4:	10800317 	ldw	r2,12(r2)
   229f8:	10800317 	ldw	r2,12(r2)
   229fc:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   22a00:	e0bffe17 	ldw	r2,-8(fp)
   22a04:	10800117 	ldw	r2,4(r2)
   22a08:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
   22a0c:	e0fffc17 	ldw	r3,-16(fp)
   22a10:	e0bfff17 	ldw	r2,-4(fp)
   22a14:	1880032e 	bgeu	r3,r2,22a24 <xTaskIncrementTick+0xcc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   22a18:	e0bfff17 	ldw	r2,-4(fp)
   22a1c:	d0a02715 	stw	r2,-32612(gp)
						break;
   22a20:	00002506 	br	22ab8 <xTaskIncrementTick+0x160>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   22a24:	e0bffe17 	ldw	r2,-8(fp)
   22a28:	10800104 	addi	r2,r2,4
   22a2c:	1009883a 	mov	r4,r2
   22a30:	0020cd00 	call	20cd0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   22a34:	e0bffe17 	ldw	r2,-8(fp)
   22a38:	10800a17 	ldw	r2,40(r2)
   22a3c:	10000426 	beq	r2,zero,22a50 <xTaskIncrementTick+0xf8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   22a40:	e0bffe17 	ldw	r2,-8(fp)
   22a44:	10800604 	addi	r2,r2,24
   22a48:	1009883a 	mov	r4,r2
   22a4c:	0020cd00 	call	20cd0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   22a50:	e0bffe17 	ldw	r2,-8(fp)
   22a54:	10800b17 	ldw	r2,44(r2)
   22a58:	d0e02117 	ldw	r3,-32636(gp)
   22a5c:	1880032e 	bgeu	r3,r2,22a6c <xTaskIncrementTick+0x114>
   22a60:	e0bffe17 	ldw	r2,-8(fp)
   22a64:	10800b17 	ldw	r2,44(r2)
   22a68:	d0a02115 	stw	r2,-32636(gp)
   22a6c:	e0bffe17 	ldw	r2,-8(fp)
   22a70:	10800b17 	ldw	r2,44(r2)
   22a74:	10c00524 	muli	r3,r2,20
   22a78:	00800134 	movhi	r2,4
   22a7c:	10a34e04 	addi	r2,r2,-29384
   22a80:	1887883a 	add	r3,r3,r2
   22a84:	e0bffe17 	ldw	r2,-8(fp)
   22a88:	10800104 	addi	r2,r2,4
   22a8c:	100b883a 	mov	r5,r2
   22a90:	1809883a 	mov	r4,r3
   22a94:	0020b6c0 	call	20b6c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   22a98:	e0bffe17 	ldw	r2,-8(fp)
   22a9c:	10c00b17 	ldw	r3,44(r2)
   22aa0:	d0a01c17 	ldw	r2,-32656(gp)
   22aa4:	10800b17 	ldw	r2,44(r2)
   22aa8:	18bfc636 	bltu	r3,r2,229c4 <__reset+0xfff829c4>
						{
							xSwitchRequired = pdTRUE;
   22aac:	00800044 	movi	r2,1
   22ab0:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
   22ab4:	003fc306 	br	229c4 <__reset+0xfff829c4>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   22ab8:	d0a01c17 	ldw	r2,-32656(gp)
   22abc:	10c00b17 	ldw	r3,44(r2)
   22ac0:	00800134 	movhi	r2,4
   22ac4:	10a34e04 	addi	r2,r2,-29384
   22ac8:	18c00524 	muli	r3,r3,20
   22acc:	10c5883a 	add	r2,r2,r3
   22ad0:	10800017 	ldw	r2,0(r2)
   22ad4:	108000b0 	cmpltui	r2,r2,2
   22ad8:	1000061e 	bne	r2,zero,22af4 <xTaskIncrementTick+0x19c>
			{
				xSwitchRequired = pdTRUE;
   22adc:	00800044 	movi	r2,1
   22ae0:	e0bffb15 	stw	r2,-20(fp)
   22ae4:	00000306 	br	22af4 <xTaskIncrementTick+0x19c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   22ae8:	d0a02317 	ldw	r2,-32628(gp)
   22aec:	10800044 	addi	r2,r2,1
   22af0:	d0a02315 	stw	r2,-32628(gp)
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   22af4:	d0a02417 	ldw	r2,-32624(gp)
   22af8:	10000226 	beq	r2,zero,22b04 <xTaskIncrementTick+0x1ac>
		{
			xSwitchRequired = pdTRUE;
   22afc:	00800044 	movi	r2,1
   22b00:	e0bffb15 	stw	r2,-20(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   22b04:	e0bffb17 	ldw	r2,-20(fp)
}
   22b08:	e037883a 	mov	sp,fp
   22b0c:	dfc00117 	ldw	ra,4(sp)
   22b10:	df000017 	ldw	fp,0(sp)
   22b14:	dec00204 	addi	sp,sp,8
   22b18:	f800283a 	ret

00022b1c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   22b1c:	defffd04 	addi	sp,sp,-12
   22b20:	df000215 	stw	fp,8(sp)
   22b24:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   22b28:	d0a02917 	ldw	r2,-32604(gp)
   22b2c:	10000326 	beq	r2,zero,22b3c <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   22b30:	00800044 	movi	r2,1
   22b34:	d0a02415 	stw	r2,-32624(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   22b38:	00002906 	br	22be0 <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
   22b3c:	d0202415 	stw	zero,-32624(gp)
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
   22b40:	d0a02117 	ldw	r2,-32636(gp)
   22b44:	e0bffe15 	stw	r2,-8(fp)
   22b48:	00000306 	br	22b58 <vTaskSwitchContext+0x3c>
   22b4c:	e0bffe17 	ldw	r2,-8(fp)
   22b50:	10bfffc4 	addi	r2,r2,-1
   22b54:	e0bffe15 	stw	r2,-8(fp)
   22b58:	00800134 	movhi	r2,4
   22b5c:	10a34e04 	addi	r2,r2,-29384
   22b60:	e0fffe17 	ldw	r3,-8(fp)
   22b64:	18c00524 	muli	r3,r3,20
   22b68:	10c5883a 	add	r2,r2,r3
   22b6c:	10800017 	ldw	r2,0(r2)
   22b70:	103ff626 	beq	r2,zero,22b4c <__reset+0xfff82b4c>
   22b74:	e0bffe17 	ldw	r2,-8(fp)
   22b78:	10c00524 	muli	r3,r2,20
   22b7c:	00800134 	movhi	r2,4
   22b80:	10a34e04 	addi	r2,r2,-29384
   22b84:	1885883a 	add	r2,r3,r2
   22b88:	e0bfff15 	stw	r2,-4(fp)
   22b8c:	e0bfff17 	ldw	r2,-4(fp)
   22b90:	10800117 	ldw	r2,4(r2)
   22b94:	10c00117 	ldw	r3,4(r2)
   22b98:	e0bfff17 	ldw	r2,-4(fp)
   22b9c:	10c00115 	stw	r3,4(r2)
   22ba0:	e0bfff17 	ldw	r2,-4(fp)
   22ba4:	10c00117 	ldw	r3,4(r2)
   22ba8:	e0bfff17 	ldw	r2,-4(fp)
   22bac:	10800204 	addi	r2,r2,8
   22bb0:	1880051e 	bne	r3,r2,22bc8 <vTaskSwitchContext+0xac>
   22bb4:	e0bfff17 	ldw	r2,-4(fp)
   22bb8:	10800117 	ldw	r2,4(r2)
   22bbc:	10c00117 	ldw	r3,4(r2)
   22bc0:	e0bfff17 	ldw	r2,-4(fp)
   22bc4:	10c00115 	stw	r3,4(r2)
   22bc8:	e0bfff17 	ldw	r2,-4(fp)
   22bcc:	10800117 	ldw	r2,4(r2)
   22bd0:	10800317 	ldw	r2,12(r2)
   22bd4:	d0a01c15 	stw	r2,-32656(gp)
   22bd8:	e0bffe17 	ldw	r2,-8(fp)
   22bdc:	d0a02115 	stw	r2,-32636(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   22be0:	0001883a 	nop
   22be4:	e037883a 	mov	sp,fp
   22be8:	df000017 	ldw	fp,0(sp)
   22bec:	dec00104 	addi	sp,sp,4
   22bf0:	f800283a 	ret

00022bf4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   22bf4:	defffc04 	addi	sp,sp,-16
   22bf8:	dfc00315 	stw	ra,12(sp)
   22bfc:	df000215 	stw	fp,8(sp)
   22c00:	df000204 	addi	fp,sp,8
   22c04:	e13ffe15 	stw	r4,-8(fp)
   22c08:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   22c0c:	d0a01c17 	ldw	r2,-32656(gp)
   22c10:	10800604 	addi	r2,r2,24
   22c14:	100b883a 	mov	r5,r2
   22c18:	e13ffe17 	ldw	r4,-8(fp)
   22c1c:	0020bf80 	call	20bf8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   22c20:	01400044 	movi	r5,1
   22c24:	e13fff17 	ldw	r4,-4(fp)
   22c28:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>
}
   22c2c:	0001883a 	nop
   22c30:	e037883a 	mov	sp,fp
   22c34:	dfc00117 	ldw	ra,4(sp)
   22c38:	df000017 	ldw	fp,0(sp)
   22c3c:	dec00204 	addi	sp,sp,8
   22c40:	f800283a 	ret

00022c44 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
   22c44:	defffb04 	addi	sp,sp,-20
   22c48:	dfc00415 	stw	ra,16(sp)
   22c4c:	df000315 	stw	fp,12(sp)
   22c50:	df000304 	addi	fp,sp,12
   22c54:	e13ffd15 	stw	r4,-12(fp)
   22c58:	e17ffe15 	stw	r5,-8(fp)
   22c5c:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   22c60:	d0a01c17 	ldw	r2,-32656(gp)
   22c64:	e0fffe17 	ldw	r3,-8(fp)
   22c68:	18e00034 	orhi	r3,r3,32768
   22c6c:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   22c70:	d0a01c17 	ldw	r2,-32656(gp)
   22c74:	10800604 	addi	r2,r2,24
   22c78:	100b883a 	mov	r5,r2
   22c7c:	e13ffd17 	ldw	r4,-12(fp)
   22c80:	0020b6c0 	call	20b6c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   22c84:	01400044 	movi	r5,1
   22c88:	e13fff17 	ldw	r4,-4(fp)
   22c8c:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>
}
   22c90:	0001883a 	nop
   22c94:	e037883a 	mov	sp,fp
   22c98:	dfc00117 	ldw	ra,4(sp)
   22c9c:	df000017 	ldw	fp,0(sp)
   22ca0:	dec00204 	addi	sp,sp,8
   22ca4:	f800283a 	ret

00022ca8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   22ca8:	defffb04 	addi	sp,sp,-20
   22cac:	dfc00415 	stw	ra,16(sp)
   22cb0:	df000315 	stw	fp,12(sp)
   22cb4:	df000304 	addi	fp,sp,12
   22cb8:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   22cbc:	e0bfff17 	ldw	r2,-4(fp)
   22cc0:	10800317 	ldw	r2,12(r2)
   22cc4:	10800317 	ldw	r2,12(r2)
   22cc8:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   22ccc:	e0bffe17 	ldw	r2,-8(fp)
   22cd0:	10800604 	addi	r2,r2,24
   22cd4:	1009883a 	mov	r4,r2
   22cd8:	0020cd00 	call	20cd0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   22cdc:	d0a02917 	ldw	r2,-32604(gp)
   22ce0:	1000171e 	bne	r2,zero,22d40 <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   22ce4:	e0bffe17 	ldw	r2,-8(fp)
   22ce8:	10800104 	addi	r2,r2,4
   22cec:	1009883a 	mov	r4,r2
   22cf0:	0020cd00 	call	20cd0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   22cf4:	e0bffe17 	ldw	r2,-8(fp)
   22cf8:	10800b17 	ldw	r2,44(r2)
   22cfc:	d0e02117 	ldw	r3,-32636(gp)
   22d00:	1880032e 	bgeu	r3,r2,22d10 <xTaskRemoveFromEventList+0x68>
   22d04:	e0bffe17 	ldw	r2,-8(fp)
   22d08:	10800b17 	ldw	r2,44(r2)
   22d0c:	d0a02115 	stw	r2,-32636(gp)
   22d10:	e0bffe17 	ldw	r2,-8(fp)
   22d14:	10800b17 	ldw	r2,44(r2)
   22d18:	10c00524 	muli	r3,r2,20
   22d1c:	00800134 	movhi	r2,4
   22d20:	10a34e04 	addi	r2,r2,-29384
   22d24:	1887883a 	add	r3,r3,r2
   22d28:	e0bffe17 	ldw	r2,-8(fp)
   22d2c:	10800104 	addi	r2,r2,4
   22d30:	100b883a 	mov	r5,r2
   22d34:	1809883a 	mov	r4,r3
   22d38:	0020b6c0 	call	20b6c <vListInsertEnd>
   22d3c:	00000606 	br	22d58 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   22d40:	e0bffe17 	ldw	r2,-8(fp)
   22d44:	10800604 	addi	r2,r2,24
   22d48:	100b883a 	mov	r5,r2
   22d4c:	01000134 	movhi	r4,4
   22d50:	21237104 	addi	r4,r4,-29244
   22d54:	0020b6c0 	call	20b6c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   22d58:	e0bffe17 	ldw	r2,-8(fp)
   22d5c:	10800b17 	ldw	r2,44(r2)
   22d60:	d0e01c17 	ldw	r3,-32656(gp)
   22d64:	18c00b17 	ldw	r3,44(r3)
   22d68:	1880052e 	bgeu	r3,r2,22d80 <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   22d6c:	00800044 	movi	r2,1
   22d70:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   22d74:	00800044 	movi	r2,1
   22d78:	d0a02415 	stw	r2,-32624(gp)
   22d7c:	00000106 	br	22d84 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
   22d80:	e03ffd15 	stw	zero,-12(fp)
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   22d84:	e0bffd17 	ldw	r2,-12(fp)
}
   22d88:	e037883a 	mov	sp,fp
   22d8c:	dfc00117 	ldw	ra,4(sp)
   22d90:	df000017 	ldw	fp,0(sp)
   22d94:	dec00204 	addi	sp,sp,8
   22d98:	f800283a 	ret

00022d9c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
   22d9c:	defffa04 	addi	sp,sp,-24
   22da0:	dfc00515 	stw	ra,20(sp)
   22da4:	df000415 	stw	fp,16(sp)
   22da8:	df000404 	addi	fp,sp,16
   22dac:	e13ffe15 	stw	r4,-8(fp)
   22db0:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   22db4:	e0bfff17 	ldw	r2,-4(fp)
   22db8:	10e00034 	orhi	r3,r2,32768
   22dbc:	e0bffe17 	ldw	r2,-8(fp)
   22dc0:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   22dc4:	e0bffe17 	ldw	r2,-8(fp)
   22dc8:	10800317 	ldw	r2,12(r2)
   22dcc:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
   22dd0:	e13ffe17 	ldw	r4,-8(fp)
   22dd4:	0020cd00 	call	20cd0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   22dd8:	e0bffd17 	ldw	r2,-12(fp)
   22ddc:	10800104 	addi	r2,r2,4
   22de0:	1009883a 	mov	r4,r2
   22de4:	0020cd00 	call	20cd0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
   22de8:	e0bffd17 	ldw	r2,-12(fp)
   22dec:	10800b17 	ldw	r2,44(r2)
   22df0:	d0e02117 	ldw	r3,-32636(gp)
   22df4:	1880032e 	bgeu	r3,r2,22e04 <xTaskRemoveFromUnorderedEventList+0x68>
   22df8:	e0bffd17 	ldw	r2,-12(fp)
   22dfc:	10800b17 	ldw	r2,44(r2)
   22e00:	d0a02115 	stw	r2,-32636(gp)
   22e04:	e0bffd17 	ldw	r2,-12(fp)
   22e08:	10800b17 	ldw	r2,44(r2)
   22e0c:	10c00524 	muli	r3,r2,20
   22e10:	00800134 	movhi	r2,4
   22e14:	10a34e04 	addi	r2,r2,-29384
   22e18:	1887883a 	add	r3,r3,r2
   22e1c:	e0bffd17 	ldw	r2,-12(fp)
   22e20:	10800104 	addi	r2,r2,4
   22e24:	100b883a 	mov	r5,r2
   22e28:	1809883a 	mov	r4,r3
   22e2c:	0020b6c0 	call	20b6c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   22e30:	e0bffd17 	ldw	r2,-12(fp)
   22e34:	10800b17 	ldw	r2,44(r2)
   22e38:	d0e01c17 	ldw	r3,-32656(gp)
   22e3c:	18c00b17 	ldw	r3,44(r3)
   22e40:	1880052e 	bgeu	r3,r2,22e58 <xTaskRemoveFromUnorderedEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
   22e44:	00800044 	movi	r2,1
   22e48:	e0bffc15 	stw	r2,-16(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   22e4c:	00800044 	movi	r2,1
   22e50:	d0a02415 	stw	r2,-32624(gp)
   22e54:	00000106 	br	22e5c <xTaskRemoveFromUnorderedEventList+0xc0>
	}
	else
	{
		xReturn = pdFALSE;
   22e58:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
   22e5c:	e0bffc17 	ldw	r2,-16(fp)
}
   22e60:	e037883a 	mov	sp,fp
   22e64:	dfc00117 	ldw	ra,4(sp)
   22e68:	df000017 	ldw	fp,0(sp)
   22e6c:	dec00204 	addi	sp,sp,8
   22e70:	f800283a 	ret

00022e74 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   22e74:	defffe04 	addi	sp,sp,-8
   22e78:	df000115 	stw	fp,4(sp)
   22e7c:	df000104 	addi	fp,sp,4
   22e80:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   22e84:	d0e02517 	ldw	r3,-32620(gp)
   22e88:	e0bfff17 	ldw	r2,-4(fp)
   22e8c:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
   22e90:	d0e02017 	ldw	r3,-32640(gp)
   22e94:	e0bfff17 	ldw	r2,-4(fp)
   22e98:	10c00115 	stw	r3,4(r2)
}
   22e9c:	0001883a 	nop
   22ea0:	e037883a 	mov	sp,fp
   22ea4:	df000017 	ldw	fp,0(sp)
   22ea8:	dec00104 	addi	sp,sp,4
   22eac:	f800283a 	ret

00022eb0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   22eb0:	defffa04 	addi	sp,sp,-24
   22eb4:	dfc00515 	stw	ra,20(sp)
   22eb8:	df000415 	stw	fp,16(sp)
   22ebc:	df000404 	addi	fp,sp,16
   22ec0:	e13ffe15 	stw	r4,-8(fp)
   22ec4:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   22ec8:	002311c0 	call	2311c <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   22ecc:	d0a02017 	ldw	r2,-32640(gp)
   22ed0:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   22ed4:	e0bfff17 	ldw	r2,-4(fp)
   22ed8:	10800017 	ldw	r2,0(r2)
   22edc:	10bfffd8 	cmpnei	r2,r2,-1
   22ee0:	1000021e 	bne	r2,zero,22eec <xTaskCheckForTimeOut+0x3c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   22ee4:	e03ffc15 	stw	zero,-16(fp)
   22ee8:	00002106 	br	22f70 <xTaskCheckForTimeOut+0xc0>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   22eec:	e0bffe17 	ldw	r2,-8(fp)
   22ef0:	10c00017 	ldw	r3,0(r2)
   22ef4:	d0a02517 	ldw	r2,-32620(gp)
   22ef8:	18800726 	beq	r3,r2,22f18 <xTaskCheckForTimeOut+0x68>
   22efc:	e0bffe17 	ldw	r2,-8(fp)
   22f00:	10800117 	ldw	r2,4(r2)
   22f04:	e0fffd17 	ldw	r3,-12(fp)
   22f08:	18800336 	bltu	r3,r2,22f18 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   22f0c:	00800044 	movi	r2,1
   22f10:	e0bffc15 	stw	r2,-16(fp)
   22f14:	00001606 	br	22f70 <xTaskCheckForTimeOut+0xc0>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   22f18:	e0bffe17 	ldw	r2,-8(fp)
   22f1c:	10800117 	ldw	r2,4(r2)
   22f20:	e0fffd17 	ldw	r3,-12(fp)
   22f24:	1887c83a 	sub	r3,r3,r2
   22f28:	e0bfff17 	ldw	r2,-4(fp)
   22f2c:	10800017 	ldw	r2,0(r2)
   22f30:	18800d2e 	bgeu	r3,r2,22f68 <xTaskCheckForTimeOut+0xb8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
   22f34:	e0bfff17 	ldw	r2,-4(fp)
   22f38:	10c00017 	ldw	r3,0(r2)
   22f3c:	e0bffe17 	ldw	r2,-8(fp)
   22f40:	11000117 	ldw	r4,4(r2)
   22f44:	e0bffd17 	ldw	r2,-12(fp)
   22f48:	2085c83a 	sub	r2,r4,r2
   22f4c:	1887883a 	add	r3,r3,r2
   22f50:	e0bfff17 	ldw	r2,-4(fp)
   22f54:	10c00015 	stw	r3,0(r2)
			vTaskSetTimeOutState( pxTimeOut );
   22f58:	e13ffe17 	ldw	r4,-8(fp)
   22f5c:	0022e740 	call	22e74 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
   22f60:	e03ffc15 	stw	zero,-16(fp)
   22f64:	00000206 	br	22f70 <xTaskCheckForTimeOut+0xc0>
		}
		else
		{
			xReturn = pdTRUE;
   22f68:	00800044 	movi	r2,1
   22f6c:	e0bffc15 	stw	r2,-16(fp)
		}
	}
	taskEXIT_CRITICAL();
   22f70:	00231700 	call	23170 <vTaskExitCritical>

	return xReturn;
   22f74:	e0bffc17 	ldw	r2,-16(fp)
}
   22f78:	e037883a 	mov	sp,fp
   22f7c:	dfc00117 	ldw	ra,4(sp)
   22f80:	df000017 	ldw	fp,0(sp)
   22f84:	dec00204 	addi	sp,sp,8
   22f88:	f800283a 	ret

00022f8c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   22f8c:	deffff04 	addi	sp,sp,-4
   22f90:	df000015 	stw	fp,0(sp)
   22f94:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
   22f98:	00800044 	movi	r2,1
   22f9c:	d0a02415 	stw	r2,-32624(gp)
}
   22fa0:	0001883a 	nop
   22fa4:	e037883a 	mov	sp,fp
   22fa8:	df000017 	ldw	fp,0(sp)
   22fac:	dec00104 	addi	sp,sp,4
   22fb0:	f800283a 	ret

00022fb4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   22fb4:	defffd04 	addi	sp,sp,-12
   22fb8:	dfc00215 	stw	ra,8(sp)
   22fbc:	df000115 	stw	fp,4(sp)
   22fc0:	df000104 	addi	fp,sp,4
   22fc4:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   22fc8:	00230940 	call	23094 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   22fcc:	00800134 	movhi	r2,4
   22fd0:	10a34e04 	addi	r2,r2,-29384
   22fd4:	10800017 	ldw	r2,0(r2)
   22fd8:	108000b0 	cmpltui	r2,r2,2
   22fdc:	103ffa1e 	bne	r2,zero,22fc8 <__reset+0xfff82fc8>
			{
				taskYIELD();
   22fe0:	003b683a 	trap	0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   22fe4:	003ff806 	br	22fc8 <__reset+0xfff82fc8>

00022fe8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   22fe8:	defffd04 	addi	sp,sp,-12
   22fec:	dfc00215 	stw	ra,8(sp)
   22ff0:	df000115 	stw	fp,4(sp)
   22ff4:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   22ff8:	e03fff15 	stw	zero,-4(fp)
   22ffc:	00000a06 	br	23028 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   23000:	e0bfff17 	ldw	r2,-4(fp)
   23004:	10c00524 	muli	r3,r2,20
   23008:	00800134 	movhi	r2,4
   2300c:	10a34e04 	addi	r2,r2,-29384
   23010:	1885883a 	add	r2,r3,r2
   23014:	1009883a 	mov	r4,r2
   23018:	0020ad80 	call	20ad8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2301c:	e0bfff17 	ldw	r2,-4(fp)
   23020:	10800044 	addi	r2,r2,1
   23024:	e0bfff15 	stw	r2,-4(fp)
   23028:	e0bfff17 	ldw	r2,-4(fp)
   2302c:	10800170 	cmpltui	r2,r2,5
   23030:	103ff31e 	bne	r2,zero,23000 <__reset+0xfff83000>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   23034:	01000134 	movhi	r4,4
   23038:	21236704 	addi	r4,r4,-29284
   2303c:	0020ad80 	call	20ad8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   23040:	01000134 	movhi	r4,4
   23044:	21236c04 	addi	r4,r4,-29264
   23048:	0020ad80 	call	20ad8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   2304c:	01000134 	movhi	r4,4
   23050:	21237104 	addi	r4,r4,-29244
   23054:	0020ad80 	call	20ad8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   23058:	01000134 	movhi	r4,4
   2305c:	21237604 	addi	r4,r4,-29224
   23060:	0020ad80 	call	20ad8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   23064:	00800134 	movhi	r2,4
   23068:	10a36704 	addi	r2,r2,-29284
   2306c:	d0a01d15 	stw	r2,-32652(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   23070:	00800134 	movhi	r2,4
   23074:	10a36c04 	addi	r2,r2,-29264
   23078:	d0a01e15 	stw	r2,-32648(gp)
}
   2307c:	0001883a 	nop
   23080:	e037883a 	mov	sp,fp
   23084:	dfc00117 	ldw	ra,4(sp)
   23088:	df000017 	ldw	fp,0(sp)
   2308c:	dec00204 	addi	sp,sp,8
   23090:	f800283a 	ret

00023094 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   23094:	deffff04 	addi	sp,sp,-4
   23098:	df000015 	stw	fp,0(sp)
   2309c:	d839883a 	mov	fp,sp
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   230a0:	0001883a 	nop
   230a4:	e037883a 	mov	sp,fp
   230a8:	df000017 	ldw	fp,0(sp)
   230ac:	dec00104 	addi	sp,sp,4
   230b0:	f800283a 	ret

000230b4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   230b4:	defffe04 	addi	sp,sp,-8
   230b8:	df000115 	stw	fp,4(sp)
   230bc:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   230c0:	d0a01d17 	ldw	r2,-32652(gp)
   230c4:	10800017 	ldw	r2,0(r2)
   230c8:	1000021e 	bne	r2,zero,230d4 <prvResetNextTaskUnblockTime+0x20>
   230cc:	00800044 	movi	r2,1
   230d0:	00000106 	br	230d8 <prvResetNextTaskUnblockTime+0x24>
   230d4:	0005883a 	mov	r2,zero
   230d8:	10803fcc 	andi	r2,r2,255
   230dc:	10000326 	beq	r2,zero,230ec <prvResetNextTaskUnblockTime+0x38>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   230e0:	00bfffc4 	movi	r2,-1
   230e4:	d0a02715 	stw	r2,-32612(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   230e8:	00000706 	br	23108 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   230ec:	d0a01d17 	ldw	r2,-32652(gp)
   230f0:	10800317 	ldw	r2,12(r2)
   230f4:	10800317 	ldw	r2,12(r2)
   230f8:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   230fc:	e0bfff17 	ldw	r2,-4(fp)
   23100:	10800117 	ldw	r2,4(r2)
   23104:	d0a02715 	stw	r2,-32612(gp)
	}
}
   23108:	0001883a 	nop
   2310c:	e037883a 	mov	sp,fp
   23110:	df000017 	ldw	fp,0(sp)
   23114:	dec00104 	addi	sp,sp,4
   23118:	f800283a 	ret

0002311c <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
   2311c:	defffe04 	addi	sp,sp,-8
   23120:	df000115 	stw	fp,4(sp)
   23124:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   23128:	0005303a 	rdctl	r2,status
   2312c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   23130:	e0ffff17 	ldw	r3,-4(fp)
   23134:	00bfff84 	movi	r2,-2
   23138:	1884703a 	and	r2,r3,r2
   2313c:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
   23140:	d0a02217 	ldw	r2,-32632(gp)
   23144:	10000526 	beq	r2,zero,2315c <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
   23148:	d0a01c17 	ldw	r2,-32656(gp)
   2314c:	10c00f17 	ldw	r3,60(r2)
   23150:	18c00044 	addi	r3,r3,1
   23154:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
   23158:	d0a01c17 	ldw	r2,-32656(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   2315c:	0001883a 	nop
   23160:	e037883a 	mov	sp,fp
   23164:	df000017 	ldw	fp,0(sp)
   23168:	dec00104 	addi	sp,sp,4
   2316c:	f800283a 	ret

00023170 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
   23170:	defffe04 	addi	sp,sp,-8
   23174:	df000115 	stw	fp,4(sp)
   23178:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
   2317c:	d0a02217 	ldw	r2,-32632(gp)
   23180:	10000e26 	beq	r2,zero,231bc <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
   23184:	d0a01c17 	ldw	r2,-32656(gp)
   23188:	10800f17 	ldw	r2,60(r2)
   2318c:	10000b26 	beq	r2,zero,231bc <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
   23190:	d0a01c17 	ldw	r2,-32656(gp)
   23194:	10c00f17 	ldw	r3,60(r2)
   23198:	18ffffc4 	addi	r3,r3,-1
   2319c:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
   231a0:	d0a01c17 	ldw	r2,-32656(gp)
   231a4:	10800f17 	ldw	r2,60(r2)
   231a8:	1000041e 	bne	r2,zero,231bc <vTaskExitCritical+0x4c>
   231ac:	00800044 	movi	r2,1
   231b0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   231b4:	e0bfff17 	ldw	r2,-4(fp)
   231b8:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   231bc:	0001883a 	nop
   231c0:	e037883a 	mov	sp,fp
   231c4:	df000017 	ldw	fp,0(sp)
   231c8:	dec00104 	addi	sp,sp,4
   231cc:	f800283a 	ret

000231d0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
   231d0:	defffe04 	addi	sp,sp,-8
   231d4:	df000115 	stw	fp,4(sp)
   231d8:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   231dc:	d0a01c17 	ldw	r2,-32656(gp)
   231e0:	10800617 	ldw	r2,24(r2)
   231e4:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   231e8:	d0a01c17 	ldw	r2,-32656(gp)
   231ec:	d0e01c17 	ldw	r3,-32656(gp)
   231f0:	18c00b17 	ldw	r3,44(r3)
   231f4:	01000144 	movi	r4,5
   231f8:	20c7c83a 	sub	r3,r4,r3
   231fc:	10c00615 	stw	r3,24(r2)

	return uxReturn;
   23200:	e0bfff17 	ldw	r2,-4(fp)
}
   23204:	e037883a 	mov	sp,fp
   23208:	df000017 	ldw	fp,0(sp)
   2320c:	dec00104 	addi	sp,sp,4
   23210:	f800283a 	ret

00023214 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
   23214:	defffb04 	addi	sp,sp,-20
   23218:	dfc00415 	stw	ra,16(sp)
   2321c:	df000315 	stw	fp,12(sp)
   23220:	df000304 	addi	fp,sp,12
   23224:	e13ffe15 	stw	r4,-8(fp)
   23228:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
   2322c:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   23230:	d0a01c17 	ldw	r2,-32656(gp)
   23234:	10801017 	ldw	r2,64(r2)
   23238:	1000091e 	bne	r2,zero,23260 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   2323c:	d0a01c17 	ldw	r2,-32656(gp)
   23240:	00c00044 	movi	r3,1
   23244:	10c01105 	stb	r3,68(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
   23248:	e0bfff17 	ldw	r2,-4(fp)
   2324c:	10000426 	beq	r2,zero,23260 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   23250:	01400044 	movi	r5,1
   23254:	e13fff17 	ldw	r4,-4(fp)
   23258:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   2325c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   23260:	00231700 	call	23170 <vTaskExitCritical>

		taskENTER_CRITICAL();
   23264:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
   23268:	d0a01c17 	ldw	r2,-32656(gp)
   2326c:	10801017 	ldw	r2,64(r2)
   23270:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
   23274:	e0bffd17 	ldw	r2,-12(fp)
   23278:	10000926 	beq	r2,zero,232a0 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
   2327c:	e0bffe17 	ldw	r2,-8(fp)
   23280:	10000326 	beq	r2,zero,23290 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
   23284:	d0a01c17 	ldw	r2,-32656(gp)
   23288:	10001015 	stw	zero,64(r2)
   2328c:	00000406 	br	232a0 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
   23290:	d0a01c17 	ldw	r2,-32656(gp)
   23294:	e0fffd17 	ldw	r3,-12(fp)
   23298:	18ffffc4 	addi	r3,r3,-1
   2329c:	10c01015 	stw	r3,64(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   232a0:	d0a01c17 	ldw	r2,-32656(gp)
   232a4:	10001105 	stb	zero,68(r2)
		}
		taskEXIT_CRITICAL();
   232a8:	00231700 	call	23170 <vTaskExitCritical>

		return ulReturn;
   232ac:	e0bffd17 	ldw	r2,-12(fp)
	}
   232b0:	e037883a 	mov	sp,fp
   232b4:	dfc00117 	ldw	ra,4(sp)
   232b8:	df000017 	ldw	fp,0(sp)
   232bc:	dec00204 	addi	sp,sp,8
   232c0:	f800283a 	ret

000232c4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
   232c4:	defff904 	addi	sp,sp,-28
   232c8:	dfc00615 	stw	ra,24(sp)
   232cc:	df000515 	stw	fp,20(sp)
   232d0:	df000504 	addi	fp,sp,20
   232d4:	e13ffc15 	stw	r4,-16(fp)
   232d8:	e17ffd15 	stw	r5,-12(fp)
   232dc:	e1bffe15 	stw	r6,-8(fp)
   232e0:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
   232e4:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   232e8:	d0a01c17 	ldw	r2,-32656(gp)
   232ec:	10801103 	ldbu	r2,68(r2)
   232f0:	10803fcc 	andi	r2,r2,255
   232f4:	108000a0 	cmpeqi	r2,r2,2
   232f8:	10000f1e 	bne	r2,zero,23338 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   232fc:	d0a01c17 	ldw	r2,-32656(gp)
   23300:	11001017 	ldw	r4,64(r2)
   23304:	e0fffc17 	ldw	r3,-16(fp)
   23308:	00c6303a 	nor	r3,zero,r3
   2330c:	20c6703a 	and	r3,r4,r3
   23310:	10c01015 	stw	r3,64(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   23314:	d0a01c17 	ldw	r2,-32656(gp)
   23318:	00c00044 	movi	r3,1
   2331c:	10c01105 	stb	r3,68(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
   23320:	e0bfff17 	ldw	r2,-4(fp)
   23324:	10000426 	beq	r2,zero,23338 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   23328:	01400044 	movi	r5,1
   2332c:	e13fff17 	ldw	r4,-4(fp)
   23330:	00238d80 	call	238d8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
   23334:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   23338:	00231700 	call	23170 <vTaskExitCritical>

		taskENTER_CRITICAL();
   2333c:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
   23340:	e0bffe17 	ldw	r2,-8(fp)
   23344:	10000426 	beq	r2,zero,23358 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   23348:	d0a01c17 	ldw	r2,-32656(gp)
   2334c:	10c01017 	ldw	r3,64(r2)
   23350:	e0bffe17 	ldw	r2,-8(fp)
   23354:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   23358:	d0a01c17 	ldw	r2,-32656(gp)
   2335c:	10801103 	ldbu	r2,68(r2)
   23360:	10803fcc 	andi	r2,r2,255
   23364:	10800058 	cmpnei	r2,r2,1
   23368:	1000021e 	bne	r2,zero,23374 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
   2336c:	e03ffb15 	stw	zero,-20(fp)
   23370:	00000806 	br	23394 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   23374:	d0a01c17 	ldw	r2,-32656(gp)
   23378:	11001017 	ldw	r4,64(r2)
   2337c:	e0fffd17 	ldw	r3,-12(fp)
   23380:	00c6303a 	nor	r3,zero,r3
   23384:	20c6703a 	and	r3,r4,r3
   23388:	10c01015 	stw	r3,64(r2)
				xReturn = pdTRUE;
   2338c:	00800044 	movi	r2,1
   23390:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   23394:	d0a01c17 	ldw	r2,-32656(gp)
   23398:	10001105 	stb	zero,68(r2)
		}
		taskEXIT_CRITICAL();
   2339c:	00231700 	call	23170 <vTaskExitCritical>

		return xReturn;
   233a0:	e0bffb17 	ldw	r2,-20(fp)
	}
   233a4:	e037883a 	mov	sp,fp
   233a8:	dfc00117 	ldw	ra,4(sp)
   233ac:	df000017 	ldw	fp,0(sp)
   233b0:	dec00204 	addi	sp,sp,8
   233b4:	f800283a 	ret

000233b8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
   233b8:	defff704 	addi	sp,sp,-36
   233bc:	dfc00815 	stw	ra,32(sp)
   233c0:	df000715 	stw	fp,28(sp)
   233c4:	df000704 	addi	fp,sp,28
   233c8:	e13ffc15 	stw	r4,-16(fp)
   233cc:	e17ffd15 	stw	r5,-12(fp)
   233d0:	e1bffe15 	stw	r6,-8(fp)
   233d4:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
   233d8:	00800044 	movi	r2,1
   233dc:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
   233e0:	e0bffc17 	ldw	r2,-16(fp)
   233e4:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
   233e8:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
   233ec:	e0bfff17 	ldw	r2,-4(fp)
   233f0:	10000426 	beq	r2,zero,23404 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   233f4:	e0bffa17 	ldw	r2,-24(fp)
   233f8:	10c01017 	ldw	r3,64(r2)
   233fc:	e0bfff17 	ldw	r2,-4(fp)
   23400:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   23404:	e0bffa17 	ldw	r2,-24(fp)
   23408:	10801103 	ldbu	r2,68(r2)
   2340c:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   23410:	e0bffa17 	ldw	r2,-24(fp)
   23414:	00c00084 	movi	r3,2
   23418:	10c01105 	stb	r3,68(r2)

			switch( eAction )
   2341c:	e0bffe17 	ldw	r2,-8(fp)
   23420:	10800168 	cmpgeui	r2,r2,5
   23424:	1000271e 	bne	r2,zero,234c4 <xTaskGenericNotify+0x10c>
   23428:	e0bffe17 	ldw	r2,-8(fp)
   2342c:	100690ba 	slli	r3,r2,2
   23430:	008000b4 	movhi	r2,2
   23434:	108d1104 	addi	r2,r2,13380
   23438:	1885883a 	add	r2,r3,r2
   2343c:	10800017 	ldw	r2,0(r2)
   23440:	1000683a 	jmp	r2
   23444:	000234c0 	call	234c <__alt_mem_onchip_memory2_nios2-0x1dcb4>
   23448:	00023458 	cmpnei	zero,zero,2257
   2344c:	00023474 	movhi	zero,2257
   23450:	0002348c 	andi	zero,zero,2258
   23454:	0002349c 	xori	zero,zero,2258
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   23458:	e0bffa17 	ldw	r2,-24(fp)
   2345c:	10c01017 	ldw	r3,64(r2)
   23460:	e0bffd17 	ldw	r2,-12(fp)
   23464:	1886b03a 	or	r3,r3,r2
   23468:	e0bffa17 	ldw	r2,-24(fp)
   2346c:	10c01015 	stw	r3,64(r2)
					break;
   23470:	00001406 	br	234c4 <xTaskGenericNotify+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   23474:	e0bffa17 	ldw	r2,-24(fp)
   23478:	10801017 	ldw	r2,64(r2)
   2347c:	10c00044 	addi	r3,r2,1
   23480:	e0bffa17 	ldw	r2,-24(fp)
   23484:	10c01015 	stw	r3,64(r2)
					break;
   23488:	00000e06 	br	234c4 <xTaskGenericNotify+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   2348c:	e0bffa17 	ldw	r2,-24(fp)
   23490:	e0fffd17 	ldw	r3,-12(fp)
   23494:	10c01015 	stw	r3,64(r2)
					break;
   23498:	00000a06 	br	234c4 <xTaskGenericNotify+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   2349c:	e0bffb03 	ldbu	r2,-20(fp)
   234a0:	108000a0 	cmpeqi	r2,r2,2
   234a4:	1000041e 	bne	r2,zero,234b8 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
   234a8:	e0bffa17 	ldw	r2,-24(fp)
   234ac:	e0fffd17 	ldw	r3,-12(fp)
   234b0:	10c01015 	stw	r3,64(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   234b4:	00000306 	br	234c4 <xTaskGenericNotify+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   234b8:	e03ff915 	stw	zero,-28(fp)
					}
					break;
   234bc:	00000106 	br	234c4 <xTaskGenericNotify+0x10c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
   234c0:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   234c4:	e0bffb03 	ldbu	r2,-20(fp)
   234c8:	10800058 	cmpnei	r2,r2,1
   234cc:	10001c1e 	bne	r2,zero,23540 <xTaskGenericNotify+0x188>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   234d0:	e0bffa17 	ldw	r2,-24(fp)
   234d4:	10800104 	addi	r2,r2,4
   234d8:	1009883a 	mov	r4,r2
   234dc:	0020cd00 	call	20cd0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
   234e0:	e0bffa17 	ldw	r2,-24(fp)
   234e4:	10800b17 	ldw	r2,44(r2)
   234e8:	d0e02117 	ldw	r3,-32636(gp)
   234ec:	1880032e 	bgeu	r3,r2,234fc <xTaskGenericNotify+0x144>
   234f0:	e0bffa17 	ldw	r2,-24(fp)
   234f4:	10800b17 	ldw	r2,44(r2)
   234f8:	d0a02115 	stw	r2,-32636(gp)
   234fc:	e0bffa17 	ldw	r2,-24(fp)
   23500:	10800b17 	ldw	r2,44(r2)
   23504:	10c00524 	muli	r3,r2,20
   23508:	00800134 	movhi	r2,4
   2350c:	10a34e04 	addi	r2,r2,-29384
   23510:	1887883a 	add	r3,r3,r2
   23514:	e0bffa17 	ldw	r2,-24(fp)
   23518:	10800104 	addi	r2,r2,4
   2351c:	100b883a 	mov	r5,r2
   23520:	1809883a 	mov	r4,r3
   23524:	0020b6c0 	call	20b6c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   23528:	e0bffa17 	ldw	r2,-24(fp)
   2352c:	10800b17 	ldw	r2,44(r2)
   23530:	d0e01c17 	ldw	r3,-32656(gp)
   23534:	18c00b17 	ldw	r3,44(r3)
   23538:	1880012e 	bgeu	r3,r2,23540 <xTaskGenericNotify+0x188>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
   2353c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   23540:	00231700 	call	23170 <vTaskExitCritical>

		return xReturn;
   23544:	e0bff917 	ldw	r2,-28(fp)
	}
   23548:	e037883a 	mov	sp,fp
   2354c:	dfc00117 	ldw	ra,4(sp)
   23550:	df000017 	ldw	fp,0(sp)
   23554:	dec00204 	addi	sp,sp,8
   23558:	f800283a 	ret

0002355c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
   2355c:	defff604 	addi	sp,sp,-40
   23560:	dfc00915 	stw	ra,36(sp)
   23564:	df000815 	stw	fp,32(sp)
   23568:	df000804 	addi	fp,sp,32
   2356c:	e13ffc15 	stw	r4,-16(fp)
   23570:	e17ffd15 	stw	r5,-12(fp)
   23574:	e1bffe15 	stw	r6,-8(fp)
   23578:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
   2357c:	00800044 	movi	r2,1
   23580:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
   23584:	e0bffc17 	ldw	r2,-16(fp)
   23588:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   2358c:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
   23590:	e0bfff17 	ldw	r2,-4(fp)
   23594:	10000426 	beq	r2,zero,235a8 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   23598:	e0bff917 	ldw	r2,-28(fp)
   2359c:	10c01017 	ldw	r3,64(r2)
   235a0:	e0bfff17 	ldw	r2,-4(fp)
   235a4:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   235a8:	e0bff917 	ldw	r2,-28(fp)
   235ac:	10801103 	ldbu	r2,68(r2)
   235b0:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   235b4:	e0bff917 	ldw	r2,-28(fp)
   235b8:	00c00084 	movi	r3,2
   235bc:	10c01105 	stb	r3,68(r2)

			switch( eAction )
   235c0:	e0bffe17 	ldw	r2,-8(fp)
   235c4:	10800168 	cmpgeui	r2,r2,5
   235c8:	1000271e 	bne	r2,zero,23668 <xTaskGenericNotifyFromISR+0x10c>
   235cc:	e0bffe17 	ldw	r2,-8(fp)
   235d0:	100690ba 	slli	r3,r2,2
   235d4:	008000b4 	movhi	r2,2
   235d8:	108d7a04 	addi	r2,r2,13800
   235dc:	1885883a 	add	r2,r3,r2
   235e0:	10800017 	ldw	r2,0(r2)
   235e4:	1000683a 	jmp	r2
   235e8:	00023664 	muli	zero,zero,2265
   235ec:	000235fc 	xorhi	zero,zero,2263
   235f0:	00023618 	cmpnei	zero,zero,2264
   235f4:	00023630 	cmpltui	zero,zero,2264
   235f8:	00023640 	call	2364 <__alt_mem_onchip_memory2_nios2-0x1dc9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   235fc:	e0bff917 	ldw	r2,-28(fp)
   23600:	10c01017 	ldw	r3,64(r2)
   23604:	e0bffd17 	ldw	r2,-12(fp)
   23608:	1886b03a 	or	r3,r3,r2
   2360c:	e0bff917 	ldw	r2,-28(fp)
   23610:	10c01015 	stw	r3,64(r2)
					break;
   23614:	00001406 	br	23668 <xTaskGenericNotifyFromISR+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   23618:	e0bff917 	ldw	r2,-28(fp)
   2361c:	10801017 	ldw	r2,64(r2)
   23620:	10c00044 	addi	r3,r2,1
   23624:	e0bff917 	ldw	r2,-28(fp)
   23628:	10c01015 	stw	r3,64(r2)
					break;
   2362c:	00000e06 	br	23668 <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   23630:	e0bff917 	ldw	r2,-28(fp)
   23634:	e0fffd17 	ldw	r3,-12(fp)
   23638:	10c01015 	stw	r3,64(r2)
					break;
   2363c:	00000a06 	br	23668 <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   23640:	e0bffb03 	ldbu	r2,-20(fp)
   23644:	108000a0 	cmpeqi	r2,r2,2
   23648:	1000041e 	bne	r2,zero,2365c <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
   2364c:	e0bff917 	ldw	r2,-28(fp)
   23650:	e0fffd17 	ldw	r3,-12(fp)
   23654:	10c01015 	stw	r3,64(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   23658:	00000306 	br	23668 <xTaskGenericNotifyFromISR+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
   2365c:	e03ff815 	stw	zero,-32(fp)
					}
					break;
   23660:	00000106 	br	23668 <xTaskGenericNotifyFromISR+0x10c>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
   23664:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   23668:	e0bffb03 	ldbu	r2,-20(fp)
   2366c:	10800058 	cmpnei	r2,r2,1
   23670:	10002c1e 	bne	r2,zero,23724 <xTaskGenericNotifyFromISR+0x1c8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   23674:	d0a02917 	ldw	r2,-32604(gp)
   23678:	1000171e 	bne	r2,zero,236d8 <xTaskGenericNotifyFromISR+0x17c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2367c:	e0bff917 	ldw	r2,-28(fp)
   23680:	10800104 	addi	r2,r2,4
   23684:	1009883a 	mov	r4,r2
   23688:	0020cd00 	call	20cd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   2368c:	e0bff917 	ldw	r2,-28(fp)
   23690:	10800b17 	ldw	r2,44(r2)
   23694:	d0e02117 	ldw	r3,-32636(gp)
   23698:	1880032e 	bgeu	r3,r2,236a8 <xTaskGenericNotifyFromISR+0x14c>
   2369c:	e0bff917 	ldw	r2,-28(fp)
   236a0:	10800b17 	ldw	r2,44(r2)
   236a4:	d0a02115 	stw	r2,-32636(gp)
   236a8:	e0bff917 	ldw	r2,-28(fp)
   236ac:	10800b17 	ldw	r2,44(r2)
   236b0:	10c00524 	muli	r3,r2,20
   236b4:	00800134 	movhi	r2,4
   236b8:	10a34e04 	addi	r2,r2,-29384
   236bc:	1887883a 	add	r3,r3,r2
   236c0:	e0bff917 	ldw	r2,-28(fp)
   236c4:	10800104 	addi	r2,r2,4
   236c8:	100b883a 	mov	r5,r2
   236cc:	1809883a 	mov	r4,r3
   236d0:	0020b6c0 	call	20b6c <vListInsertEnd>
   236d4:	00000606 	br	236f0 <xTaskGenericNotifyFromISR+0x194>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   236d8:	e0bff917 	ldw	r2,-28(fp)
   236dc:	10800604 	addi	r2,r2,24
   236e0:	100b883a 	mov	r5,r2
   236e4:	01000134 	movhi	r4,4
   236e8:	21237104 	addi	r4,r4,-29244
   236ec:	0020b6c0 	call	20b6c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   236f0:	e0bff917 	ldw	r2,-28(fp)
   236f4:	10800b17 	ldw	r2,44(r2)
   236f8:	d0e01c17 	ldw	r3,-32656(gp)
   236fc:	18c00b17 	ldw	r3,44(r3)
   23700:	1880082e 	bgeu	r3,r2,23724 <xTaskGenericNotifyFromISR+0x1c8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   23704:	e0800217 	ldw	r2,8(fp)
   23708:	10000426 	beq	r2,zero,2371c <xTaskGenericNotifyFromISR+0x1c0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   2370c:	e0800217 	ldw	r2,8(fp)
   23710:	00c00044 	movi	r3,1
   23714:	10c00015 	stw	r3,0(r2)
   23718:	00000206 	br	23724 <xTaskGenericNotifyFromISR+0x1c8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
   2371c:	00800044 	movi	r2,1
   23720:	d0a02415 	stw	r2,-32624(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
   23724:	e0bff817 	ldw	r2,-32(fp)
	}
   23728:	e037883a 	mov	sp,fp
   2372c:	dfc00117 	ldw	ra,4(sp)
   23730:	df000017 	ldw	fp,0(sp)
   23734:	dec00204 	addi	sp,sp,8
   23738:	f800283a 	ret

0002373c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
   2373c:	defff904 	addi	sp,sp,-28
   23740:	dfc00615 	stw	ra,24(sp)
   23744:	df000515 	stw	fp,20(sp)
   23748:	df000504 	addi	fp,sp,20
   2374c:	e13ffe15 	stw	r4,-8(fp)
   23750:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
   23754:	e0bffe17 	ldw	r2,-8(fp)
   23758:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   2375c:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
   23760:	e0bffb17 	ldw	r2,-20(fp)
   23764:	10801103 	ldbu	r2,68(r2)
   23768:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   2376c:	e0bffb17 	ldw	r2,-20(fp)
   23770:	00c00084 	movi	r3,2
   23774:	10c01105 	stb	r3,68(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
   23778:	e0bffb17 	ldw	r2,-20(fp)
   2377c:	10801017 	ldw	r2,64(r2)
   23780:	10c00044 	addi	r3,r2,1
   23784:	e0bffb17 	ldw	r2,-20(fp)
   23788:	10c01015 	stw	r3,64(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   2378c:	e0bffd03 	ldbu	r2,-12(fp)
   23790:	10800058 	cmpnei	r2,r2,1
   23794:	10002c1e 	bne	r2,zero,23848 <vTaskNotifyGiveFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   23798:	d0a02917 	ldw	r2,-32604(gp)
   2379c:	1000171e 	bne	r2,zero,237fc <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   237a0:	e0bffb17 	ldw	r2,-20(fp)
   237a4:	10800104 	addi	r2,r2,4
   237a8:	1009883a 	mov	r4,r2
   237ac:	0020cd00 	call	20cd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   237b0:	e0bffb17 	ldw	r2,-20(fp)
   237b4:	10800b17 	ldw	r2,44(r2)
   237b8:	d0e02117 	ldw	r3,-32636(gp)
   237bc:	1880032e 	bgeu	r3,r2,237cc <vTaskNotifyGiveFromISR+0x90>
   237c0:	e0bffb17 	ldw	r2,-20(fp)
   237c4:	10800b17 	ldw	r2,44(r2)
   237c8:	d0a02115 	stw	r2,-32636(gp)
   237cc:	e0bffb17 	ldw	r2,-20(fp)
   237d0:	10800b17 	ldw	r2,44(r2)
   237d4:	10c00524 	muli	r3,r2,20
   237d8:	00800134 	movhi	r2,4
   237dc:	10a34e04 	addi	r2,r2,-29384
   237e0:	1887883a 	add	r3,r3,r2
   237e4:	e0bffb17 	ldw	r2,-20(fp)
   237e8:	10800104 	addi	r2,r2,4
   237ec:	100b883a 	mov	r5,r2
   237f0:	1809883a 	mov	r4,r3
   237f4:	0020b6c0 	call	20b6c <vListInsertEnd>
   237f8:	00000606 	br	23814 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   237fc:	e0bffb17 	ldw	r2,-20(fp)
   23800:	10800604 	addi	r2,r2,24
   23804:	100b883a 	mov	r5,r2
   23808:	01000134 	movhi	r4,4
   2380c:	21237104 	addi	r4,r4,-29244
   23810:	0020b6c0 	call	20b6c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   23814:	e0bffb17 	ldw	r2,-20(fp)
   23818:	10800b17 	ldw	r2,44(r2)
   2381c:	d0e01c17 	ldw	r3,-32656(gp)
   23820:	18c00b17 	ldw	r3,44(r3)
   23824:	1880082e 	bgeu	r3,r2,23848 <vTaskNotifyGiveFromISR+0x10c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   23828:	e0bfff17 	ldw	r2,-4(fp)
   2382c:	10000426 	beq	r2,zero,23840 <vTaskNotifyGiveFromISR+0x104>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   23830:	e0bfff17 	ldw	r2,-4(fp)
   23834:	00c00044 	movi	r3,1
   23838:	10c00015 	stw	r3,0(r2)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
   2383c:	00000206 	br	23848 <vTaskNotifyGiveFromISR+0x10c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
   23840:	00800044 	movi	r2,1
   23844:	d0a02415 	stw	r2,-32624(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
   23848:	0001883a 	nop
   2384c:	e037883a 	mov	sp,fp
   23850:	dfc00117 	ldw	ra,4(sp)
   23854:	df000017 	ldw	fp,0(sp)
   23858:	dec00204 	addi	sp,sp,8
   2385c:	f800283a 	ret

00023860 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
   23860:	defffb04 	addi	sp,sp,-20
   23864:	dfc00415 	stw	ra,16(sp)
   23868:	df000315 	stw	fp,12(sp)
   2386c:	df000304 	addi	fp,sp,12
   23870:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
   23874:	e0bfff17 	ldw	r2,-4(fp)
   23878:	1000021e 	bne	r2,zero,23884 <xTaskNotifyStateClear+0x24>
   2387c:	d0a01c17 	ldw	r2,-32656(gp)
   23880:	00000106 	br	23888 <xTaskNotifyStateClear+0x28>
   23884:	e0bfff17 	ldw	r2,-4(fp)
   23888:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
   2388c:	002311c0 	call	2311c <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   23890:	e0bffe17 	ldw	r2,-8(fp)
   23894:	10801103 	ldbu	r2,68(r2)
   23898:	10803fcc 	andi	r2,r2,255
   2389c:	10800098 	cmpnei	r2,r2,2
   238a0:	1000051e 	bne	r2,zero,238b8 <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   238a4:	e0bffe17 	ldw	r2,-8(fp)
   238a8:	10001105 	stb	zero,68(r2)
				xReturn = pdPASS;
   238ac:	00800044 	movi	r2,1
   238b0:	e0bffd15 	stw	r2,-12(fp)
   238b4:	00000106 	br	238bc <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
   238b8:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
   238bc:	00231700 	call	23170 <vTaskExitCritical>

		return xReturn;
   238c0:	e0bffd17 	ldw	r2,-12(fp)
	}
   238c4:	e037883a 	mov	sp,fp
   238c8:	dfc00117 	ldw	ra,4(sp)
   238cc:	df000017 	ldw	fp,0(sp)
   238d0:	dec00204 	addi	sp,sp,8
   238d4:	f800283a 	ret

000238d8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   238d8:	defffa04 	addi	sp,sp,-24
   238dc:	dfc00515 	stw	ra,20(sp)
   238e0:	df000415 	stw	fp,16(sp)
   238e4:	df000404 	addi	fp,sp,16
   238e8:	e13ffe15 	stw	r4,-8(fp)
   238ec:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   238f0:	d0a02017 	ldw	r2,-32640(gp)
   238f4:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   238f8:	d0a01c17 	ldw	r2,-32656(gp)
   238fc:	10800104 	addi	r2,r2,4
   23900:	1009883a 	mov	r4,r2
   23904:	0020cd00 	call	20cd0 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   23908:	e0bffe17 	ldw	r2,-8(fp)
   2390c:	10bfffd8 	cmpnei	r2,r2,-1
   23910:	1000091e 	bne	r2,zero,23938 <prvAddCurrentTaskToDelayedList+0x60>
   23914:	e0bfff17 	ldw	r2,-4(fp)
   23918:	10000726 	beq	r2,zero,23938 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   2391c:	d0a01c17 	ldw	r2,-32656(gp)
   23920:	10800104 	addi	r2,r2,4
   23924:	100b883a 	mov	r5,r2
   23928:	01000134 	movhi	r4,4
   2392c:	21237604 	addi	r4,r4,-29224
   23930:	0020b6c0 	call	20b6c <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   23934:	00001c06 	br	239a8 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   23938:	e0fffc17 	ldw	r3,-16(fp)
   2393c:	e0bffe17 	ldw	r2,-8(fp)
   23940:	1885883a 	add	r2,r3,r2
   23944:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   23948:	d0a01c17 	ldw	r2,-32656(gp)
   2394c:	e0fffd17 	ldw	r3,-12(fp)
   23950:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
   23954:	e0fffd17 	ldw	r3,-12(fp)
   23958:	e0bffc17 	ldw	r2,-16(fp)
   2395c:	1880072e 	bgeu	r3,r2,2397c <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   23960:	d0e01e17 	ldw	r3,-32648(gp)
   23964:	d0a01c17 	ldw	r2,-32656(gp)
   23968:	10800104 	addi	r2,r2,4
   2396c:	100b883a 	mov	r5,r2
   23970:	1809883a 	mov	r4,r3
   23974:	0020bf80 	call	20bf8 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   23978:	00000b06 	br	239a8 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   2397c:	d0e01d17 	ldw	r3,-32652(gp)
   23980:	d0a01c17 	ldw	r2,-32656(gp)
   23984:	10800104 	addi	r2,r2,4
   23988:	100b883a 	mov	r5,r2
   2398c:	1809883a 	mov	r4,r3
   23990:	0020bf80 	call	20bf8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   23994:	d0a02717 	ldw	r2,-32612(gp)
   23998:	e0fffd17 	ldw	r3,-12(fp)
   2399c:	1880022e 	bgeu	r3,r2,239a8 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
   239a0:	e0bffd17 	ldw	r2,-12(fp)
   239a4:	d0a02715 	stw	r2,-32612(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   239a8:	0001883a 	nop
   239ac:	e037883a 	mov	sp,fp
   239b0:	dfc00117 	ldw	ra,4(sp)
   239b4:	df000017 	ldw	fp,0(sp)
   239b8:	dec00204 	addi	sp,sp,8
   239bc:	f800283a 	ret

000239c0 <_ZN20Alf_SharedMemoryComm4InitEmmmmmmtm>:

using namespace std;


bool Alf_SharedMemoryComm::Init(uint32_t sh_mem_wr_addr, uint32_t wr_mut_addr, uint32_t wr_mb_addr, uint32_t sh_mem_rd_addr,
									 uint32_t rd_mut_addr, uint32_t rd_mb_addr, uint16_t cp_id, uint32_t addr_offset){
   239c0:	defff804 	addi	sp,sp,-32
   239c4:	dfc00715 	stw	ra,28(sp)
   239c8:	df000615 	stw	fp,24(sp)
   239cc:	df000604 	addi	fp,sp,24
   239d0:	e13ffb15 	stw	r4,-20(fp)
   239d4:	e17ffc15 	stw	r5,-16(fp)
   239d8:	e1bffd15 	stw	r6,-12(fp)
   239dc:	e1fffe15 	stw	r7,-8(fp)
   239e0:	e0800517 	ldw	r2,20(fp)
   239e4:	e0bfff0d 	sth	r2,-4(fp)
	bool write_mapped = false, read_mapped = false;
   239e8:	e03ffa05 	stb	zero,-24(fp)
   239ec:	e03ffa45 	stb	zero,-23(fp)

	_cpu_id = cp_id;
   239f0:	e0bffb17 	ldw	r2,-20(fp)
   239f4:	e0ffff0b 	ldhu	r3,-4(fp)
   239f8:	10c00c0d 	sth	r3,48(r2)

	_shared_memory_wr_addr = sh_mem_wr_addr + addr_offset;
   239fc:	e0fffc17 	ldw	r3,-16(fp)
   23a00:	e0800617 	ldw	r2,24(fp)
   23a04:	1887883a 	add	r3,r3,r2
   23a08:	e0bffb17 	ldw	r2,-20(fp)
   23a0c:	10c00015 	stw	r3,0(r2)
	_wr_mutex_addr = wr_mut_addr + addr_offset;
   23a10:	e0fffd17 	ldw	r3,-12(fp)
   23a14:	e0800617 	ldw	r2,24(fp)
   23a18:	1887883a 	add	r3,r3,r2
   23a1c:	e0bffb17 	ldw	r2,-20(fp)
   23a20:	10c00215 	stw	r3,8(r2)
	_wr_mailbox_addr = wr_mb_addr + addr_offset;
   23a24:	e0fffe17 	ldw	r3,-8(fp)
   23a28:	e0800617 	ldw	r2,24(fp)
   23a2c:	1887883a 	add	r3,r3,r2
   23a30:	e0bffb17 	ldw	r2,-20(fp)
   23a34:	10c00415 	stw	r3,16(r2)

	_shared_memory_rd_addr = sh_mem_rd_addr + addr_offset;
   23a38:	e0c00217 	ldw	r3,8(fp)
   23a3c:	e0800617 	ldw	r2,24(fp)
   23a40:	1887883a 	add	r3,r3,r2
   23a44:	e0bffb17 	ldw	r2,-20(fp)
   23a48:	10c00615 	stw	r3,24(r2)
	_rd_mutex_addr = rd_mut_addr + addr_offset;
   23a4c:	e0c00317 	ldw	r3,12(fp)
   23a50:	e0800617 	ldw	r2,24(fp)
   23a54:	1887883a 	add	r3,r3,r2
   23a58:	e0bffb17 	ldw	r2,-20(fp)
   23a5c:	10c00815 	stw	r3,32(r2)
	_rd_mailbox_addr = rd_mb_addr + addr_offset;
   23a60:	e0c00417 	ldw	r3,16(fp)
   23a64:	e0800617 	ldw	r2,24(fp)
   23a68:	1887883a 	add	r3,r3,r2
   23a6c:	e0bffb17 	ldw	r2,-20(fp)
   23a70:	10c00a15 	stw	r3,40(r2)
	_wr_memory_addr_offset = addr_offset;
   23a74:	e0bffb17 	ldw	r2,-20(fp)
   23a78:	e0c00617 	ldw	r3,24(fp)
   23a7c:	10c00e15 	stw	r3,56(r2)
	}
	close(fd);
	WriteInterfaceStatus = true;

#else
	_shared_memory_wr = (void*)_shared_memory_wr_addr;
   23a80:	e0bffb17 	ldw	r2,-20(fp)
   23a84:	10800017 	ldw	r2,0(r2)
   23a88:	1007883a 	mov	r3,r2
   23a8c:	e0bffb17 	ldw	r2,-20(fp)
   23a90:	10c00115 	stw	r3,4(r2)
	_shared_memory_rd = (void*)_shared_memory_rd_addr;
   23a94:	e0bffb17 	ldw	r2,-20(fp)
   23a98:	10800617 	ldw	r2,24(r2)
   23a9c:	1007883a 	mov	r3,r2
   23aa0:	e0bffb17 	ldw	r2,-20(fp)
   23aa4:	10c00715 	stw	r3,28(r2)
	_wr_mutex = (void*)_wr_mutex_addr;
   23aa8:	e0bffb17 	ldw	r2,-20(fp)
   23aac:	10800217 	ldw	r2,8(r2)
   23ab0:	1007883a 	mov	r3,r2
   23ab4:	e0bffb17 	ldw	r2,-20(fp)
   23ab8:	10c00315 	stw	r3,12(r2)
	_rd_mutex = (void*)_rd_mutex_addr;
   23abc:	e0bffb17 	ldw	r2,-20(fp)
   23ac0:	10800817 	ldw	r2,32(r2)
   23ac4:	1007883a 	mov	r3,r2
   23ac8:	e0bffb17 	ldw	r2,-20(fp)
   23acc:	10c00915 	stw	r3,36(r2)
	_wr_mailbox = (void*)_wr_mailbox_addr;
   23ad0:	e0bffb17 	ldw	r2,-20(fp)
   23ad4:	10800417 	ldw	r2,16(r2)
   23ad8:	1007883a 	mov	r3,r2
   23adc:	e0bffb17 	ldw	r2,-20(fp)
   23ae0:	10c00515 	stw	r3,20(r2)
	_rd_mailbox = (void*)_rd_mailbox_addr;
   23ae4:	e0bffb17 	ldw	r2,-20(fp)
   23ae8:	10800a17 	ldw	r2,40(r2)
   23aec:	1007883a 	mov	r3,r2
   23af0:	e0bffb17 	ldw	r2,-20(fp)
   23af4:	10c00b15 	stw	r3,44(r2)
	_wr_memory_pos = 0;
   23af8:	e0bffb17 	ldw	r2,-20(fp)
   23afc:	10000d0d 	sth	zero,52(r2)
	ResetWriteMutex();
   23b00:	e13ffb17 	ldw	r4,-20(fp)
   23b04:	0023e3c0 	call	23e3c <_ZN20Alf_SharedMemoryComm15ResetWriteMutexEv>
	DisableMailboxInterrupt();
   23b08:	e13ffb17 	ldw	r4,-20(fp)
   23b0c:	0023bfc0 	call	23bfc <_ZN20Alf_SharedMemoryComm23DisableMailboxInterruptEv>
	write_mapped = true;
   23b10:	00800044 	movi	r2,1
   23b14:	e0bffa05 	stb	r2,-24(fp)
	read_mapped = true;
   23b18:	00800044 	movi	r2,1
   23b1c:	e0bffa45 	stb	r2,-23(fp)
	WriteInterfaceStatus = false;	//must be disabled by default. Reason: The NIOS must wait until the first message from linux was received, otherwise it will hang up!
   23b20:	e0bffb17 	ldw	r2,-20(fp)
   23b24:	10003245 	stb	zero,201(r2)
#endif

	ReadInterfaceStatus = true;
   23b28:	e0bffb17 	ldw	r2,-20(fp)
   23b2c:	00c00044 	movi	r3,1
   23b30:	10c03205 	stb	r3,200(r2)
	_all_write_addr_mapped = write_mapped;
   23b34:	e0bffb17 	ldw	r2,-20(fp)
   23b38:	e0fffa03 	ldbu	r3,-24(fp)
   23b3c:	10c00cc5 	stb	r3,51(r2)
	_all_read_addr_mapped = read_mapped;
   23b40:	e0bffb17 	ldw	r2,-20(fp)
   23b44:	e0fffa43 	ldbu	r3,-23(fp)
   23b48:	10c00c85 	stb	r3,50(r2)
	return (_all_write_addr_mapped and _all_read_addr_mapped);
   23b4c:	e0bffb17 	ldw	r2,-20(fp)
   23b50:	10800cc3 	ldbu	r2,51(r2)
   23b54:	10803fcc 	andi	r2,r2,255
   23b58:	10000626 	beq	r2,zero,23b74 <_ZN20Alf_SharedMemoryComm4InitEmmmmmmtm+0x1b4>
   23b5c:	e0bffb17 	ldw	r2,-20(fp)
   23b60:	10800c83 	ldbu	r2,50(r2)
   23b64:	10803fcc 	andi	r2,r2,255
   23b68:	10000226 	beq	r2,zero,23b74 <_ZN20Alf_SharedMemoryComm4InitEmmmmmmtm+0x1b4>
   23b6c:	00800044 	movi	r2,1
   23b70:	00000106 	br	23b78 <_ZN20Alf_SharedMemoryComm4InitEmmmmmmtm+0x1b8>
   23b74:	0005883a 	mov	r2,zero
}
   23b78:	e037883a 	mov	sp,fp
   23b7c:	dfc00117 	ldw	ra,4(sp)
   23b80:	df000017 	ldw	fp,0(sp)
   23b84:	dec00204 	addi	sp,sp,8
   23b88:	f800283a 	ret

00023b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>:

bool Alf_SharedMemoryComm::TryLock(void *addr){
   23b8c:	defffb04 	addi	sp,sp,-20
   23b90:	df000415 	stw	fp,16(sp)
   23b94:	df000404 	addi	fp,sp,16
   23b98:	e13ffe15 	stw	r4,-8(fp)
   23b9c:	e17fff15 	stw	r5,-4(fp)
	bool success = false;
   23ba0:	e03ffc05 	stb	zero,-16(fp)
	uint32_t register_write = ((uint32_t(_cpu_id) << 16) | 0x1);	//trying to write the cpu id and a 1 to the register. The 1 could be any other 16-bit value, it shows that the mutex is owned by a cpu.
   23ba4:	e0bffe17 	ldw	r2,-8(fp)
   23ba8:	10800c0b 	ldhu	r2,48(r2)
   23bac:	10bfffcc 	andi	r2,r2,65535
   23bb0:	1004943a 	slli	r2,r2,16
   23bb4:	10800054 	ori	r2,r2,1
   23bb8:	e0bffd15 	stw	r2,-12(fp)
	RW_REGISTER(addr) = register_write;
   23bbc:	e0bfff17 	ldw	r2,-4(fp)
   23bc0:	e0fffd17 	ldw	r3,-12(fp)
   23bc4:	10c00015 	stw	r3,0(r2)
	if(RW_REGISTER(addr) == register_write){	//checking if what we write is the same like what we now read
   23bc8:	e0bfff17 	ldw	r2,-4(fp)
   23bcc:	10c00017 	ldw	r3,0(r2)
   23bd0:	e0bffd17 	ldw	r2,-12(fp)
   23bd4:	1885003a 	cmpeq	r2,r3,r2
   23bd8:	10803fcc 	andi	r2,r2,255
   23bdc:	10000226 	beq	r2,zero,23be8 <_ZN20Alf_SharedMemoryComm7TryLockEPv+0x5c>
		success = true;	//if its the same, it works to get the lock, otherwise we have no lock on the shared memory
   23be0:	00800044 	movi	r2,1
   23be4:	e0bffc05 	stb	r2,-16(fp)
	}
	return success;
   23be8:	e0bffc03 	ldbu	r2,-16(fp)
}
   23bec:	e037883a 	mov	sp,fp
   23bf0:	df000017 	ldw	fp,0(sp)
   23bf4:	dec00104 	addi	sp,sp,4
   23bf8:	f800283a 	ret

00023bfc <_ZN20Alf_SharedMemoryComm23DisableMailboxInterruptEv>:

void Alf_SharedMemoryComm::DisableMailboxInterrupt(){
   23bfc:	defffe04 	addi	sp,sp,-8
   23c00:	df000115 	stw	fp,4(sp)
   23c04:	df000104 	addi	fp,sp,4
   23c08:	e13fff15 	stw	r4,-4(fp)
	RW_REGISTER(_rd_mailbox + RAW_NEXT_REG*3) = 0x0;
   23c0c:	e0bfff17 	ldw	r2,-4(fp)
   23c10:	10800b17 	ldw	r2,44(r2)
   23c14:	10800304 	addi	r2,r2,12
   23c18:	10000015 	stw	zero,0(r2)
}
   23c1c:	0001883a 	nop
   23c20:	e037883a 	mov	sp,fp
   23c24:	df000017 	ldw	fp,0(sp)
   23c28:	dec00104 	addi	sp,sp,4
   23c2c:	f800283a 	ret

00023c30 <_ZN20Alf_SharedMemoryComm22EnableMailboxInterruptEv>:

void Alf_SharedMemoryComm::EnableMailboxInterrupt(){
   23c30:	defffe04 	addi	sp,sp,-8
   23c34:	df000115 	stw	fp,4(sp)
   23c38:	df000104 	addi	fp,sp,4
   23c3c:	e13fff15 	stw	r4,-4(fp)
	RW_REGISTER(_rd_mailbox + RAW_NEXT_REG*3) = 0x03;
   23c40:	e0bfff17 	ldw	r2,-4(fp)
   23c44:	10800b17 	ldw	r2,44(r2)
   23c48:	10800304 	addi	r2,r2,12
   23c4c:	00c000c4 	movi	r3,3
   23c50:	10c00015 	stw	r3,0(r2)
}
   23c54:	0001883a 	nop
   23c58:	e037883a 	mov	sp,fp
   23c5c:	df000017 	ldw	fp,0(sp)
   23c60:	dec00104 	addi	sp,sp,4
   23c64:	f800283a 	ret

00023c68 <_ZN20Alf_SharedMemoryComm11WaitForLockEPv>:

void Alf_SharedMemoryComm::WaitForLock(void *addr){
   23c68:	defffc04 	addi	sp,sp,-16
   23c6c:	dfc00315 	stw	ra,12(sp)
   23c70:	df000215 	stw	fp,8(sp)
   23c74:	df000204 	addi	fp,sp,8
   23c78:	e13ffe15 	stw	r4,-8(fp)
   23c7c:	e17fff15 	stw	r5,-4(fp)
	while(not TryLock(addr));
   23c80:	e17fff17 	ldw	r5,-4(fp)
   23c84:	e13ffe17 	ldw	r4,-8(fp)
   23c88:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   23c8c:	1080005c 	xori	r2,r2,1
   23c90:	10803fcc 	andi	r2,r2,255
   23c94:	10000126 	beq	r2,zero,23c9c <_ZN20Alf_SharedMemoryComm11WaitForLockEPv+0x34>
   23c98:	003ff906 	br	23c80 <__reset+0xfff83c80>
}
   23c9c:	0001883a 	nop
   23ca0:	e037883a 	mov	sp,fp
   23ca4:	dfc00117 	ldw	ra,4(sp)
   23ca8:	df000017 	ldw	fp,0(sp)
   23cac:	dec00204 	addi	sp,sp,8
   23cb0:	f800283a 	ret

00023cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>:

void Alf_SharedMemoryComm::ReleaseLock(void *addr){
   23cb4:	defffc04 	addi	sp,sp,-16
   23cb8:	df000315 	stw	fp,12(sp)
   23cbc:	df000304 	addi	fp,sp,12
   23cc0:	e13ffe15 	stw	r4,-8(fp)
   23cc4:	e17fff15 	stw	r5,-4(fp)
	uint32_t cpu_to_write = uint32_t(_cpu_id) << 16;
   23cc8:	e0bffe17 	ldw	r2,-8(fp)
   23ccc:	10800c0b 	ldhu	r2,48(r2)
   23cd0:	10bfffcc 	andi	r2,r2,65535
   23cd4:	1004943a 	slli	r2,r2,16
   23cd8:	e0bffd15 	stw	r2,-12(fp)
#ifdef __linux__
	RW_REGISTER(addr) = cpu_to_write;
#else
	// stores the cpu_to_write to the addr (%1) with byte offset 0
	IOWR(addr,0,cpu_to_write);
   23cdc:	e0fffd17 	ldw	r3,-12(fp)
   23ce0:	e0bfff17 	ldw	r2,-4(fp)
   23ce4:	10c00035 	stwio	r3,0(r2)
#endif
}
   23ce8:	0001883a 	nop
   23cec:	e037883a 	mov	sp,fp
   23cf0:	df000017 	ldw	fp,0(sp)
   23cf4:	dec00104 	addi	sp,sp,4
   23cf8:	f800283a 	ret

00023cfc <_ZN20Alf_SharedMemoryComm21WriteAndCommitMailboxEPKvmRKm>:

bool Alf_SharedMemoryComm::WriteAndCommitMailbox(const void *addr, const uint32_t top_address, const uint32_t &message_id){
   23cfc:	defffb04 	addi	sp,sp,-20
   23d00:	df000415 	stw	fp,16(sp)
   23d04:	df000404 	addi	fp,sp,16
   23d08:	e13ffc15 	stw	r4,-16(fp)
   23d0c:	e17ffd15 	stw	r5,-12(fp)
   23d10:	e1bffe15 	stw	r6,-8(fp)
   23d14:	e1ffff15 	stw	r7,-4(fp)
	RW_REGISTER(addr + RAW_NEXT_REG) = top_address; //offset for pointer register, write the address to the mailbox' pointer register
   23d18:	e0bffd17 	ldw	r2,-12(fp)
   23d1c:	10800104 	addi	r2,r2,4
   23d20:	e0fffe17 	ldw	r3,-8(fp)
   23d24:	10c00015 	stw	r3,0(r2)
	RW_REGISTER(addr) = message_id; // now commit the message by writing any value to the command register, an interrupt will be triggered
   23d28:	e0bfff17 	ldw	r2,-4(fp)
   23d2c:	10c00017 	ldw	r3,0(r2)
   23d30:	e0bffd17 	ldw	r2,-12(fp)
   23d34:	10c00015 	stw	r3,0(r2)
	return true;
   23d38:	00800044 	movi	r2,1
}
   23d3c:	e037883a 	mov	sp,fp
   23d40:	df000017 	ldw	fp,0(sp)
   23d44:	dec00104 	addi	sp,sp,4
   23d48:	f800283a 	ret

00023d4c <_ZN20Alf_SharedMemoryComm5WriteERK17Alf_Drive_Command>:
	}else
		ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
	return ret_var;
}

alf_error Alf_SharedMemoryComm::Write(const Alf_Drive_Command &drive){
   23d4c:	defffa04 	addi	sp,sp,-24
   23d50:	dfc00515 	stw	ra,20(sp)
   23d54:	df000415 	stw	fp,16(sp)
   23d58:	df000404 	addi	fp,sp,16
   23d5c:	e13ffe15 	stw	r4,-8(fp)
   23d60:	e17fff15 	stw	r5,-4(fp)
	return HardwareWrite(drive, ALF_DRIVE_COMMAND_ID, sizeof(drive));
   23d64:	008000c4 	movi	r2,3
   23d68:	e0bffd15 	stw	r2,-12(fp)
   23d6c:	00800104 	movi	r2,4
   23d70:	e0bffc15 	stw	r2,-16(fp)
   23d74:	e0bffd04 	addi	r2,fp,-12
   23d78:	e1fffc04 	addi	r7,fp,-16
   23d7c:	100d883a 	mov	r6,r2
   23d80:	e17fff17 	ldw	r5,-4(fp)
   23d84:	e13ffe17 	ldw	r4,-8(fp)
   23d88:	00240ac0 	call	240ac <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_>
}
   23d8c:	e037883a 	mov	sp,fp
   23d90:	dfc00117 	ldw	ra,4(sp)
   23d94:	df000017 	ldw	fp,0(sp)
   23d98:	dec00204 	addi	sp,sp,8
   23d9c:	f800283a 	ret

00023da0 <_ZN20Alf_SharedMemoryComm5WriteERK14Alf_Drive_Info>:

alf_error Alf_SharedMemoryComm::Write(const Alf_Drive_Info &drive){
   23da0:	defffa04 	addi	sp,sp,-24
   23da4:	dfc00515 	stw	ra,20(sp)
   23da8:	df000415 	stw	fp,16(sp)
   23dac:	df000404 	addi	fp,sp,16
   23db0:	e13ffe15 	stw	r4,-8(fp)
   23db4:	e17fff15 	stw	r5,-4(fp)
	return HardwareWrite(drive, ALF_DRIVE_INFO_ID, sizeof(drive));
   23db8:	00800104 	movi	r2,4
   23dbc:	e0bffd15 	stw	r2,-12(fp)
   23dc0:	00800804 	movi	r2,32
   23dc4:	e0bffc15 	stw	r2,-16(fp)
   23dc8:	e0bffd04 	addi	r2,fp,-12
   23dcc:	e1fffc04 	addi	r7,fp,-16
   23dd0:	100d883a 	mov	r6,r2
   23dd4:	e17fff17 	ldw	r5,-4(fp)
   23dd8:	e13ffe17 	ldw	r4,-8(fp)
   23ddc:	00242400 	call	24240 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_>
}
   23de0:	e037883a 	mov	sp,fp
   23de4:	dfc00117 	ldw	ra,4(sp)
   23de8:	df000017 	ldw	fp,0(sp)
   23dec:	dec00204 	addi	sp,sp,8
   23df0:	f800283a 	ret

00023df4 <_ZN20Alf_SharedMemoryComm5WriteERm>:

alf_error Alf_SharedMemoryComm::Write(uint32_t &num){
   23df4:	defffb04 	addi	sp,sp,-20
   23df8:	dfc00415 	stw	ra,16(sp)
   23dfc:	df000315 	stw	fp,12(sp)
   23e00:	df000304 	addi	fp,sp,12
   23e04:	e13ffe15 	stw	r4,-8(fp)
   23e08:	e17fff15 	stw	r5,-4(fp)
	return HardwareWrite(num, num, sizeof(num));
   23e0c:	00800104 	movi	r2,4
   23e10:	e0bffd15 	stw	r2,-12(fp)
   23e14:	e1fffd04 	addi	r7,fp,-12
   23e18:	e1bfff17 	ldw	r6,-4(fp)
   23e1c:	e17fff17 	ldw	r5,-4(fp)
   23e20:	e13ffe17 	ldw	r4,-8(fp)
   23e24:	00243d40 	call	243d4 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_>
}
   23e28:	e037883a 	mov	sp,fp
   23e2c:	dfc00117 	ldw	ra,4(sp)
   23e30:	df000017 	ldw	fp,0(sp)
   23e34:	dec00204 	addi	sp,sp,8
   23e38:	f800283a 	ret

00023e3c <_ZN20Alf_SharedMemoryComm15ResetWriteMutexEv>:

void Alf_SharedMemoryComm::ResetWriteMutex(){
   23e3c:	defffe04 	addi	sp,sp,-8
   23e40:	df000115 	stw	fp,4(sp)
   23e44:	df000104 	addi	fp,sp,4
   23e48:	e13fff15 	stw	r4,-4(fp)
	RW_REGISTER(_wr_mutex + 0x04) = 0x1;		// first write a 1 to the reset register which set this register to 0
   23e4c:	e0bfff17 	ldw	r2,-4(fp)
   23e50:	10800317 	ldw	r2,12(r2)
   23e54:	10800104 	addi	r2,r2,4
   23e58:	00c00044 	movi	r3,1
   23e5c:	10c00015 	stw	r3,0(r2)
	RW_REGISTER(_wr_mutex) = (uint32_t(_cpu_id) << 16 ) | 0x0;	// then give the mutex free by writing the cpu id(thats also the default value) and 0 to the register
   23e60:	e0bfff17 	ldw	r2,-4(fp)
   23e64:	10800317 	ldw	r2,12(r2)
   23e68:	e0ffff17 	ldw	r3,-4(fp)
   23e6c:	18c00c0b 	ldhu	r3,48(r3)
   23e70:	18ffffcc 	andi	r3,r3,65535
   23e74:	1806943a 	slli	r3,r3,16
   23e78:	10c00015 	stw	r3,0(r2)
}
   23e7c:	0001883a 	nop
   23e80:	e037883a 	mov	sp,fp
   23e84:	df000017 	ldw	fp,0(sp)
   23e88:	dec00104 	addi	sp,sp,4
   23e8c:	f800283a 	ret

00023e90 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv>:

void Alf_SharedMemoryComm::ReadInterruptHandler(void){
   23e90:	defffb04 	addi	sp,sp,-20
   23e94:	dfc00415 	stw	ra,16(sp)
   23e98:	df000315 	stw	fp,12(sp)
   23e9c:	df000304 	addi	fp,sp,12
   23ea0:	e13fff15 	stw	r4,-4(fp)
	mailbox_s act_var;
	act_var.reg = RW_REGISTER(_rd_mailbox + RAW_NEXT_REG);	//first read the address register
   23ea4:	e0bfff17 	ldw	r2,-4(fp)
   23ea8:	10800b17 	ldw	r2,44(r2)
   23eac:	10800104 	addi	r2,r2,4
   23eb0:	10800017 	ldw	r2,0(r2)
   23eb4:	e0bffe15 	stw	r2,-8(fp)
	uint32_t message_id = RW_REGISTER(_rd_mailbox); 	// then read the message id which is communicated and implies to the sender that we read the message completely
   23eb8:	e0bfff17 	ldw	r2,-4(fp)
   23ebc:	10800b17 	ldw	r2,44(r2)
   23ec0:	10800017 	ldw	r2,0(r2)
   23ec4:	e0bffd15 	stw	r2,-12(fp)
	if(message_id != ALF_END_ID) WriteInterfaceStatus = true;
   23ec8:	e0bffd17 	ldw	r2,-12(fp)
   23ecc:	10803fe0 	cmpeqi	r2,r2,255
   23ed0:	1000031e 	bne	r2,zero,23ee0 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0x50>
   23ed4:	e0bfff17 	ldw	r2,-4(fp)
   23ed8:	00c00044 	movi	r3,1
   23edc:	10c03245 	stb	r3,201(r2)
	switch (message_id) {
   23ee0:	e0bffd17 	ldw	r2,-12(fp)
   23ee4:	10c00120 	cmpeqi	r3,r2,4
   23ee8:	1800051e 	bne	r3,zero,23f00 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0x70>
   23eec:	10c03fe0 	cmpeqi	r3,r2,255
   23ef0:	1800111e 	bne	r3,zero,23f38 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0xa8>
   23ef4:	108000e0 	cmpeqi	r2,r2,3
   23ef8:	1000081e 	bne	r2,zero,23f1c <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0x8c>
				break;
			case ALF_END_ID:
				WriteInterfaceStatus = false;
				break;
			default:
				break;
   23efc:	00001106 	br	23f44 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0xb4>
	act_var.reg = RW_REGISTER(_rd_mailbox + RAW_NEXT_REG);	//first read the address register
	uint32_t message_id = RW_REGISTER(_rd_mailbox); 	// then read the message id which is communicated and implies to the sender that we read the message completely
	if(message_id != ALF_END_ID) WriteInterfaceStatus = true;
	switch (message_id) {
			case ALF_DRIVE_INFO_ID:
				_buffer_drive_info.push(act_var);
   23f00:	e0bfff17 	ldw	r2,-4(fp)
   23f04:	10801204 	addi	r2,r2,72
   23f08:	e0fffe04 	addi	r3,fp,-8
   23f0c:	180b883a 	mov	r5,r3
   23f10:	1009883a 	mov	r4,r2
   23f14:	00245680 	call	24568 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_>
				break;
   23f18:	00000a06 	br	23f44 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0xb4>
			case ALF_DRIVE_COMMAND_ID:
				_buffer_drive_command.push(act_var);
   23f1c:	e0bfff17 	ldw	r2,-4(fp)
   23f20:	10802204 	addi	r2,r2,136
   23f24:	e0fffe04 	addi	r3,fp,-8
   23f28:	180b883a 	mov	r5,r3
   23f2c:	1009883a 	mov	r4,r2
   23f30:	00245680 	call	24568 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_>
				break;
   23f34:	00000306 	br	23f44 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv+0xb4>
			case ALF_END_ID:
				WriteInterfaceStatus = false;
   23f38:	e0bfff17 	ldw	r2,-4(fp)
   23f3c:	10003245 	stb	zero,201(r2)
				break;
   23f40:	0001883a 	nop
			default:
				break;
	}
}
   23f44:	0001883a 	nop
   23f48:	e037883a 	mov	sp,fp
   23f4c:	dfc00117 	ldw	ra,4(sp)
   23f50:	df000017 	ldw	fp,0(sp)
   23f54:	dec00204 	addi	sp,sp,8
   23f58:	f800283a 	ret

00023f5c <_ZN20Alf_SharedMemoryComm4ReadER14Alf_Drive_Info>:

alf_error Alf_SharedMemoryComm::Read(Alf_Drive_Info &drive){
   23f5c:	defff904 	addi	sp,sp,-28
   23f60:	dfc00615 	stw	ra,24(sp)
   23f64:	df000515 	stw	fp,20(sp)
   23f68:	df000504 	addi	fp,sp,20
   23f6c:	e13ffe15 	stw	r4,-8(fp)
   23f70:	e17fff15 	stw	r5,-4(fp)
	if(not _buffer_drive_info.empty()){
   23f74:	e0bffe17 	ldw	r2,-8(fp)
   23f78:	10801204 	addi	r2,r2,72
   23f7c:	1009883a 	mov	r4,r2
   23f80:	00246780 	call	24678 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE5emptyEv>
   23f84:	1080005c 	xori	r2,r2,1
   23f88:	10803fcc 	andi	r2,r2,255
   23f8c:	10001726 	beq	r2,zero,23fec <_ZN20Alf_SharedMemoryComm4ReadER14Alf_Drive_Info+0x90>
		mailbox_s top = _buffer_drive_info.top();
   23f90:	e0bffe17 	ldw	r2,-8(fp)
   23f94:	10801204 	addi	r2,r2,72
   23f98:	1009883a 	mov	r4,r2
   23f9c:	00246a00 	call	246a0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3topEv>
   23fa0:	e0bffd15 	stw	r2,-12(fp)
		_buffer_drive_info.pop();	//"remove" the top object
   23fa4:	e0bffe17 	ldw	r2,-8(fp)
   23fa8:	10801204 	addi	r2,r2,72
   23fac:	1009883a 	mov	r4,r2
   23fb0:	00246e00 	call	246e0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv>
		return HardwareRead(drive, sizeof(drive), uint32_t(top.reg + _shared_memory_rd));
   23fb4:	00800804 	movi	r2,32
   23fb8:	e0bffc15 	stw	r2,-16(fp)
   23fbc:	e0bffe17 	ldw	r2,-8(fp)
   23fc0:	10c00717 	ldw	r3,28(r2)
   23fc4:	e0bffd17 	ldw	r2,-12(fp)
   23fc8:	1885883a 	add	r2,r3,r2
   23fcc:	e0bffb15 	stw	r2,-20(fp)
   23fd0:	e0bffc04 	addi	r2,fp,-16
   23fd4:	e1fffb04 	addi	r7,fp,-20
   23fd8:	100d883a 	mov	r6,r2
   23fdc:	e17fff17 	ldw	r5,-4(fp)
   23fe0:	e13ffe17 	ldw	r4,-8(fp)
   23fe4:	002476c0 	call	2476c <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_>
   23fe8:	00000106 	br	23ff0 <_ZN20Alf_SharedMemoryComm4ReadER14Alf_Drive_Info+0x94>
	}else
		return ALF_NOTHING_IN_BUFFER;
   23fec:	00bfe7c4 	movi	r2,-97
}
   23ff0:	e037883a 	mov	sp,fp
   23ff4:	dfc00117 	ldw	ra,4(sp)
   23ff8:	df000017 	ldw	fp,0(sp)
   23ffc:	dec00204 	addi	sp,sp,8
   24000:	f800283a 	ret

00024004 <_ZN20Alf_SharedMemoryComm4ReadER17Alf_Drive_Command>:

alf_error Alf_SharedMemoryComm::Read(Alf_Drive_Command &drive){
   24004:	defff904 	addi	sp,sp,-28
   24008:	dfc00615 	stw	ra,24(sp)
   2400c:	df000515 	stw	fp,20(sp)
   24010:	df000504 	addi	fp,sp,20
   24014:	e13ffe15 	stw	r4,-8(fp)
   24018:	e17fff15 	stw	r5,-4(fp)
	if(not _buffer_drive_command.empty()){
   2401c:	e0bffe17 	ldw	r2,-8(fp)
   24020:	10802204 	addi	r2,r2,136
   24024:	1009883a 	mov	r4,r2
   24028:	00246780 	call	24678 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE5emptyEv>
   2402c:	1080005c 	xori	r2,r2,1
   24030:	10803fcc 	andi	r2,r2,255
   24034:	10001726 	beq	r2,zero,24094 <_ZN20Alf_SharedMemoryComm4ReadER17Alf_Drive_Command+0x90>
		mailbox_s top = _buffer_drive_command.top();
   24038:	e0bffe17 	ldw	r2,-8(fp)
   2403c:	10802204 	addi	r2,r2,136
   24040:	1009883a 	mov	r4,r2
   24044:	00246a00 	call	246a0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3topEv>
   24048:	e0bffd15 	stw	r2,-12(fp)
		_buffer_drive_command.pop();
   2404c:	e0bffe17 	ldw	r2,-8(fp)
   24050:	10802204 	addi	r2,r2,136
   24054:	1009883a 	mov	r4,r2
   24058:	00246e00 	call	246e0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv>
		return HardwareRead(drive, sizeof(drive), uint32_t(top.reg + _shared_memory_rd));
   2405c:	00800104 	movi	r2,4
   24060:	e0bffc15 	stw	r2,-16(fp)
   24064:	e0bffe17 	ldw	r2,-8(fp)
   24068:	10c00717 	ldw	r3,28(r2)
   2406c:	e0bffd17 	ldw	r2,-12(fp)
   24070:	1885883a 	add	r2,r3,r2
   24074:	e0bffb15 	stw	r2,-20(fp)
   24078:	e0bffc04 	addi	r2,fp,-16
   2407c:	e1fffb04 	addi	r7,fp,-20
   24080:	100d883a 	mov	r6,r2
   24084:	e17fff17 	ldw	r5,-4(fp)
   24088:	e13ffe17 	ldw	r4,-8(fp)
   2408c:	00248280 	call	24828 <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_>
   24090:	00000106 	br	24098 <_ZN20Alf_SharedMemoryComm4ReadER17Alf_Drive_Command+0x94>
	}else
		return ALF_NOTHING_IN_BUFFER;
   24094:	00bfe7c4 	movi	r2,-97
}
   24098:	e037883a 	mov	sp,fp
   2409c:	dfc00117 	ldw	ra,4(sp)
   240a0:	df000017 	ldw	fp,0(sp)
   240a4:	dec00204 	addi	sp,sp,8
   240a8:	f800283a 	ret

000240ac <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_>:
	RW_REGISTER(addr) = message_id; // now commit the message by writing any value to the command register, an interrupt will be triggered
	return true;
}

template <typename t>
alf_error Alf_SharedMemoryComm::HardwareWrite(const t &obj, const uint32_t &message_id, const uint32_t &size){
   240ac:	defff704 	addi	sp,sp,-36
   240b0:	dfc00815 	stw	ra,32(sp)
   240b4:	df000715 	stw	fp,28(sp)
   240b8:	df000704 	addi	fp,sp,28
   240bc:	e13ffc15 	stw	r4,-16(fp)
   240c0:	e17ffd15 	stw	r5,-12(fp)
   240c4:	e1bffe15 	stw	r6,-8(fp)
   240c8:	e1ffff15 	stw	r7,-4(fp)
	alf_error ret_var = ALF_NO_ERROR;
   240cc:	00800044 	movi	r2,1
   240d0:	e0bff915 	stw	r2,-28(fp)
	if(not WriteInterfaceStatus){
   240d4:	e0bffc17 	ldw	r2,-16(fp)
   240d8:	10803243 	ldbu	r2,201(r2)
   240dc:	1080005c 	xori	r2,r2,1
   240e0:	10803fcc 	andi	r2,r2,255
   240e4:	10000326 	beq	r2,zero,240f4 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x48>
		ret_var = ALF_WRITE_SHARED_MEMORY_DISABLED;
   240e8:	00bfea04 	movi	r2,-88
   240ec:	e0bff915 	stw	r2,-28(fp)
   240f0:	00004d06 	br	24228 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
	}else{
		uint32_t message_start;
		uint32_t new_pos = ((size/RAW_NEXT_REG)*RAW_NEXT_REG) + ((size%RAW_NEXT_REG) > 0 ? RAW_NEXT_REG : 0);	//calculating size of the message
   240f4:	e0bfff17 	ldw	r2,-4(fp)
   240f8:	10800017 	ldw	r2,0(r2)
   240fc:	1004d0ba 	srli	r2,r2,2
   24100:	1085883a 	add	r2,r2,r2
   24104:	1085883a 	add	r2,r2,r2
   24108:	1007883a 	mov	r3,r2
   2410c:	e0bfff17 	ldw	r2,-4(fp)
   24110:	10800017 	ldw	r2,0(r2)
   24114:	108000cc 	andi	r2,r2,3
   24118:	10000226 	beq	r2,zero,24124 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x78>
   2411c:	00800104 	movi	r2,4
   24120:	00000106 	br	24128 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x7c>
   24124:	0005883a 	mov	r2,zero
   24128:	1885883a 	add	r2,r3,r2
   2412c:	e0bffa15 	stw	r2,-24(fp)
		if(_all_write_addr_mapped){
   24130:	e0bffc17 	ldw	r2,-16(fp)
   24134:	10800cc3 	ldbu	r2,51(r2)
   24138:	10803fcc 	andi	r2,r2,255
   2413c:	10003826 	beq	r2,zero,24220 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x174>
			if(TryLock(_wr_mutex)){
   24140:	e0bffc17 	ldw	r2,-16(fp)
   24144:	10800317 	ldw	r2,12(r2)
   24148:	100b883a 	mov	r5,r2
   2414c:	e13ffc17 	ldw	r4,-16(fp)
   24150:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   24154:	10803fcc 	andi	r2,r2,255
   24158:	10002e26 	beq	r2,zero,24214 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x168>
				if(_wr_memory_pos + new_pos > _shared_memory_size)
   2415c:	e0bffc17 	ldw	r2,-16(fp)
   24160:	10800d0b 	ldhu	r2,52(r2)
   24164:	10ffffcc 	andi	r3,r2,65535
   24168:	e0bffa17 	ldw	r2,-24(fp)
   2416c:	1885883a 	add	r2,r3,r2
   24170:	e0fffc17 	ldw	r3,-16(fp)
   24174:	18c00f17 	ldw	r3,60(r3)
   24178:	1880022e 	bgeu	r3,r2,24184 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0xd8>
					_wr_memory_pos = 0;	//starting writing from 0 if the storage is full
   2417c:	e0bffc17 	ldw	r2,-16(fp)
   24180:	10000d0d 	sth	zero,52(r2)
				/// then copying the whole object to the memory
				std::memcpy(_shared_memory_wr + _wr_memory_pos, (void*)&obj, size);
   24184:	e0bffc17 	ldw	r2,-16(fp)
   24188:	10c00117 	ldw	r3,4(r2)
   2418c:	e0bffc17 	ldw	r2,-16(fp)
   24190:	10800d0b 	ldhu	r2,52(r2)
   24194:	10bfffcc 	andi	r2,r2,65535
   24198:	1887883a 	add	r3,r3,r2
   2419c:	e0bfff17 	ldw	r2,-4(fp)
   241a0:	10800017 	ldw	r2,0(r2)
   241a4:	100d883a 	mov	r6,r2
   241a8:	e17ffd17 	ldw	r5,-12(fp)
   241ac:	1809883a 	mov	r4,r3
   241b0:	002b6ac0 	call	2b6ac <memcpy>
				message_start = _wr_memory_pos;
   241b4:	e0bffc17 	ldw	r2,-16(fp)
   241b8:	10800d0b 	ldhu	r2,52(r2)
   241bc:	10bfffcc 	andi	r2,r2,65535
   241c0:	e0bffb15 	stw	r2,-20(fp)
				_wr_memory_pos += new_pos;
   241c4:	e0bffc17 	ldw	r2,-16(fp)
   241c8:	10800d0b 	ldhu	r2,52(r2)
   241cc:	e0fffa17 	ldw	r3,-24(fp)
   241d0:	10c5883a 	add	r2,r2,r3
   241d4:	1007883a 	mov	r3,r2
   241d8:	e0bffc17 	ldw	r2,-16(fp)
   241dc:	10c00d0d 	sth	r3,52(r2)
				ReleaseLock(_wr_mutex);
   241e0:	e0bffc17 	ldw	r2,-16(fp)
   241e4:	10800317 	ldw	r2,12(r2)
   241e8:	100b883a 	mov	r5,r2
   241ec:	e13ffc17 	ldw	r4,-16(fp)
   241f0:	0023cb40 	call	23cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>
				WriteAndCommitMailbox(_wr_mailbox, message_start, message_id);
   241f4:	e0bffc17 	ldw	r2,-16(fp)
   241f8:	10800517 	ldw	r2,20(r2)
   241fc:	e1fffe17 	ldw	r7,-8(fp)
   24200:	e1bffb17 	ldw	r6,-20(fp)
   24204:	100b883a 	mov	r5,r2
   24208:	e13ffc17 	ldw	r4,-16(fp)
   2420c:	0023cfc0 	call	23cfc <_ZN20Alf_SharedMemoryComm21WriteAndCommitMailboxEPKvmRKm>
   24210:	00000506 	br	24228 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
			}else{
				ret_var = ALF_LOCK_MEMORY_FAILED;
   24214:	00bfe9c4 	movi	r2,-89
   24218:	e0bff915 	stw	r2,-28(fp)
   2421c:	00000206 	br	24228 <_ZN20Alf_SharedMemoryComm13HardwareWriteI17Alf_Drive_CommandEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
			}
		}else{
			ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
   24220:	00bfe984 	movi	r2,-90
   24224:	e0bff915 	stw	r2,-28(fp)
		}
	}
	return ret_var;
   24228:	e0bff917 	ldw	r2,-28(fp)
}
   2422c:	e037883a 	mov	sp,fp
   24230:	dfc00117 	ldw	ra,4(sp)
   24234:	df000017 	ldw	fp,0(sp)
   24238:	dec00204 	addi	sp,sp,8
   2423c:	f800283a 	ret

00024240 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_>:
	RW_REGISTER(addr) = message_id; // now commit the message by writing any value to the command register, an interrupt will be triggered
	return true;
}

template <typename t>
alf_error Alf_SharedMemoryComm::HardwareWrite(const t &obj, const uint32_t &message_id, const uint32_t &size){
   24240:	defff704 	addi	sp,sp,-36
   24244:	dfc00815 	stw	ra,32(sp)
   24248:	df000715 	stw	fp,28(sp)
   2424c:	df000704 	addi	fp,sp,28
   24250:	e13ffc15 	stw	r4,-16(fp)
   24254:	e17ffd15 	stw	r5,-12(fp)
   24258:	e1bffe15 	stw	r6,-8(fp)
   2425c:	e1ffff15 	stw	r7,-4(fp)
	alf_error ret_var = ALF_NO_ERROR;
   24260:	00800044 	movi	r2,1
   24264:	e0bff915 	stw	r2,-28(fp)
	if(not WriteInterfaceStatus){
   24268:	e0bffc17 	ldw	r2,-16(fp)
   2426c:	10803243 	ldbu	r2,201(r2)
   24270:	1080005c 	xori	r2,r2,1
   24274:	10803fcc 	andi	r2,r2,255
   24278:	10000326 	beq	r2,zero,24288 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x48>
		ret_var = ALF_WRITE_SHARED_MEMORY_DISABLED;
   2427c:	00bfea04 	movi	r2,-88
   24280:	e0bff915 	stw	r2,-28(fp)
   24284:	00004d06 	br	243bc <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
	}else{
		uint32_t message_start;
		uint32_t new_pos = ((size/RAW_NEXT_REG)*RAW_NEXT_REG) + ((size%RAW_NEXT_REG) > 0 ? RAW_NEXT_REG : 0);	//calculating size of the message
   24288:	e0bfff17 	ldw	r2,-4(fp)
   2428c:	10800017 	ldw	r2,0(r2)
   24290:	1004d0ba 	srli	r2,r2,2
   24294:	1085883a 	add	r2,r2,r2
   24298:	1085883a 	add	r2,r2,r2
   2429c:	1007883a 	mov	r3,r2
   242a0:	e0bfff17 	ldw	r2,-4(fp)
   242a4:	10800017 	ldw	r2,0(r2)
   242a8:	108000cc 	andi	r2,r2,3
   242ac:	10000226 	beq	r2,zero,242b8 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x78>
   242b0:	00800104 	movi	r2,4
   242b4:	00000106 	br	242bc <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x7c>
   242b8:	0005883a 	mov	r2,zero
   242bc:	1885883a 	add	r2,r3,r2
   242c0:	e0bffa15 	stw	r2,-24(fp)
		if(_all_write_addr_mapped){
   242c4:	e0bffc17 	ldw	r2,-16(fp)
   242c8:	10800cc3 	ldbu	r2,51(r2)
   242cc:	10803fcc 	andi	r2,r2,255
   242d0:	10003826 	beq	r2,zero,243b4 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x174>
			if(TryLock(_wr_mutex)){
   242d4:	e0bffc17 	ldw	r2,-16(fp)
   242d8:	10800317 	ldw	r2,12(r2)
   242dc:	100b883a 	mov	r5,r2
   242e0:	e13ffc17 	ldw	r4,-16(fp)
   242e4:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   242e8:	10803fcc 	andi	r2,r2,255
   242ec:	10002e26 	beq	r2,zero,243a8 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x168>
				if(_wr_memory_pos + new_pos > _shared_memory_size)
   242f0:	e0bffc17 	ldw	r2,-16(fp)
   242f4:	10800d0b 	ldhu	r2,52(r2)
   242f8:	10ffffcc 	andi	r3,r2,65535
   242fc:	e0bffa17 	ldw	r2,-24(fp)
   24300:	1885883a 	add	r2,r3,r2
   24304:	e0fffc17 	ldw	r3,-16(fp)
   24308:	18c00f17 	ldw	r3,60(r3)
   2430c:	1880022e 	bgeu	r3,r2,24318 <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0xd8>
					_wr_memory_pos = 0;	//starting writing from 0 if the storage is full
   24310:	e0bffc17 	ldw	r2,-16(fp)
   24314:	10000d0d 	sth	zero,52(r2)
				/// then copying the whole object to the memory
				std::memcpy(_shared_memory_wr + _wr_memory_pos, (void*)&obj, size);
   24318:	e0bffc17 	ldw	r2,-16(fp)
   2431c:	10c00117 	ldw	r3,4(r2)
   24320:	e0bffc17 	ldw	r2,-16(fp)
   24324:	10800d0b 	ldhu	r2,52(r2)
   24328:	10bfffcc 	andi	r2,r2,65535
   2432c:	1887883a 	add	r3,r3,r2
   24330:	e0bfff17 	ldw	r2,-4(fp)
   24334:	10800017 	ldw	r2,0(r2)
   24338:	100d883a 	mov	r6,r2
   2433c:	e17ffd17 	ldw	r5,-12(fp)
   24340:	1809883a 	mov	r4,r3
   24344:	002b6ac0 	call	2b6ac <memcpy>
				message_start = _wr_memory_pos;
   24348:	e0bffc17 	ldw	r2,-16(fp)
   2434c:	10800d0b 	ldhu	r2,52(r2)
   24350:	10bfffcc 	andi	r2,r2,65535
   24354:	e0bffb15 	stw	r2,-20(fp)
				_wr_memory_pos += new_pos;
   24358:	e0bffc17 	ldw	r2,-16(fp)
   2435c:	10800d0b 	ldhu	r2,52(r2)
   24360:	e0fffa17 	ldw	r3,-24(fp)
   24364:	10c5883a 	add	r2,r2,r3
   24368:	1007883a 	mov	r3,r2
   2436c:	e0bffc17 	ldw	r2,-16(fp)
   24370:	10c00d0d 	sth	r3,52(r2)
				ReleaseLock(_wr_mutex);
   24374:	e0bffc17 	ldw	r2,-16(fp)
   24378:	10800317 	ldw	r2,12(r2)
   2437c:	100b883a 	mov	r5,r2
   24380:	e13ffc17 	ldw	r4,-16(fp)
   24384:	0023cb40 	call	23cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>
				WriteAndCommitMailbox(_wr_mailbox, message_start, message_id);
   24388:	e0bffc17 	ldw	r2,-16(fp)
   2438c:	10800517 	ldw	r2,20(r2)
   24390:	e1fffe17 	ldw	r7,-8(fp)
   24394:	e1bffb17 	ldw	r6,-20(fp)
   24398:	100b883a 	mov	r5,r2
   2439c:	e13ffc17 	ldw	r4,-16(fp)
   243a0:	0023cfc0 	call	23cfc <_ZN20Alf_SharedMemoryComm21WriteAndCommitMailboxEPKvmRKm>
   243a4:	00000506 	br	243bc <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
			}else{
				ret_var = ALF_LOCK_MEMORY_FAILED;
   243a8:	00bfe9c4 	movi	r2,-89
   243ac:	e0bff915 	stw	r2,-28(fp)
   243b0:	00000206 	br	243bc <_ZN20Alf_SharedMemoryComm13HardwareWriteI14Alf_Drive_InfoEE15ALF_ERROR_CODESRKT_RKmS7_+0x17c>
			}
		}else{
			ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
   243b4:	00bfe984 	movi	r2,-90
   243b8:	e0bff915 	stw	r2,-28(fp)
		}
	}
	return ret_var;
   243bc:	e0bff917 	ldw	r2,-28(fp)
}
   243c0:	e037883a 	mov	sp,fp
   243c4:	dfc00117 	ldw	ra,4(sp)
   243c8:	df000017 	ldw	fp,0(sp)
   243cc:	dec00204 	addi	sp,sp,8
   243d0:	f800283a 	ret

000243d4 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_>:
	RW_REGISTER(addr) = message_id; // now commit the message by writing any value to the command register, an interrupt will be triggered
	return true;
}

template <typename t>
alf_error Alf_SharedMemoryComm::HardwareWrite(const t &obj, const uint32_t &message_id, const uint32_t &size){
   243d4:	defff704 	addi	sp,sp,-36
   243d8:	dfc00815 	stw	ra,32(sp)
   243dc:	df000715 	stw	fp,28(sp)
   243e0:	df000704 	addi	fp,sp,28
   243e4:	e13ffc15 	stw	r4,-16(fp)
   243e8:	e17ffd15 	stw	r5,-12(fp)
   243ec:	e1bffe15 	stw	r6,-8(fp)
   243f0:	e1ffff15 	stw	r7,-4(fp)
	alf_error ret_var = ALF_NO_ERROR;
   243f4:	00800044 	movi	r2,1
   243f8:	e0bff915 	stw	r2,-28(fp)
	if(not WriteInterfaceStatus){
   243fc:	e0bffc17 	ldw	r2,-16(fp)
   24400:	10803243 	ldbu	r2,201(r2)
   24404:	1080005c 	xori	r2,r2,1
   24408:	10803fcc 	andi	r2,r2,255
   2440c:	10000326 	beq	r2,zero,2441c <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x48>
		ret_var = ALF_WRITE_SHARED_MEMORY_DISABLED;
   24410:	00bfea04 	movi	r2,-88
   24414:	e0bff915 	stw	r2,-28(fp)
   24418:	00004d06 	br	24550 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x17c>
	}else{
		uint32_t message_start;
		uint32_t new_pos = ((size/RAW_NEXT_REG)*RAW_NEXT_REG) + ((size%RAW_NEXT_REG) > 0 ? RAW_NEXT_REG : 0);	//calculating size of the message
   2441c:	e0bfff17 	ldw	r2,-4(fp)
   24420:	10800017 	ldw	r2,0(r2)
   24424:	1004d0ba 	srli	r2,r2,2
   24428:	1085883a 	add	r2,r2,r2
   2442c:	1085883a 	add	r2,r2,r2
   24430:	1007883a 	mov	r3,r2
   24434:	e0bfff17 	ldw	r2,-4(fp)
   24438:	10800017 	ldw	r2,0(r2)
   2443c:	108000cc 	andi	r2,r2,3
   24440:	10000226 	beq	r2,zero,2444c <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x78>
   24444:	00800104 	movi	r2,4
   24448:	00000106 	br	24450 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x7c>
   2444c:	0005883a 	mov	r2,zero
   24450:	1885883a 	add	r2,r3,r2
   24454:	e0bffa15 	stw	r2,-24(fp)
		if(_all_write_addr_mapped){
   24458:	e0bffc17 	ldw	r2,-16(fp)
   2445c:	10800cc3 	ldbu	r2,51(r2)
   24460:	10803fcc 	andi	r2,r2,255
   24464:	10003826 	beq	r2,zero,24548 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x174>
			if(TryLock(_wr_mutex)){
   24468:	e0bffc17 	ldw	r2,-16(fp)
   2446c:	10800317 	ldw	r2,12(r2)
   24470:	100b883a 	mov	r5,r2
   24474:	e13ffc17 	ldw	r4,-16(fp)
   24478:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   2447c:	10803fcc 	andi	r2,r2,255
   24480:	10002e26 	beq	r2,zero,2453c <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x168>
				if(_wr_memory_pos + new_pos > _shared_memory_size)
   24484:	e0bffc17 	ldw	r2,-16(fp)
   24488:	10800d0b 	ldhu	r2,52(r2)
   2448c:	10ffffcc 	andi	r3,r2,65535
   24490:	e0bffa17 	ldw	r2,-24(fp)
   24494:	1885883a 	add	r2,r3,r2
   24498:	e0fffc17 	ldw	r3,-16(fp)
   2449c:	18c00f17 	ldw	r3,60(r3)
   244a0:	1880022e 	bgeu	r3,r2,244ac <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0xd8>
					_wr_memory_pos = 0;	//starting writing from 0 if the storage is full
   244a4:	e0bffc17 	ldw	r2,-16(fp)
   244a8:	10000d0d 	sth	zero,52(r2)
				/// then copying the whole object to the memory
				std::memcpy(_shared_memory_wr + _wr_memory_pos, (void*)&obj, size);
   244ac:	e0bffc17 	ldw	r2,-16(fp)
   244b0:	10c00117 	ldw	r3,4(r2)
   244b4:	e0bffc17 	ldw	r2,-16(fp)
   244b8:	10800d0b 	ldhu	r2,52(r2)
   244bc:	10bfffcc 	andi	r2,r2,65535
   244c0:	1887883a 	add	r3,r3,r2
   244c4:	e0bfff17 	ldw	r2,-4(fp)
   244c8:	10800017 	ldw	r2,0(r2)
   244cc:	100d883a 	mov	r6,r2
   244d0:	e17ffd17 	ldw	r5,-12(fp)
   244d4:	1809883a 	mov	r4,r3
   244d8:	002b6ac0 	call	2b6ac <memcpy>
				message_start = _wr_memory_pos;
   244dc:	e0bffc17 	ldw	r2,-16(fp)
   244e0:	10800d0b 	ldhu	r2,52(r2)
   244e4:	10bfffcc 	andi	r2,r2,65535
   244e8:	e0bffb15 	stw	r2,-20(fp)
				_wr_memory_pos += new_pos;
   244ec:	e0bffc17 	ldw	r2,-16(fp)
   244f0:	10800d0b 	ldhu	r2,52(r2)
   244f4:	e0fffa17 	ldw	r3,-24(fp)
   244f8:	10c5883a 	add	r2,r2,r3
   244fc:	1007883a 	mov	r3,r2
   24500:	e0bffc17 	ldw	r2,-16(fp)
   24504:	10c00d0d 	sth	r3,52(r2)
				ReleaseLock(_wr_mutex);
   24508:	e0bffc17 	ldw	r2,-16(fp)
   2450c:	10800317 	ldw	r2,12(r2)
   24510:	100b883a 	mov	r5,r2
   24514:	e13ffc17 	ldw	r4,-16(fp)
   24518:	0023cb40 	call	23cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>
				WriteAndCommitMailbox(_wr_mailbox, message_start, message_id);
   2451c:	e0bffc17 	ldw	r2,-16(fp)
   24520:	10800517 	ldw	r2,20(r2)
   24524:	e1fffe17 	ldw	r7,-8(fp)
   24528:	e1bffb17 	ldw	r6,-20(fp)
   2452c:	100b883a 	mov	r5,r2
   24530:	e13ffc17 	ldw	r4,-16(fp)
   24534:	0023cfc0 	call	23cfc <_ZN20Alf_SharedMemoryComm21WriteAndCommitMailboxEPKvmRKm>
   24538:	00000506 	br	24550 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x17c>
			}else{
				ret_var = ALF_LOCK_MEMORY_FAILED;
   2453c:	00bfe9c4 	movi	r2,-89
   24540:	e0bff915 	stw	r2,-28(fp)
   24544:	00000206 	br	24550 <_ZN20Alf_SharedMemoryComm13HardwareWriteImEE15ALF_ERROR_CODESRKT_RKmS6_+0x17c>
			}
		}else{
			ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
   24548:	00bfe984 	movi	r2,-90
   2454c:	e0bff915 	stw	r2,-28(fp)
		}
	}
	return ret_var;
   24550:	e0bff917 	ldw	r2,-28(fp)
}
   24554:	e037883a 	mov	sp,fp
   24558:	dfc00117 	ldw	ra,4(sp)
   2455c:	df000017 	ldw	fp,0(sp)
   24560:	dec00204 	addi	sp,sp,8
   24564:	f800283a 	ret

00024568 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_>:
	/**
	 * @brief      Pushs a element to the ring buffer. If the ring buffer is full, the oldest element in there will be overwritten.
	 *
	 * @param[in]  a     The element to push into.
	 */
	void push(const obj &a){
   24568:	defffc04 	addi	sp,sp,-16
   2456c:	dfc00315 	stw	ra,12(sp)
   24570:	df000215 	stw	fp,8(sp)
   24574:	df000204 	addi	fp,sp,8
   24578:	e13ffe15 	stw	r4,-8(fp)
   2457c:	e17fff15 	stw	r5,-4(fp)
		if(not _empty){
   24580:	e0bffe17 	ldw	r2,-8(fp)
   24584:	10800f03 	ldbu	r2,60(r2)
   24588:	1080005c 	xori	r2,r2,1
   2458c:	10803fcc 	andi	r2,r2,255
   24590:	10002726 	beq	r2,zero,24630 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_+0xc8>
			_top_element = (_top_element + 1)%_max_size;
   24594:	e0bffe17 	ldw	r2,-8(fp)
   24598:	10800d17 	ldw	r2,52(r2)
   2459c:	10c00044 	addi	r3,r2,1
   245a0:	e0bffe17 	ldw	r2,-8(fp)
   245a4:	10800017 	ldw	r2,0(r2)
   245a8:	100b883a 	mov	r5,r2
   245ac:	1809883a 	mov	r4,r3
   245b0:	0027e500 	call	27e50 <__umodsi3>
   245b4:	1007883a 	mov	r3,r2
   245b8:	e0bffe17 	ldw	r2,-8(fp)
   245bc:	10c00d15 	stw	r3,52(r2)
			if(_top_element == _first_element){
   245c0:	e0bffe17 	ldw	r2,-8(fp)
   245c4:	10c00d17 	ldw	r3,52(r2)
   245c8:	e0bffe17 	ldw	r2,-8(fp)
   245cc:	10800e17 	ldw	r2,56(r2)
   245d0:	18800b1e 	bne	r3,r2,24600 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE4pushERKS1_+0x98>
				_first_element = (_first_element+1)%_max_size;
   245d4:	e0bffe17 	ldw	r2,-8(fp)
   245d8:	10800e17 	ldw	r2,56(r2)
   245dc:	10c00044 	addi	r3,r2,1
   245e0:	e0bffe17 	ldw	r2,-8(fp)
   245e4:	10800017 	ldw	r2,0(r2)
   245e8:	100b883a 	mov	r5,r2
   245ec:	1809883a 	mov	r4,r3
   245f0:	0027e500 	call	27e50 <__umodsi3>
   245f4:	1007883a 	mov	r3,r2
   245f8:	e0bffe17 	ldw	r2,-8(fp)
   245fc:	10c00e15 	stw	r3,56(r2)
			}
			_stack[_top_element] = a;
   24600:	e0bffe17 	ldw	r2,-8(fp)
   24604:	10800d17 	ldw	r2,52(r2)
   24608:	e0fffe17 	ldw	r3,-8(fp)
   2460c:	10800044 	addi	r2,r2,1
   24610:	1085883a 	add	r2,r2,r2
   24614:	1085883a 	add	r2,r2,r2
   24618:	1885883a 	add	r2,r3,r2
   2461c:	e0ffff17 	ldw	r3,-4(fp)
   24620:	18c00017 	ldw	r3,0(r3)
   24624:	10c00015 	stw	r3,0(r2)
			_empty = false;
   24628:	e0bffe17 	ldw	r2,-8(fp)
   2462c:	10000f05 	stb	zero,60(r2)
		}
		_stack[_top_element] = a;
   24630:	e0bffe17 	ldw	r2,-8(fp)
   24634:	10800d17 	ldw	r2,52(r2)
   24638:	e0fffe17 	ldw	r3,-8(fp)
   2463c:	10800044 	addi	r2,r2,1
   24640:	1085883a 	add	r2,r2,r2
   24644:	1085883a 	add	r2,r2,r2
   24648:	1885883a 	add	r2,r3,r2
   2464c:	e0ffff17 	ldw	r3,-4(fp)
   24650:	18c00017 	ldw	r3,0(r3)
   24654:	10c00015 	stw	r3,0(r2)
		_empty = false;
   24658:	e0bffe17 	ldw	r2,-8(fp)
   2465c:	10000f05 	stb	zero,60(r2)
	}
   24660:	0001883a 	nop
   24664:	e037883a 	mov	sp,fp
   24668:	dfc00117 	ldw	ra,4(sp)
   2466c:	df000017 	ldw	fp,0(sp)
   24670:	dec00204 	addi	sp,sp,8
   24674:	f800283a 	ret

00024678 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE5emptyEv>:
	/**
	 * @brief      Is the ring buffer empty?
	 *
	 * @return     true = empty, false = elements in the ring buffer
	 */
	bool empty(){
   24678:	defffe04 	addi	sp,sp,-8
   2467c:	df000115 	stw	fp,4(sp)
   24680:	df000104 	addi	fp,sp,4
   24684:	e13fff15 	stw	r4,-4(fp)
		return _empty;
   24688:	e0bfff17 	ldw	r2,-4(fp)
   2468c:	10800f03 	ldbu	r2,60(r2)
	}
   24690:	e037883a 	mov	sp,fp
   24694:	df000017 	ldw	fp,0(sp)
   24698:	dec00104 	addi	sp,sp,4
   2469c:	f800283a 	ret

000246a0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3topEv>:
	 * @brief      returns the top element on the ring buffer (is the actualst)
	 *
	 * @return     the top element, could be of any datatype
	 * @attention  a call to #pop() is necessary if the element should removed from the ring buffer
	 */
	obj top(){
   246a0:	defffe04 	addi	sp,sp,-8
   246a4:	df000115 	stw	fp,4(sp)
   246a8:	df000104 	addi	fp,sp,4
   246ac:	e13fff15 	stw	r4,-4(fp)
		return _stack[_top_element];
   246b0:	e0bfff17 	ldw	r2,-4(fp)
   246b4:	10800d17 	ldw	r2,52(r2)
   246b8:	e0ffff17 	ldw	r3,-4(fp)
   246bc:	10800044 	addi	r2,r2,1
   246c0:	1085883a 	add	r2,r2,r2
   246c4:	1085883a 	add	r2,r2,r2
   246c8:	1885883a 	add	r2,r3,r2
   246cc:	10800017 	ldw	r2,0(r2)
	}
   246d0:	e037883a 	mov	sp,fp
   246d4:	df000017 	ldw	fp,0(sp)
   246d8:	dec00104 	addi	sp,sp,4
   246dc:	f800283a 	ret

000246e0 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv>:

	/**
	 * @brief      Removes the top element of the ringbuffer. This element is the actualst element, next top element ist n-1.
	 */
	void pop(){
   246e0:	defffe04 	addi	sp,sp,-8
   246e4:	df000115 	stw	fp,4(sp)
   246e8:	df000104 	addi	fp,sp,4
   246ec:	e13fff15 	stw	r4,-4(fp)
		if(not _empty){
   246f0:	e0bfff17 	ldw	r2,-4(fp)
   246f4:	10800f03 	ldbu	r2,60(r2)
   246f8:	1080005c 	xori	r2,r2,1
   246fc:	10803fcc 	andi	r2,r2,255
   24700:	10001526 	beq	r2,zero,24758 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv+0x78>
			if(_top_element == _first_element) _empty = true;
   24704:	e0bfff17 	ldw	r2,-4(fp)
   24708:	10c00d17 	ldw	r3,52(r2)
   2470c:	e0bfff17 	ldw	r2,-4(fp)
   24710:	10800e17 	ldw	r2,56(r2)
   24714:	1880041e 	bne	r3,r2,24728 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv+0x48>
   24718:	e0bfff17 	ldw	r2,-4(fp)
   2471c:	00c00044 	movi	r3,1
   24720:	10c00f05 	stb	r3,60(r2)
			else{
				if(_top_element == 0) _top_element = _max_size;
				_top_element--;
			}
		}
	}
   24724:	00000c06 	br	24758 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv+0x78>
	 */
	void pop(){
		if(not _empty){
			if(_top_element == _first_element) _empty = true;
			else{
				if(_top_element == 0) _top_element = _max_size;
   24728:	e0bfff17 	ldw	r2,-4(fp)
   2472c:	10800d17 	ldw	r2,52(r2)
   24730:	1000041e 	bne	r2,zero,24744 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EE3popEv+0x64>
   24734:	e0bfff17 	ldw	r2,-4(fp)
   24738:	10c00017 	ldw	r3,0(r2)
   2473c:	e0bfff17 	ldw	r2,-4(fp)
   24740:	10c00d15 	stw	r3,52(r2)
				_top_element--;
   24744:	e0bfff17 	ldw	r2,-4(fp)
   24748:	10800d17 	ldw	r2,52(r2)
   2474c:	10ffffc4 	addi	r3,r2,-1
   24750:	e0bfff17 	ldw	r2,-4(fp)
   24754:	10c00d15 	stw	r3,52(r2)
			}
		}
	}
   24758:	0001883a 	nop
   2475c:	e037883a 	mov	sp,fp
   24760:	df000017 	ldw	fp,0(sp)
   24764:	dec00104 	addi	sp,sp,4
   24768:	f800283a 	ret

0002476c <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_>:

template <typename t>
alf_error Alf_SharedMemoryComm::HardwareRead(t &obj, const uint32_t &size, const uint32_t &addr){
   2476c:	defff904 	addi	sp,sp,-28
   24770:	dfc00615 	stw	ra,24(sp)
   24774:	df000515 	stw	fp,20(sp)
   24778:	df000504 	addi	fp,sp,20
   2477c:	e13ffc15 	stw	r4,-16(fp)
   24780:	e17ffd15 	stw	r5,-12(fp)
   24784:	e1bffe15 	stw	r6,-8(fp)
   24788:	e1ffff15 	stw	r7,-4(fp)
	alf_error ret_var = ALF_NO_ERROR;
   2478c:	00800044 	movi	r2,1
   24790:	e0bffb15 	stw	r2,-20(fp)
	if(_all_write_addr_mapped){
   24794:	e0bffc17 	ldw	r2,-16(fp)
   24798:	10800cc3 	ldbu	r2,51(r2)
   2479c:	10803fcc 	andi	r2,r2,255
   247a0:	10001926 	beq	r2,zero,24808 <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_+0x9c>
		if(TryLock(_rd_mutex)){
   247a4:	e0bffc17 	ldw	r2,-16(fp)
   247a8:	10800917 	ldw	r2,36(r2)
   247ac:	100b883a 	mov	r5,r2
   247b0:	e13ffc17 	ldw	r4,-16(fp)
   247b4:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   247b8:	10803fcc 	andi	r2,r2,255
   247bc:	10000f26 	beq	r2,zero,247fc <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_+0x90>
			std::memcpy((void*)&obj, (void*)addr, size);
   247c0:	e0bfff17 	ldw	r2,-4(fp)
   247c4:	10800017 	ldw	r2,0(r2)
   247c8:	1007883a 	mov	r3,r2
   247cc:	e0bffe17 	ldw	r2,-8(fp)
   247d0:	10800017 	ldw	r2,0(r2)
   247d4:	100d883a 	mov	r6,r2
   247d8:	180b883a 	mov	r5,r3
   247dc:	e13ffd17 	ldw	r4,-12(fp)
   247e0:	002b6ac0 	call	2b6ac <memcpy>
			ReleaseLock(_rd_mutex);
   247e4:	e0bffc17 	ldw	r2,-16(fp)
   247e8:	10800917 	ldw	r2,36(r2)
   247ec:	100b883a 	mov	r5,r2
   247f0:	e13ffc17 	ldw	r4,-16(fp)
   247f4:	0023cb40 	call	23cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>
   247f8:	00000506 	br	24810 <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_+0xa4>
		}else
			ret_var = ALF_LOCK_MEMORY_FAILED;
   247fc:	00bfe9c4 	movi	r2,-89
   24800:	e0bffb15 	stw	r2,-20(fp)
   24804:	00000206 	br	24810 <_ZN20Alf_SharedMemoryComm12HardwareReadI14Alf_Drive_InfoEE15ALF_ERROR_CODESRT_RKmS6_+0xa4>
	}else
		ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
   24808:	00bfe984 	movi	r2,-90
   2480c:	e0bffb15 	stw	r2,-20(fp)
	return ret_var;
   24810:	e0bffb17 	ldw	r2,-20(fp)
}
   24814:	e037883a 	mov	sp,fp
   24818:	dfc00117 	ldw	ra,4(sp)
   2481c:	df000017 	ldw	fp,0(sp)
   24820:	dec00204 	addi	sp,sp,8
   24824:	f800283a 	ret

00024828 <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_>:
	}
	return ret_var;
}

template <typename t>
alf_error Alf_SharedMemoryComm::HardwareRead(t &obj, const uint32_t &size, const uint32_t &addr){
   24828:	defff904 	addi	sp,sp,-28
   2482c:	dfc00615 	stw	ra,24(sp)
   24830:	df000515 	stw	fp,20(sp)
   24834:	df000504 	addi	fp,sp,20
   24838:	e13ffc15 	stw	r4,-16(fp)
   2483c:	e17ffd15 	stw	r5,-12(fp)
   24840:	e1bffe15 	stw	r6,-8(fp)
   24844:	e1ffff15 	stw	r7,-4(fp)
	alf_error ret_var = ALF_NO_ERROR;
   24848:	00800044 	movi	r2,1
   2484c:	e0bffb15 	stw	r2,-20(fp)
	if(_all_write_addr_mapped){
   24850:	e0bffc17 	ldw	r2,-16(fp)
   24854:	10800cc3 	ldbu	r2,51(r2)
   24858:	10803fcc 	andi	r2,r2,255
   2485c:	10001926 	beq	r2,zero,248c4 <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_+0x9c>
		if(TryLock(_rd_mutex)){
   24860:	e0bffc17 	ldw	r2,-16(fp)
   24864:	10800917 	ldw	r2,36(r2)
   24868:	100b883a 	mov	r5,r2
   2486c:	e13ffc17 	ldw	r4,-16(fp)
   24870:	0023b8c0 	call	23b8c <_ZN20Alf_SharedMemoryComm7TryLockEPv>
   24874:	10803fcc 	andi	r2,r2,255
   24878:	10000f26 	beq	r2,zero,248b8 <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_+0x90>
			std::memcpy((void*)&obj, (void*)addr, size);
   2487c:	e0bfff17 	ldw	r2,-4(fp)
   24880:	10800017 	ldw	r2,0(r2)
   24884:	1007883a 	mov	r3,r2
   24888:	e0bffe17 	ldw	r2,-8(fp)
   2488c:	10800017 	ldw	r2,0(r2)
   24890:	100d883a 	mov	r6,r2
   24894:	180b883a 	mov	r5,r3
   24898:	e13ffd17 	ldw	r4,-12(fp)
   2489c:	002b6ac0 	call	2b6ac <memcpy>
			ReleaseLock(_rd_mutex);
   248a0:	e0bffc17 	ldw	r2,-16(fp)
   248a4:	10800917 	ldw	r2,36(r2)
   248a8:	100b883a 	mov	r5,r2
   248ac:	e13ffc17 	ldw	r4,-16(fp)
   248b0:	0023cb40 	call	23cb4 <_ZN20Alf_SharedMemoryComm11ReleaseLockEPv>
   248b4:	00000506 	br	248cc <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_+0xa4>
		}else
			ret_var = ALF_LOCK_MEMORY_FAILED;
   248b8:	00bfe9c4 	movi	r2,-89
   248bc:	e0bffb15 	stw	r2,-20(fp)
   248c0:	00000206 	br	248cc <_ZN20Alf_SharedMemoryComm12HardwareReadI17Alf_Drive_CommandEE15ALF_ERROR_CODESRT_RKmS6_+0xa4>
	}else
		ret_var = ALF_NO_WELL_FPGABridge_MAPPING;
   248c4:	00bfe984 	movi	r2,-90
   248c8:	e0bffb15 	stw	r2,-20(fp)
	return ret_var;
   248cc:	e0bffb17 	ldw	r2,-20(fp)
}
   248d0:	e037883a 	mov	sp,fp
   248d4:	dfc00117 	ldw	ra,4(sp)
   248d8:	df000017 	ldw	fp,0(sp)
   248dc:	dec00204 	addi	sp,sp,8
   248e0:	f800283a 	ret

000248e4 <_Z10set_tft_dcb>:
#include "lcdfont.hpp"

alt_u8 Display::_currentLine = 0;
alt_u16 Display::_bgcolor = ILI9341_BLACK;

void set_tft_dc(bool bit) {
   248e4:	defffd04 	addi	sp,sp,-12
   248e8:	df000215 	stw	fp,8(sp)
   248ec:	df000204 	addi	fp,sp,8
   248f0:	2005883a 	mov	r2,r4
   248f4:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 i = IORD_8DIRECT(GARFIELD_GPIO_BASE,0);
   248f8:	00801c04 	movi	r2,112
   248fc:	10800023 	ldbuio	r2,0(r2)
   24900:	10803fcc 	andi	r2,r2,255
   24904:	e0bffe05 	stb	r2,-8(fp)
	if(bit == true) {
   24908:	e0bfff03 	ldbu	r2,-4(fp)
   2490c:	10000526 	beq	r2,zero,24924 <_Z10set_tft_dcb+0x40>
		i |= 1 << 7;
   24910:	e0fffe03 	ldbu	r3,-8(fp)
   24914:	00bfe004 	movi	r2,-128
   24918:	1884b03a 	or	r2,r3,r2
   2491c:	e0bffe05 	stb	r2,-8(fp)
   24920:	00000306 	br	24930 <_Z10set_tft_dcb+0x4c>
	}
	else {
		i &= ~(1 << 7);
   24924:	e0bffe03 	ldbu	r2,-8(fp)
   24928:	10801fcc 	andi	r2,r2,127
   2492c:	e0bffe05 	stb	r2,-8(fp)
	}
	IOWR(GARFIELD_GPIO_BASE, 0, i);
   24930:	e0fffe03 	ldbu	r3,-8(fp)
   24934:	00801c04 	movi	r2,112
   24938:	10c00035 	stwio	r3,0(r2)
}
   2493c:	0001883a 	nop
   24940:	e037883a 	mov	sp,fp
   24944:	df000017 	ldw	fp,0(sp)
   24948:	dec00104 	addi	sp,sp,4
   2494c:	f800283a 	ret

00024950 <_Z14spi_write_byteh>:


void spi_write_byte(alt_u8 byte) {
   24950:	defffa04 	addi	sp,sp,-24
   24954:	dfc00515 	stw	ra,20(sp)
   24958:	df000415 	stw	fp,16(sp)
   2495c:	df000404 	addi	fp,sp,16
   24960:	2005883a 	mov	r2,r4
   24964:	e0bfff05 	stb	r2,-4(fp)
	alt_avalon_spi_command(SPI_0_BASE, 0, 1, &byte, 0, NULL, 0);
   24968:	d8000215 	stw	zero,8(sp)
   2496c:	d8000115 	stw	zero,4(sp)
   24970:	d8000015 	stw	zero,0(sp)
   24974:	e1ffff04 	addi	r7,fp,-4
   24978:	01800044 	movi	r6,1
   2497c:	000b883a 	mov	r5,zero
   24980:	01000804 	movi	r4,32
   24984:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
}
   24988:	0001883a 	nop
   2498c:	e037883a 	mov	sp,fp
   24990:	dfc00117 	ldw	ra,4(sp)
   24994:	df000017 	ldw	fp,0(sp)
   24998:	dec00204 	addi	sp,sp,8
   2499c:	f800283a 	ret

000249a0 <_Z8delay_msh>:

void delay_ms(alt_u8 ms) {
   249a0:	defffd04 	addi	sp,sp,-12
   249a4:	df000215 	stw	fp,8(sp)
   249a8:	df000204 	addi	fp,sp,8
   249ac:	2005883a 	mov	r2,r4
   249b0:	e0bfff05 	stb	r2,-4(fp)
	for(volatile alt_u32 i = 0; i < 2000000;i++);
   249b4:	e03ffe15 	stw	zero,-8(fp)
   249b8:	e0fffe17 	ldw	r3,-8(fp)
   249bc:	008007f4 	movhi	r2,31
   249c0:	10a11fc4 	addi	r2,r2,-31617
   249c4:	10c5403a 	cmpgeu	r2,r2,r3
   249c8:	10803fcc 	andi	r2,r2,255
   249cc:	10000426 	beq	r2,zero,249e0 <_Z8delay_msh+0x40>
   249d0:	e0bffe17 	ldw	r2,-8(fp)
   249d4:	10800044 	addi	r2,r2,1
   249d8:	e0bffe15 	stw	r2,-8(fp)
   249dc:	003ff606 	br	249b8 <__reset+0xfff849b8>
}
   249e0:	0001883a 	nop
   249e4:	e037883a 	mov	sp,fp
   249e8:	df000017 	ldw	fp,0(sp)
   249ec:	dec00104 	addi	sp,sp,4
   249f0:	f800283a 	ret

000249f4 <_Z10reversestrPc>:

void reversestr(char s[])
 {
   249f4:	defffa04 	addi	sp,sp,-24
   249f8:	dfc00515 	stw	ra,20(sp)
   249fc:	df000415 	stw	fp,16(sp)
   24a00:	df000404 	addi	fp,sp,16
   24a04:	e13fff15 	stw	r4,-4(fp)
     int i, j;
     char c;

     for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
   24a08:	e03ffc15 	stw	zero,-16(fp)
   24a0c:	e13fff17 	ldw	r4,-4(fp)
   24a10:	002b9f00 	call	2b9f0 <strlen>
   24a14:	10bfffc4 	addi	r2,r2,-1
   24a18:	e0bffd15 	stw	r2,-12(fp)
   24a1c:	e0fffc17 	ldw	r3,-16(fp)
   24a20:	e0bffd17 	ldw	r2,-12(fp)
   24a24:	1880190e 	bge	r3,r2,24a8c <_Z10reversestrPc+0x98>
         c = s[i];
   24a28:	e0bffc17 	ldw	r2,-16(fp)
   24a2c:	e0ffff17 	ldw	r3,-4(fp)
   24a30:	1885883a 	add	r2,r3,r2
   24a34:	10800003 	ldbu	r2,0(r2)
   24a38:	e0bffe05 	stb	r2,-8(fp)
         s[i] = s[j];
   24a3c:	e0bffc17 	ldw	r2,-16(fp)
   24a40:	e0ffff17 	ldw	r3,-4(fp)
   24a44:	1885883a 	add	r2,r3,r2
   24a48:	e0fffd17 	ldw	r3,-12(fp)
   24a4c:	e13fff17 	ldw	r4,-4(fp)
   24a50:	20c7883a 	add	r3,r4,r3
   24a54:	18c00003 	ldbu	r3,0(r3)
   24a58:	10c00005 	stb	r3,0(r2)
         s[j] = c;
   24a5c:	e0bffd17 	ldw	r2,-12(fp)
   24a60:	e0ffff17 	ldw	r3,-4(fp)
   24a64:	1885883a 	add	r2,r3,r2
   24a68:	e0fffe03 	ldbu	r3,-8(fp)
   24a6c:	10c00005 	stb	r3,0(r2)
void reversestr(char s[])
 {
     int i, j;
     char c;

     for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
   24a70:	e0bffc17 	ldw	r2,-16(fp)
   24a74:	10800044 	addi	r2,r2,1
   24a78:	e0bffc15 	stw	r2,-16(fp)
   24a7c:	e0bffd17 	ldw	r2,-12(fp)
   24a80:	10bfffc4 	addi	r2,r2,-1
   24a84:	e0bffd15 	stw	r2,-12(fp)
   24a88:	003fe406 	br	24a1c <__reset+0xfff84a1c>
         c = s[i];
         s[i] = s[j];
         s[j] = c;
     }
 }
   24a8c:	0001883a 	nop
   24a90:	e037883a 	mov	sp,fp
   24a94:	dfc00117 	ldw	ra,4(sp)
   24a98:	df000017 	ldw	fp,0(sp)
   24a9c:	dec00204 	addi	sp,sp,8
   24aa0:	f800283a 	ret

00024aa4 <_Z8itochptriPc>:

void itochptr(int n, char s[])
{
   24aa4:	defff904 	addi	sp,sp,-28
   24aa8:	dfc00615 	stw	ra,24(sp)
   24aac:	df000515 	stw	fp,20(sp)
   24ab0:	dc000415 	stw	r16,16(sp)
   24ab4:	df000504 	addi	fp,sp,20
   24ab8:	e13ffd15 	stw	r4,-12(fp)
   24abc:	e17ffe15 	stw	r5,-8(fp)
	int i, sign;

	if ((sign = n) < 0)  /* record sign */
   24ac0:	e0bffd17 	ldw	r2,-12(fp)
   24ac4:	e0bffc15 	stw	r2,-16(fp)
   24ac8:	e0bffc17 	ldw	r2,-16(fp)
   24acc:	1004d7fa 	srli	r2,r2,31
   24ad0:	10803fcc 	andi	r2,r2,255
   24ad4:	10000326 	beq	r2,zero,24ae4 <_Z8itochptriPc+0x40>
		n = -n;          /* make n positive */
   24ad8:	e0bffd17 	ldw	r2,-12(fp)
   24adc:	0085c83a 	sub	r2,zero,r2
   24ae0:	e0bffd15 	stw	r2,-12(fp)
	i = 0;
   24ae4:	e03ffb15 	stw	zero,-20(fp)
	do {       /* generate digits in reverse order */
		s[i++] = n % 10 + '0';   /* get next digit */
   24ae8:	e0bffb17 	ldw	r2,-20(fp)
   24aec:	10c00044 	addi	r3,r2,1
   24af0:	e0fffb15 	stw	r3,-20(fp)
   24af4:	1007883a 	mov	r3,r2
   24af8:	e0bffe17 	ldw	r2,-8(fp)
   24afc:	10e1883a 	add	r16,r2,r3
   24b00:	e0bffd17 	ldw	r2,-12(fp)
   24b04:	01400284 	movi	r5,10
   24b08:	1009883a 	mov	r4,r2
   24b0c:	0027d780 	call	27d78 <__modsi3>
   24b10:	10800c04 	addi	r2,r2,48
   24b14:	80800005 	stb	r2,0(r16)
	int i, sign;

	if ((sign = n) < 0)  /* record sign */
		n = -n;          /* make n positive */
	i = 0;
	do {       /* generate digits in reverse order */
   24b18:	e0bffd17 	ldw	r2,-12(fp)
   24b1c:	01400284 	movi	r5,10
   24b20:	1009883a 	mov	r4,r2
   24b24:	0027cf40 	call	27cf4 <__divsi3>
   24b28:	e0bffd15 	stw	r2,-12(fp)
   24b2c:	e0bffd17 	ldw	r2,-12(fp)
   24b30:	0084803a 	cmplt	r2,zero,r2
   24b34:	10803fcc 	andi	r2,r2,255
   24b38:	10000126 	beq	r2,zero,24b40 <_Z8itochptriPc+0x9c>
   24b3c:	003fea06 	br	24ae8 <__reset+0xfff84ae8>
		s[i++] = n % 10 + '0';   /* get next digit */
	} while ((n /= 10) > 0);     /* delete it */
	if (sign < 0)
   24b40:	e0bffc17 	ldw	r2,-16(fp)
   24b44:	1000080e 	bge	r2,zero,24b68 <_Z8itochptriPc+0xc4>
		s[i++] = '-';
   24b48:	e0bffb17 	ldw	r2,-20(fp)
   24b4c:	10c00044 	addi	r3,r2,1
   24b50:	e0fffb15 	stw	r3,-20(fp)
   24b54:	1007883a 	mov	r3,r2
   24b58:	e0bffe17 	ldw	r2,-8(fp)
   24b5c:	10c5883a 	add	r2,r2,r3
   24b60:	00c00b44 	movi	r3,45
   24b64:	10c00005 	stb	r3,0(r2)
	s[i] = '\0';
   24b68:	e0bffb17 	ldw	r2,-20(fp)
   24b6c:	e0fffe17 	ldw	r3,-8(fp)
   24b70:	1885883a 	add	r2,r3,r2
   24b74:	10000005 	stb	zero,0(r2)
	reversestr(s);
   24b78:	e13ffe17 	ldw	r4,-8(fp)
   24b7c:	00249f40 	call	249f4 <_Z10reversestrPc>
}
   24b80:	0001883a 	nop
   24b84:	e6ffff04 	addi	sp,fp,-4
   24b88:	dfc00217 	ldw	ra,8(sp)
   24b8c:	df000117 	ldw	fp,4(sp)
   24b90:	dc000017 	ldw	r16,0(sp)
   24b94:	dec00304 	addi	sp,sp,12
   24b98:	f800283a 	ret

00024b9c <_ZN7DisplayC1Ess>:


Display::Display(alt_16 width, alt_16 height) {
   24b9c:	defffc04 	addi	sp,sp,-16
   24ba0:	df000315 	stw	fp,12(sp)
   24ba4:	df000304 	addi	fp,sp,12
   24ba8:	e13ffd15 	stw	r4,-12(fp)
   24bac:	2807883a 	mov	r3,r5
   24bb0:	3005883a 	mov	r2,r6
   24bb4:	e0fffe0d 	sth	r3,-8(fp)
   24bb8:	e0bfff0d 	sth	r2,-4(fp)
	_width = width;
   24bbc:	e0bffd17 	ldw	r2,-12(fp)
   24bc0:	e0fffe0b 	ldhu	r3,-8(fp)
   24bc4:	10c0000d 	sth	r3,0(r2)
	_height = height;
   24bc8:	e0bffd17 	ldw	r2,-12(fp)
   24bcc:	e0ffff0b 	ldhu	r3,-4(fp)
   24bd0:	10c0008d 	sth	r3,2(r2)
	_cp437 = false;
   24bd4:	e0bffd17 	ldw	r2,-12(fp)
   24bd8:	10000145 	stb	zero,5(r2)
	_rotation = 0;
   24bdc:	e0bffd17 	ldw	r2,-12(fp)
   24be0:	10000105 	stb	zero,4(r2)
	_currentLine = 0;
   24be4:	d0202b05 	stb	zero,-32596(gp)
	_bgcolor = ILI9341_BLACK;
   24be8:	d0202b8d 	sth	zero,-32594(gp)
}
   24bec:	0001883a 	nop
   24bf0:	e037883a 	mov	sp,fp
   24bf4:	df000017 	ldw	fp,0(sp)
   24bf8:	dec00104 	addi	sp,sp,4
   24bfc:	f800283a 	ret

00024c00 <_ZN7Display4initEt>:

void Display::init(alt_u16 bgcolor) {
   24c00:	defffc04 	addi	sp,sp,-16
   24c04:	dfc00315 	stw	ra,12(sp)
   24c08:	df000215 	stw	fp,8(sp)
   24c0c:	df000204 	addi	fp,sp,8
   24c10:	e13ffe15 	stw	r4,-8(fp)
   24c14:	2805883a 	mov	r2,r5
   24c18:	e0bfff0d 	sth	r2,-4(fp)
	//TO DO: TOGGLE RESET

	writecommand(0xEF);
   24c1c:	01403bc4 	movi	r5,239
   24c20:	e13ffe17 	ldw	r4,-8(fp)
   24c24:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x03);
   24c28:	014000c4 	movi	r5,3
   24c2c:	e13ffe17 	ldw	r4,-8(fp)
   24c30:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x80);
   24c34:	01402004 	movi	r5,128
   24c38:	e13ffe17 	ldw	r4,-8(fp)
   24c3c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x02);
   24c40:	01400084 	movi	r5,2
   24c44:	e13ffe17 	ldw	r4,-8(fp)
   24c48:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xCF);
   24c4c:	014033c4 	movi	r5,207
   24c50:	e13ffe17 	ldw	r4,-8(fp)
   24c54:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x00);
   24c58:	000b883a 	mov	r5,zero
   24c5c:	e13ffe17 	ldw	r4,-8(fp)
   24c60:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0XC1);
   24c64:	01403044 	movi	r5,193
   24c68:	e13ffe17 	ldw	r4,-8(fp)
   24c6c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0X30);
   24c70:	01400c04 	movi	r5,48
   24c74:	e13ffe17 	ldw	r4,-8(fp)
   24c78:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xED);
   24c7c:	01403b44 	movi	r5,237
   24c80:	e13ffe17 	ldw	r4,-8(fp)
   24c84:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x64);
   24c88:	01401904 	movi	r5,100
   24c8c:	e13ffe17 	ldw	r4,-8(fp)
   24c90:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x03);
   24c94:	014000c4 	movi	r5,3
   24c98:	e13ffe17 	ldw	r4,-8(fp)
   24c9c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0X12);
   24ca0:	01400484 	movi	r5,18
   24ca4:	e13ffe17 	ldw	r4,-8(fp)
   24ca8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0X81);
   24cac:	01402044 	movi	r5,129
   24cb0:	e13ffe17 	ldw	r4,-8(fp)
   24cb4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xE8);
   24cb8:	01403a04 	movi	r5,232
   24cbc:	e13ffe17 	ldw	r4,-8(fp)
   24cc0:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x85);
   24cc4:	01402144 	movi	r5,133
   24cc8:	e13ffe17 	ldw	r4,-8(fp)
   24ccc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x00);
   24cd0:	000b883a 	mov	r5,zero
   24cd4:	e13ffe17 	ldw	r4,-8(fp)
   24cd8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x78);
   24cdc:	01401e04 	movi	r5,120
   24ce0:	e13ffe17 	ldw	r4,-8(fp)
   24ce4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xCB);
   24ce8:	014032c4 	movi	r5,203
   24cec:	e13ffe17 	ldw	r4,-8(fp)
   24cf0:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x39);
   24cf4:	01400e44 	movi	r5,57
   24cf8:	e13ffe17 	ldw	r4,-8(fp)
   24cfc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x2C);
   24d00:	01400b04 	movi	r5,44
   24d04:	e13ffe17 	ldw	r4,-8(fp)
   24d08:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x00);
   24d0c:	000b883a 	mov	r5,zero
   24d10:	e13ffe17 	ldw	r4,-8(fp)
   24d14:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x34);
   24d18:	01400d04 	movi	r5,52
   24d1c:	e13ffe17 	ldw	r4,-8(fp)
   24d20:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x02);
   24d24:	01400084 	movi	r5,2
   24d28:	e13ffe17 	ldw	r4,-8(fp)
   24d2c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xF7);
   24d30:	01403dc4 	movi	r5,247
   24d34:	e13ffe17 	ldw	r4,-8(fp)
   24d38:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x20);
   24d3c:	01400804 	movi	r5,32
   24d40:	e13ffe17 	ldw	r4,-8(fp)
   24d44:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xEA);
   24d48:	01403a84 	movi	r5,234
   24d4c:	e13ffe17 	ldw	r4,-8(fp)
   24d50:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x00);
   24d54:	000b883a 	mov	r5,zero
   24d58:	e13ffe17 	ldw	r4,-8(fp)
   24d5c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x00);
   24d60:	000b883a 	mov	r5,zero
   24d64:	e13ffe17 	ldw	r4,-8(fp)
   24d68:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_PWCTR1);    //Power control
   24d6c:	01403004 	movi	r5,192
   24d70:	e13ffe17 	ldw	r4,-8(fp)
   24d74:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x23);   //VRH[5:0]
   24d78:	014008c4 	movi	r5,35
   24d7c:	e13ffe17 	ldw	r4,-8(fp)
   24d80:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_PWCTR2);    //Power control
   24d84:	01403044 	movi	r5,193
   24d88:	e13ffe17 	ldw	r4,-8(fp)
   24d8c:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x10);   //SAP[2:0];BT[3:0]
   24d90:	01400404 	movi	r5,16
   24d94:	e13ffe17 	ldw	r4,-8(fp)
   24d98:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_VMCTR1);    //VCM control
   24d9c:	01403144 	movi	r5,197
   24da0:	e13ffe17 	ldw	r4,-8(fp)
   24da4:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x3e);
   24da8:	01400f84 	movi	r5,62
   24dac:	e13ffe17 	ldw	r4,-8(fp)
   24db0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x28);
   24db4:	01400a04 	movi	r5,40
   24db8:	e13ffe17 	ldw	r4,-8(fp)
   24dbc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_VMCTR2);    //VCM control2
   24dc0:	014031c4 	movi	r5,199
   24dc4:	e13ffe17 	ldw	r4,-8(fp)
   24dc8:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x86);
   24dcc:	01402184 	movi	r5,134
   24dd0:	e13ffe17 	ldw	r4,-8(fp)
   24dd4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_MADCTL);    // Memory Access Control
   24dd8:	01400d84 	movi	r5,54
   24ddc:	e13ffe17 	ldw	r4,-8(fp)
   24de0:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x48);
   24de4:	01401204 	movi	r5,72
   24de8:	e13ffe17 	ldw	r4,-8(fp)
   24dec:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_PIXFMT);
   24df0:	01400e84 	movi	r5,58
   24df4:	e13ffe17 	ldw	r4,-8(fp)
   24df8:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x55);
   24dfc:	01401544 	movi	r5,85
   24e00:	e13ffe17 	ldw	r4,-8(fp)
   24e04:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_FRMCTR1);
   24e08:	01402c44 	movi	r5,177
   24e0c:	e13ffe17 	ldw	r4,-8(fp)
   24e10:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x00);
   24e14:	000b883a 	mov	r5,zero
   24e18:	e13ffe17 	ldw	r4,-8(fp)
   24e1c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x18);
   24e20:	01400604 	movi	r5,24
   24e24:	e13ffe17 	ldw	r4,-8(fp)
   24e28:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_DFUNCTR);    // Display Function Control
   24e2c:	01402d84 	movi	r5,182
   24e30:	e13ffe17 	ldw	r4,-8(fp)
   24e34:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x08);
   24e38:	01400204 	movi	r5,8
   24e3c:	e13ffe17 	ldw	r4,-8(fp)
   24e40:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x82);
   24e44:	01402084 	movi	r5,130
   24e48:	e13ffe17 	ldw	r4,-8(fp)
   24e4c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x27);
   24e50:	014009c4 	movi	r5,39
   24e54:	e13ffe17 	ldw	r4,-8(fp)
   24e58:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(0xF2);    // 3Gamma Function Disable
   24e5c:	01403c84 	movi	r5,242
   24e60:	e13ffe17 	ldw	r4,-8(fp)
   24e64:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x00);
   24e68:	000b883a 	mov	r5,zero
   24e6c:	e13ffe17 	ldw	r4,-8(fp)
   24e70:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_GAMMASET);    //Gamma curve selected
   24e74:	01400984 	movi	r5,38
   24e78:	e13ffe17 	ldw	r4,-8(fp)
   24e7c:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x01);
   24e80:	01400044 	movi	r5,1
   24e84:	e13ffe17 	ldw	r4,-8(fp)
   24e88:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_GMCTRP1);    //Set Gamma
   24e8c:	01403804 	movi	r5,224
   24e90:	e13ffe17 	ldw	r4,-8(fp)
   24e94:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x0F);
   24e98:	014003c4 	movi	r5,15
   24e9c:	e13ffe17 	ldw	r4,-8(fp)
   24ea0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x31);
   24ea4:	01400c44 	movi	r5,49
   24ea8:	e13ffe17 	ldw	r4,-8(fp)
   24eac:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x2B);
   24eb0:	01400ac4 	movi	r5,43
   24eb4:	e13ffe17 	ldw	r4,-8(fp)
   24eb8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0C);
   24ebc:	01400304 	movi	r5,12
   24ec0:	e13ffe17 	ldw	r4,-8(fp)
   24ec4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0E);
   24ec8:	01400384 	movi	r5,14
   24ecc:	e13ffe17 	ldw	r4,-8(fp)
   24ed0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x08);
   24ed4:	01400204 	movi	r5,8
   24ed8:	e13ffe17 	ldw	r4,-8(fp)
   24edc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x4E);
   24ee0:	01401384 	movi	r5,78
   24ee4:	e13ffe17 	ldw	r4,-8(fp)
   24ee8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0xF1);
   24eec:	01403c44 	movi	r5,241
   24ef0:	e13ffe17 	ldw	r4,-8(fp)
   24ef4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x37);
   24ef8:	01400dc4 	movi	r5,55
   24efc:	e13ffe17 	ldw	r4,-8(fp)
   24f00:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x07);
   24f04:	014001c4 	movi	r5,7
   24f08:	e13ffe17 	ldw	r4,-8(fp)
   24f0c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x10);
   24f10:	01400404 	movi	r5,16
   24f14:	e13ffe17 	ldw	r4,-8(fp)
   24f18:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x03);
   24f1c:	014000c4 	movi	r5,3
   24f20:	e13ffe17 	ldw	r4,-8(fp)
   24f24:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0E);
   24f28:	01400384 	movi	r5,14
   24f2c:	e13ffe17 	ldw	r4,-8(fp)
   24f30:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x09);
   24f34:	01400244 	movi	r5,9
   24f38:	e13ffe17 	ldw	r4,-8(fp)
   24f3c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x00);
   24f40:	000b883a 	mov	r5,zero
   24f44:	e13ffe17 	ldw	r4,-8(fp)
   24f48:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_GMCTRN1);    //Set Gamma
   24f4c:	01403844 	movi	r5,225
   24f50:	e13ffe17 	ldw	r4,-8(fp)
   24f54:	00250600 	call	25060 <_ZN7Display12writecommandEh>
		writedata(0x00);
   24f58:	000b883a 	mov	r5,zero
   24f5c:	e13ffe17 	ldw	r4,-8(fp)
   24f60:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0E);
   24f64:	01400384 	movi	r5,14
   24f68:	e13ffe17 	ldw	r4,-8(fp)
   24f6c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x14);
   24f70:	01400504 	movi	r5,20
   24f74:	e13ffe17 	ldw	r4,-8(fp)
   24f78:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x03);
   24f7c:	014000c4 	movi	r5,3
   24f80:	e13ffe17 	ldw	r4,-8(fp)
   24f84:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x11);
   24f88:	01400444 	movi	r5,17
   24f8c:	e13ffe17 	ldw	r4,-8(fp)
   24f90:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x07);
   24f94:	014001c4 	movi	r5,7
   24f98:	e13ffe17 	ldw	r4,-8(fp)
   24f9c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x31);
   24fa0:	01400c44 	movi	r5,49
   24fa4:	e13ffe17 	ldw	r4,-8(fp)
   24fa8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0xC1);
   24fac:	01403044 	movi	r5,193
   24fb0:	e13ffe17 	ldw	r4,-8(fp)
   24fb4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x48);
   24fb8:	01401204 	movi	r5,72
   24fbc:	e13ffe17 	ldw	r4,-8(fp)
   24fc0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x08);
   24fc4:	01400204 	movi	r5,8
   24fc8:	e13ffe17 	ldw	r4,-8(fp)
   24fcc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0F);
   24fd0:	014003c4 	movi	r5,15
   24fd4:	e13ffe17 	ldw	r4,-8(fp)
   24fd8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0C);
   24fdc:	01400304 	movi	r5,12
   24fe0:	e13ffe17 	ldw	r4,-8(fp)
   24fe4:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x31);
   24fe8:	01400c44 	movi	r5,49
   24fec:	e13ffe17 	ldw	r4,-8(fp)
   24ff0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x36);
   24ff4:	01400d84 	movi	r5,54
   24ff8:	e13ffe17 	ldw	r4,-8(fp)
   24ffc:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
		writedata(0x0F);
   25000:	014003c4 	movi	r5,15
   25004:	e13ffe17 	ldw	r4,-8(fp)
   25008:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_SLPOUT);    //Exit Sleep
   2500c:	01400444 	movi	r5,17
   25010:	e13ffe17 	ldw	r4,-8(fp)
   25014:	00250600 	call	25060 <_ZN7Display12writecommandEh>


	delay_ms(120);
   25018:	01001e04 	movi	r4,120
   2501c:	00249a00 	call	249a0 <_Z8delay_msh>


	writecommand(ILI9341_DISPON);    //Display on
   25020:	01400a44 	movi	r5,41
   25024:	e13ffe17 	ldw	r4,-8(fp)
   25028:	00250600 	call	25060 <_ZN7Display12writecommandEh>

	_bgcolor = bgcolor;
   2502c:	e0bfff0b 	ldhu	r2,-4(fp)
   25030:	d0a02b8d 	sth	r2,-32594(gp)

	fillScreen(_bgcolor);
   25034:	d0a02b8b 	ldhu	r2,-32594(gp)
   25038:	10bfffcc 	andi	r2,r2,65535
   2503c:	100b883a 	mov	r5,r2
   25040:	e13ffe17 	ldw	r4,-8(fp)
   25044:	002596c0 	call	2596c <_ZN7Display10fillScreenEt>
}
   25048:	0001883a 	nop
   2504c:	e037883a 	mov	sp,fp
   25050:	dfc00117 	ldw	ra,4(sp)
   25054:	df000017 	ldw	fp,0(sp)
   25058:	dec00204 	addi	sp,sp,8
   2505c:	f800283a 	ret

00025060 <_ZN7Display12writecommandEh>:

void Display::writecommand(alt_u8 c) {
   25060:	defffc04 	addi	sp,sp,-16
   25064:	dfc00315 	stw	ra,12(sp)
   25068:	df000215 	stw	fp,8(sp)
   2506c:	df000204 	addi	fp,sp,8
   25070:	e13ffe15 	stw	r4,-8(fp)
   25074:	2805883a 	mov	r2,r5
   25078:	e0bfff05 	stb	r2,-4(fp)
	set_tft_dc(false);
   2507c:	0009883a 	mov	r4,zero
   25080:	00248e40 	call	248e4 <_Z10set_tft_dcb>

	spi_write_byte(c);
   25084:	e0bfff03 	ldbu	r2,-4(fp)
   25088:	1009883a 	mov	r4,r2
   2508c:	00249500 	call	24950 <_Z14spi_write_byteh>
}
   25090:	0001883a 	nop
   25094:	e037883a 	mov	sp,fp
   25098:	dfc00117 	ldw	ra,4(sp)
   2509c:	df000017 	ldw	fp,0(sp)
   250a0:	dec00204 	addi	sp,sp,8
   250a4:	f800283a 	ret

000250a8 <_ZN7Display9writedataEh>:

void Display::writedata(alt_u8 c) {
   250a8:	defffc04 	addi	sp,sp,-16
   250ac:	dfc00315 	stw	ra,12(sp)
   250b0:	df000215 	stw	fp,8(sp)
   250b4:	df000204 	addi	fp,sp,8
   250b8:	e13ffe15 	stw	r4,-8(fp)
   250bc:	2805883a 	mov	r2,r5
   250c0:	e0bfff05 	stb	r2,-4(fp)
	set_tft_dc(true);
   250c4:	01000044 	movi	r4,1
   250c8:	00248e40 	call	248e4 <_Z10set_tft_dcb>

	spi_write_byte(c);
   250cc:	e0bfff03 	ldbu	r2,-4(fp)
   250d0:	1009883a 	mov	r4,r2
   250d4:	00249500 	call	24950 <_Z14spi_write_byteh>
}
   250d8:	0001883a 	nop
   250dc:	e037883a 	mov	sp,fp
   250e0:	dfc00117 	ldw	ra,4(sp)
   250e4:	df000017 	ldw	fp,0(sp)
   250e8:	dec00204 	addi	sp,sp,8
   250ec:	f800283a 	ret

000250f0 <_ZN7Display9drawPixelEsst>:

void Display::drawPixel(alt_16 x, alt_16 y, alt_u16 color) {
   250f0:	defff904 	addi	sp,sp,-28
   250f4:	dfc00615 	stw	ra,24(sp)
   250f8:	df000515 	stw	fp,20(sp)
   250fc:	df000504 	addi	fp,sp,20
   25100:	e13ffc15 	stw	r4,-16(fp)
   25104:	2809883a 	mov	r4,r5
   25108:	3007883a 	mov	r3,r6
   2510c:	3805883a 	mov	r2,r7
   25110:	e13ffd0d 	sth	r4,-12(fp)
   25114:	e0fffe0d 	sth	r3,-8(fp)
   25118:	e0bfff0d 	sth	r2,-4(fp)
	if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
   2511c:	e0bffd0f 	ldh	r2,-12(fp)
   25120:	10002c16 	blt	r2,zero,251d4 <_ZN7Display9drawPixelEsst+0xe4>
   25124:	e0bffc17 	ldw	r2,-16(fp)
   25128:	1080000b 	ldhu	r2,0(r2)
   2512c:	10bfffcc 	andi	r2,r2,65535
   25130:	10a0001c 	xori	r2,r2,32768
   25134:	10a00004 	addi	r2,r2,-32768
   25138:	e0fffd0f 	ldh	r3,-12(fp)
   2513c:	1880250e 	bge	r3,r2,251d4 <_ZN7Display9drawPixelEsst+0xe4>
   25140:	e0bffe0f 	ldh	r2,-8(fp)
   25144:	10002316 	blt	r2,zero,251d4 <_ZN7Display9drawPixelEsst+0xe4>
   25148:	e0bffc17 	ldw	r2,-16(fp)
   2514c:	1080008b 	ldhu	r2,2(r2)
   25150:	10bfffcc 	andi	r2,r2,65535
   25154:	10a0001c 	xori	r2,r2,32768
   25158:	10a00004 	addi	r2,r2,-32768
   2515c:	e0fffe0f 	ldh	r3,-8(fp)
   25160:	18801c0e 	bge	r3,r2,251d4 <_ZN7Display9drawPixelEsst+0xe4>

	setAddrWindow(x,y,x+1,y+1);
   25164:	e0bffd0b 	ldhu	r2,-12(fp)
   25168:	10ffffcc 	andi	r3,r2,65535
   2516c:	e0bffe0b 	ldhu	r2,-8(fp)
   25170:	113fffcc 	andi	r4,r2,65535
   25174:	e0bffd0b 	ldhu	r2,-12(fp)
   25178:	10800044 	addi	r2,r2,1
   2517c:	117fffcc 	andi	r5,r2,65535
   25180:	e0bffe0b 	ldhu	r2,-8(fp)
   25184:	10800044 	addi	r2,r2,1
   25188:	10bfffcc 	andi	r2,r2,65535
   2518c:	d8800015 	stw	r2,0(sp)
   25190:	280f883a 	mov	r7,r5
   25194:	200d883a 	mov	r6,r4
   25198:	180b883a 	mov	r5,r3
   2519c:	e13ffc17 	ldw	r4,-16(fp)
   251a0:	0025bb80 	call	25bb8 <_ZN7Display13setAddrWindowEtttt>


	set_tft_dc(true);
   251a4:	01000044 	movi	r4,1
   251a8:	00248e40 	call	248e4 <_Z10set_tft_dcb>

	spi_write_byte(color >> 8);
   251ac:	e0bfff0b 	ldhu	r2,-4(fp)
   251b0:	1004d23a 	srli	r2,r2,8
   251b4:	10bfffcc 	andi	r2,r2,65535
   251b8:	1009883a 	mov	r4,r2
   251bc:	00249500 	call	24950 <_Z14spi_write_byteh>
	spi_write_byte(color);
   251c0:	e0bfff0b 	ldhu	r2,-4(fp)
   251c4:	10803fcc 	andi	r2,r2,255
   251c8:	1009883a 	mov	r4,r2
   251cc:	00249500 	call	24950 <_Z14spi_write_byteh>
   251d0:	00000106 	br	251d8 <_ZN7Display9drawPixelEsst+0xe8>

	spi_write_byte(c);
}

void Display::drawPixel(alt_16 x, alt_16 y, alt_u16 color) {
	if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
   251d4:	0001883a 	nop

	set_tft_dc(true);

	spi_write_byte(color >> 8);
	spi_write_byte(color);
}
   251d8:	e037883a 	mov	sp,fp
   251dc:	dfc00117 	ldw	ra,4(sp)
   251e0:	df000017 	ldw	fp,0(sp)
   251e4:	dec00204 	addi	sp,sp,8
   251e8:	f800283a 	ret

000251ec <_ZN7Display8drawCharEsshtth>:

void Display::drawChar(alt_16 x, alt_16 y, unsigned char c, alt_u16 color, alt_u16 bg, alt_u8 size) {
   251ec:	defff404 	addi	sp,sp,-48
   251f0:	dfc00b15 	stw	ra,44(sp)
   251f4:	df000a15 	stw	fp,40(sp)
   251f8:	df000a04 	addi	fp,sp,40
   251fc:	e13ff915 	stw	r4,-28(fp)
   25200:	2811883a 	mov	r8,r5
   25204:	380b883a 	mov	r5,r7
   25208:	e1000217 	ldw	r4,8(fp)
   2520c:	e0c00317 	ldw	r3,12(fp)
   25210:	e0800417 	ldw	r2,16(fp)
   25214:	e23ffa0d 	sth	r8,-24(fp)
   25218:	e1bffb0d 	sth	r6,-20(fp)
   2521c:	e17ffc05 	stb	r5,-16(fp)
   25220:	e13ffd0d 	sth	r4,-12(fp)
   25224:	e0fffe0d 	sth	r3,-8(fp)
   25228:	e0bfff05 	stb	r2,-4(fp)
	if((x >= _width)            || // Clip right
   2522c:	e0bff917 	ldw	r2,-28(fp)
   25230:	1080000b 	ldhu	r2,0(r2)
   25234:	10bfffcc 	andi	r2,r2,65535
   25238:	10a0001c 	xori	r2,r2,32768
   2523c:	10a00004 	addi	r2,r2,-32768
   25240:	e0fffa0f 	ldh	r3,-24(fp)
   25244:	1880aa0e 	bge	r3,r2,254f0 <_ZN7Display8drawCharEsshtth+0x304>
			(y >= _height)           || // Clip bottom
   25248:	e0bff917 	ldw	r2,-28(fp)
   2524c:	1080008b 	ldhu	r2,2(r2)
	spi_write_byte(color >> 8);
	spi_write_byte(color);
}

void Display::drawChar(alt_16 x, alt_16 y, unsigned char c, alt_u16 color, alt_u16 bg, alt_u8 size) {
	if((x >= _width)            || // Clip right
   25250:	10bfffcc 	andi	r2,r2,65535
   25254:	10a0001c 	xori	r2,r2,32768
   25258:	10a00004 	addi	r2,r2,-32768
   2525c:	e0fffb0f 	ldh	r3,-20(fp)
   25260:	1880a30e 	bge	r3,r2,254f0 <_ZN7Display8drawCharEsshtth+0x304>
			(y >= _height)           || // Clip bottom
			((x + CHARSIZE_WIDTH * size - 1) < 0) || // Clip left
   25264:	e0fffa0f 	ldh	r3,-24(fp)
   25268:	e0bfff03 	ldbu	r2,-4(fp)
   2526c:	108001a4 	muli	r2,r2,6
   25270:	1885883a 	add	r2,r3,r2
   25274:	10bfffc4 	addi	r2,r2,-1
	spi_write_byte(color);
}

void Display::drawChar(alt_16 x, alt_16 y, unsigned char c, alt_u16 color, alt_u16 bg, alt_u8 size) {
	if((x >= _width)            || // Clip right
			(y >= _height)           || // Clip bottom
   25278:	10009d16 	blt	r2,zero,254f0 <_ZN7Display8drawCharEsshtth+0x304>
			((x + CHARSIZE_WIDTH * size - 1) < 0) || // Clip left
			((y + CHARSIZE_HEIGHT * size - 1) < 0))   // Clip top
   2527c:	e0fffb0f 	ldh	r3,-20(fp)
   25280:	e0bfff03 	ldbu	r2,-4(fp)
   25284:	100490fa 	slli	r2,r2,3
   25288:	1885883a 	add	r2,r3,r2
   2528c:	10bfffc4 	addi	r2,r2,-1
}

void Display::drawChar(alt_16 x, alt_16 y, unsigned char c, alt_u16 color, alt_u16 bg, alt_u8 size) {
	if((x >= _width)            || // Clip right
			(y >= _height)           || // Clip bottom
			((x + CHARSIZE_WIDTH * size - 1) < 0) || // Clip left
   25290:	10009716 	blt	r2,zero,254f0 <_ZN7Display8drawCharEsshtth+0x304>
			((y + CHARSIZE_HEIGHT * size - 1) < 0))   // Clip top
		return;

	if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
   25294:	e0bff917 	ldw	r2,-28(fp)
   25298:	10800143 	ldbu	r2,5(r2)
   2529c:	1080005c 	xori	r2,r2,1
   252a0:	10803fcc 	andi	r2,r2,255
   252a4:	10000626 	beq	r2,zero,252c0 <_ZN7Display8drawCharEsshtth+0xd4>
   252a8:	e0bffc03 	ldbu	r2,-16(fp)
   252ac:	10802c30 	cmpltui	r2,r2,176
   252b0:	1000031e 	bne	r2,zero,252c0 <_ZN7Display8drawCharEsshtth+0xd4>
   252b4:	e0bffc03 	ldbu	r2,-16(fp)
   252b8:	10800044 	addi	r2,r2,1
   252bc:	e0bffc05 	stb	r2,-16(fp)

	for(alt_8 i=0; i<CHARSIZE_WIDTH; i++ ) {
   252c0:	e03ff805 	stb	zero,-32(fp)
   252c4:	e0bff807 	ldb	r2,-32(fp)
   252c8:	10800188 	cmpgei	r2,r2,6
   252cc:	1000891e 	bne	r2,zero,254f4 <_ZN7Display8drawCharEsshtth+0x308>
		alt_u8 line;
		if(i < (CHARSIZE_WIDTH-1)) line = font[(c*(CHARSIZE_WIDTH-1))+i];
   252d0:	e0bff807 	ldb	r2,-32(fp)
   252d4:	10800148 	cmpgei	r2,r2,5
   252d8:	10000a1e 	bne	r2,zero,25304 <_ZN7Display8drawCharEsshtth+0x118>
   252dc:	e0bffc03 	ldbu	r2,-16(fp)
   252e0:	10c00164 	muli	r3,r2,5
   252e4:	e0bff807 	ldb	r2,-32(fp)
   252e8:	1887883a 	add	r3,r3,r2
   252ec:	008000f4 	movhi	r2,3
   252f0:	108a6144 	addi	r2,r2,10629
   252f4:	10c5883a 	add	r2,r2,r3
   252f8:	10800003 	ldbu	r2,0(r2)
   252fc:	e0bff845 	stb	r2,-31(fp)
   25300:	00000106 	br	25308 <_ZN7Display8drawCharEsshtth+0x11c>
		else      line = 0x0;
   25304:	e03ff845 	stb	zero,-31(fp)
		for(alt_8 j=0; j<CHARSIZE_HEIGHT; j++, line >>= 1) {
   25308:	e03ff885 	stb	zero,-30(fp)
   2530c:	e0bff887 	ldb	r2,-30(fp)
   25310:	10800208 	cmpgei	r2,r2,8
   25314:	1000721e 	bne	r2,zero,254e0 <_ZN7Display8drawCharEsshtth+0x2f4>
			if(line & 0x1) {
   25318:	e0bff843 	ldbu	r2,-31(fp)
   2531c:	1080004c 	andi	r2,r2,1
   25320:	10003326 	beq	r2,zero,253f0 <_ZN7Display8drawCharEsshtth+0x204>
				if(size == 1) drawPixel(x+i, y+j, color);
   25324:	e0bfff03 	ldbu	r2,-4(fp)
   25328:	10800058 	cmpnei	r2,r2,1
   2532c:	1000131e 	bne	r2,zero,2537c <_ZN7Display8drawCharEsshtth+0x190>
   25330:	e0fff807 	ldb	r3,-32(fp)
   25334:	e0bffa0b 	ldhu	r2,-24(fp)
   25338:	1885883a 	add	r2,r3,r2
   2533c:	113fffcc 	andi	r4,r2,65535
   25340:	2120001c 	xori	r4,r4,32768
   25344:	21200004 	addi	r4,r4,-32768
   25348:	e0fff887 	ldb	r3,-30(fp)
   2534c:	e0bffb0b 	ldhu	r2,-20(fp)
   25350:	1885883a 	add	r2,r3,r2
   25354:	10bfffcc 	andi	r2,r2,65535
   25358:	10a0001c 	xori	r2,r2,32768
   2535c:	10a00004 	addi	r2,r2,-32768
   25360:	e0fffd0b 	ldhu	r3,-12(fp)
   25364:	180f883a 	mov	r7,r3
   25368:	100d883a 	mov	r6,r2
   2536c:	200b883a 	mov	r5,r4
   25370:	e13ff917 	ldw	r4,-28(fp)
   25374:	00250f00 	call	250f0 <_ZN7Display9drawPixelEsst>
   25378:	00005206 	br	254c4 <_ZN7Display8drawCharEsshtth+0x2d8>
				else          fillRect(x+(i*size), y+(j*size), size, size, color);
   2537c:	e0fff807 	ldb	r3,-32(fp)
   25380:	e0bfff03 	ldbu	r2,-4(fp)
   25384:	1885383a 	mul	r2,r3,r2
   25388:	1007883a 	mov	r3,r2
   2538c:	e0bffa0b 	ldhu	r2,-24(fp)
   25390:	1885883a 	add	r2,r3,r2
   25394:	113fffcc 	andi	r4,r2,65535
   25398:	2120001c 	xori	r4,r4,32768
   2539c:	21200004 	addi	r4,r4,-32768
   253a0:	e0fff887 	ldb	r3,-30(fp)
   253a4:	e0bfff03 	ldbu	r2,-4(fp)
   253a8:	1885383a 	mul	r2,r3,r2
   253ac:	1007883a 	mov	r3,r2
   253b0:	e0bffb0b 	ldhu	r2,-20(fp)
   253b4:	1885883a 	add	r2,r3,r2
   253b8:	117fffcc 	andi	r5,r2,65535
   253bc:	2960001c 	xori	r5,r5,32768
   253c0:	29600004 	addi	r5,r5,-32768
   253c4:	e1bfff03 	ldbu	r6,-4(fp)
   253c8:	e0bfff03 	ldbu	r2,-4(fp)
   253cc:	e0fffd0b 	ldhu	r3,-12(fp)
   253d0:	d8c00115 	stw	r3,4(sp)
   253d4:	d8800015 	stw	r2,0(sp)
   253d8:	300f883a 	mov	r7,r6
   253dc:	280d883a 	mov	r6,r5
   253e0:	200b883a 	mov	r5,r4
   253e4:	e13ff917 	ldw	r4,-28(fp)
   253e8:	00259e80 	call	259e8 <_ZN7Display8fillRectEsssst>
   253ec:	00003506 	br	254c4 <_ZN7Display8drawCharEsshtth+0x2d8>
			} else if(bg != color) {
   253f0:	e0fffe0b 	ldhu	r3,-8(fp)
   253f4:	e0bffd0b 	ldhu	r2,-12(fp)
   253f8:	18803226 	beq	r3,r2,254c4 <_ZN7Display8drawCharEsshtth+0x2d8>
				if(size == 1) drawPixel(x+i, y+j, bg);
   253fc:	e0bfff03 	ldbu	r2,-4(fp)
   25400:	10800058 	cmpnei	r2,r2,1
   25404:	1000131e 	bne	r2,zero,25454 <_ZN7Display8drawCharEsshtth+0x268>
   25408:	e0fff807 	ldb	r3,-32(fp)
   2540c:	e0bffa0b 	ldhu	r2,-24(fp)
   25410:	1885883a 	add	r2,r3,r2
   25414:	113fffcc 	andi	r4,r2,65535
   25418:	2120001c 	xori	r4,r4,32768
   2541c:	21200004 	addi	r4,r4,-32768
   25420:	e0fff887 	ldb	r3,-30(fp)
   25424:	e0bffb0b 	ldhu	r2,-20(fp)
   25428:	1885883a 	add	r2,r3,r2
   2542c:	10bfffcc 	andi	r2,r2,65535
   25430:	10a0001c 	xori	r2,r2,32768
   25434:	10a00004 	addi	r2,r2,-32768
   25438:	e0fffe0b 	ldhu	r3,-8(fp)
   2543c:	180f883a 	mov	r7,r3
   25440:	100d883a 	mov	r6,r2
   25444:	200b883a 	mov	r5,r4
   25448:	e13ff917 	ldw	r4,-28(fp)
   2544c:	00250f00 	call	250f0 <_ZN7Display9drawPixelEsst>
   25450:	00001c06 	br	254c4 <_ZN7Display8drawCharEsshtth+0x2d8>
				else          fillRect(x+i*size, y+j*size, size, size, bg);
   25454:	e0fff807 	ldb	r3,-32(fp)
   25458:	e0bfff03 	ldbu	r2,-4(fp)
   2545c:	1885383a 	mul	r2,r3,r2
   25460:	1007883a 	mov	r3,r2
   25464:	e0bffa0b 	ldhu	r2,-24(fp)
   25468:	1885883a 	add	r2,r3,r2
   2546c:	113fffcc 	andi	r4,r2,65535
   25470:	2120001c 	xori	r4,r4,32768
   25474:	21200004 	addi	r4,r4,-32768
   25478:	e0fff887 	ldb	r3,-30(fp)
   2547c:	e0bfff03 	ldbu	r2,-4(fp)
   25480:	1885383a 	mul	r2,r3,r2
   25484:	1007883a 	mov	r3,r2
   25488:	e0bffb0b 	ldhu	r2,-20(fp)
   2548c:	1885883a 	add	r2,r3,r2
   25490:	117fffcc 	andi	r5,r2,65535
   25494:	2960001c 	xori	r5,r5,32768
   25498:	29600004 	addi	r5,r5,-32768
   2549c:	e1bfff03 	ldbu	r6,-4(fp)
   254a0:	e0bfff03 	ldbu	r2,-4(fp)
   254a4:	e0fffe0b 	ldhu	r3,-8(fp)
   254a8:	d8c00115 	stw	r3,4(sp)
   254ac:	d8800015 	stw	r2,0(sp)
   254b0:	300f883a 	mov	r7,r6
   254b4:	280d883a 	mov	r6,r5
   254b8:	200b883a 	mov	r5,r4
   254bc:	e13ff917 	ldw	r4,-28(fp)
   254c0:	00259e80 	call	259e8 <_ZN7Display8fillRectEsssst>

	for(alt_8 i=0; i<CHARSIZE_WIDTH; i++ ) {
		alt_u8 line;
		if(i < (CHARSIZE_WIDTH-1)) line = font[(c*(CHARSIZE_WIDTH-1))+i];
		else      line = 0x0;
		for(alt_8 j=0; j<CHARSIZE_HEIGHT; j++, line >>= 1) {
   254c4:	e0bff883 	ldbu	r2,-30(fp)
   254c8:	10800044 	addi	r2,r2,1
   254cc:	e0bff885 	stb	r2,-30(fp)
   254d0:	e0bff843 	ldbu	r2,-31(fp)
   254d4:	1005d07a 	srai	r2,r2,1
   254d8:	e0bff845 	stb	r2,-31(fp)
   254dc:	003f8b06 	br	2530c <__reset+0xfff8530c>
			((y + CHARSIZE_HEIGHT * size - 1) < 0))   // Clip top
		return;

	if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

	for(alt_8 i=0; i<CHARSIZE_WIDTH; i++ ) {
   254e0:	e0bff803 	ldbu	r2,-32(fp)
   254e4:	10800044 	addi	r2,r2,1
   254e8:	e0bff805 	stb	r2,-32(fp)
   254ec:	003f7506 	br	252c4 <__reset+0xfff852c4>
void Display::drawChar(alt_16 x, alt_16 y, unsigned char c, alt_u16 color, alt_u16 bg, alt_u8 size) {
	if((x >= _width)            || // Clip right
			(y >= _height)           || // Clip bottom
			((x + CHARSIZE_WIDTH * size - 1) < 0) || // Clip left
			((y + CHARSIZE_HEIGHT * size - 1) < 0))   // Clip top
		return;
   254f0:	0001883a 	nop
				if(size == 1) drawPixel(x+i, y+j, bg);
				else          fillRect(x+i*size, y+j*size, size, size, bg);
			}
		}
	}
}
   254f4:	e037883a 	mov	sp,fp
   254f8:	dfc00117 	ldw	ra,4(sp)
   254fc:	df000017 	ldw	fp,0(sp)
   25500:	dec00204 	addi	sp,sp,8
   25504:	f800283a 	ret

00025508 <_ZN7Display9writeLineEPKcth>:

void Display::writeLine(const char* line, alt_u16 color, alt_u8 size) {
   25508:	defff404 	addi	sp,sp,-48
   2550c:	dfc00b15 	stw	ra,44(sp)
   25510:	df000a15 	stw	fp,40(sp)
   25514:	dc000915 	stw	r16,36(sp)
   25518:	df000a04 	addi	fp,sp,40
   2551c:	e13ffb15 	stw	r4,-20(fp)
   25520:	e17ffc15 	stw	r5,-16(fp)
   25524:	3007883a 	mov	r3,r6
   25528:	3805883a 	mov	r2,r7
   2552c:	e0fffd0d 	sth	r3,-12(fp)
   25530:	e0bffe05 	stb	r2,-8(fp)
	alt_u16 cursor_x = 0;
   25534:	e03ff90d 	sth	zero,-28(fp)
	static alt_u16 cursor_y = 0;

	if(_currentLine < 99) {
   25538:	d0a02b03 	ldbu	r2,-32596(gp)
   2553c:	10803fcc 	andi	r2,r2,255
   25540:	108018e8 	cmpgeui	r2,r2,99
   25544:	1000041e 	bne	r2,zero,25558 <_ZN7Display9writeLineEPKcth+0x50>
		_currentLine++;
   25548:	d0a02b03 	ldbu	r2,-32596(gp)
   2554c:	10800044 	addi	r2,r2,1
   25550:	d0a02b05 	stb	r2,-32596(gp)
   25554:	00000606 	br	25570 <_ZN7Display9writeLineEPKcth+0x68>
	}
	else if(_currentLine==99) {
   25558:	d0a02b03 	ldbu	r2,-32596(gp)
   2555c:	10803fcc 	andi	r2,r2,255
   25560:	108018d8 	cmpnei	r2,r2,99
   25564:	1000021e 	bne	r2,zero,25570 <_ZN7Display9writeLineEPKcth+0x68>
		_currentLine = 1;
   25568:	00800044 	movi	r2,1
   2556c:	d0a02b05 	stb	r2,-32596(gp)
	}

	if(_height < cursor_y+(CHARSIZE_HEIGHT*size)) {
   25570:	e0bffb17 	ldw	r2,-20(fp)
   25574:	1080008b 	ldhu	r2,2(r2)
   25578:	10ffffcc 	andi	r3,r2,65535
   2557c:	18e0001c 	xori	r3,r3,32768
   25580:	18e00004 	addi	r3,r3,-32768
   25584:	d0a02c0b 	ldhu	r2,-32592(gp)
   25588:	113fffcc 	andi	r4,r2,65535
   2558c:	e0bffe03 	ldbu	r2,-8(fp)
   25590:	100490fa 	slli	r2,r2,3
   25594:	2085883a 	add	r2,r4,r2
   25598:	1880010e 	bge	r3,r2,255a0 <_ZN7Display9writeLineEPKcth+0x98>
		cursor_y = 0;
   2559c:	d0202c0d 	sth	zero,-32592(gp)
	}

	fillRect(0, cursor_y, _width, (CHARSIZE_HEIGHT*size)-1, _bgcolor);
   255a0:	d0a02c0b 	ldhu	r2,-32592(gp)
   255a4:	113fffcc 	andi	r4,r2,65535
   255a8:	2120001c 	xori	r4,r4,32768
   255ac:	21200004 	addi	r4,r4,-32768
   255b0:	e0bffb17 	ldw	r2,-20(fp)
   255b4:	1080000b 	ldhu	r2,0(r2)
   255b8:	117fffcc 	andi	r5,r2,65535
   255bc:	2960001c 	xori	r5,r5,32768
   255c0:	29600004 	addi	r5,r5,-32768
   255c4:	e0bffe03 	ldbu	r2,-8(fp)
   255c8:	100490fa 	slli	r2,r2,3
   255cc:	10bfffc4 	addi	r2,r2,-1
   255d0:	10bfffcc 	andi	r2,r2,65535
   255d4:	10a0001c 	xori	r2,r2,32768
   255d8:	10a00004 	addi	r2,r2,-32768
   255dc:	d0e02b8b 	ldhu	r3,-32594(gp)
   255e0:	18ffffcc 	andi	r3,r3,65535
   255e4:	d8c00115 	stw	r3,4(sp)
   255e8:	d8800015 	stw	r2,0(sp)
   255ec:	280f883a 	mov	r7,r5
   255f0:	200d883a 	mov	r6,r4
   255f4:	000b883a 	mov	r5,zero
   255f8:	e13ffb17 	ldw	r4,-20(fp)
   255fc:	00259e80 	call	259e8 <_ZN7Display8fillRectEsssst>

	char number[3];
	itochptr(_currentLine, number);
   25600:	d0a02b03 	ldbu	r2,-32596(gp)
   25604:	10803fcc 	andi	r2,r2,255
   25608:	e0fffa04 	addi	r3,fp,-24
   2560c:	180b883a 	mov	r5,r3
   25610:	1009883a 	mov	r4,r2
   25614:	0024aa40 	call	24aa4 <_Z8itochptriPc>
	//sprintf(number, "%i", currentLine);


	if(_currentLine > 9) {
   25618:	d0a02b03 	ldbu	r2,-32596(gp)
   2561c:	10803fcc 	andi	r2,r2,255
   25620:	108002b0 	cmpltui	r2,r2,10
   25624:	1000501e 	bne	r2,zero,25768 <_ZN7Display9writeLineEPKcth+0x260>
		drawChar(0, cursor_y, number[0], color, _bgcolor, size);
   25628:	d0a02c0b 	ldhu	r2,-32592(gp)
   2562c:	117fffcc 	andi	r5,r2,65535
   25630:	2960001c 	xori	r5,r5,32768
   25634:	29600004 	addi	r5,r5,-32768
   25638:	e0bffa03 	ldbu	r2,-24(fp)
   2563c:	11803fcc 	andi	r6,r2,255
   25640:	e0bffd0b 	ldhu	r2,-12(fp)
   25644:	d0e02b8b 	ldhu	r3,-32594(gp)
   25648:	18ffffcc 	andi	r3,r3,65535
   2564c:	e13ffe03 	ldbu	r4,-8(fp)
   25650:	d9000215 	stw	r4,8(sp)
   25654:	d8c00115 	stw	r3,4(sp)
   25658:	d8800015 	stw	r2,0(sp)
   2565c:	300f883a 	mov	r7,r6
   25660:	280d883a 	mov	r6,r5
   25664:	000b883a 	mov	r5,zero
   25668:	e13ffb17 	ldw	r4,-20(fp)
   2566c:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		drawChar(1*(CHARSIZE_WIDTH*size), cursor_y, number[1], color, _bgcolor, size);
   25670:	e0bffe03 	ldbu	r2,-8(fp)
   25674:	108001a4 	muli	r2,r2,6
   25678:	117fffcc 	andi	r5,r2,65535
   2567c:	2960001c 	xori	r5,r5,32768
   25680:	29600004 	addi	r5,r5,-32768
   25684:	d0a02c0b 	ldhu	r2,-32592(gp)
   25688:	11bfffcc 	andi	r6,r2,65535
   2568c:	31a0001c 	xori	r6,r6,32768
   25690:	31a00004 	addi	r6,r6,-32768
   25694:	e0bffa43 	ldbu	r2,-23(fp)
   25698:	11c03fcc 	andi	r7,r2,255
   2569c:	e0bffd0b 	ldhu	r2,-12(fp)
   256a0:	d0e02b8b 	ldhu	r3,-32594(gp)
   256a4:	18ffffcc 	andi	r3,r3,65535
   256a8:	e13ffe03 	ldbu	r4,-8(fp)
   256ac:	d9000215 	stw	r4,8(sp)
   256b0:	d8c00115 	stw	r3,4(sp)
   256b4:	d8800015 	stw	r2,0(sp)
   256b8:	e13ffb17 	ldw	r4,-20(fp)
   256bc:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		drawChar(2*(CHARSIZE_WIDTH*size), cursor_y, ':', color, _bgcolor, size);
   256c0:	e0bffe03 	ldbu	r2,-8(fp)
   256c4:	10800324 	muli	r2,r2,12
   256c8:	117fffcc 	andi	r5,r2,65535
   256cc:	2960001c 	xori	r5,r5,32768
   256d0:	29600004 	addi	r5,r5,-32768
   256d4:	d0a02c0b 	ldhu	r2,-32592(gp)
   256d8:	11bfffcc 	andi	r6,r2,65535
   256dc:	31a0001c 	xori	r6,r6,32768
   256e0:	31a00004 	addi	r6,r6,-32768
   256e4:	e0bffd0b 	ldhu	r2,-12(fp)
   256e8:	d0e02b8b 	ldhu	r3,-32594(gp)
   256ec:	18ffffcc 	andi	r3,r3,65535
   256f0:	e13ffe03 	ldbu	r4,-8(fp)
   256f4:	d9000215 	stw	r4,8(sp)
   256f8:	d8c00115 	stw	r3,4(sp)
   256fc:	d8800015 	stw	r2,0(sp)
   25700:	01c00e84 	movi	r7,58
   25704:	e13ffb17 	ldw	r4,-20(fp)
   25708:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		drawChar(3*(CHARSIZE_WIDTH*size), cursor_y, ' ', color, _bgcolor, size);
   2570c:	e0bffe03 	ldbu	r2,-8(fp)
   25710:	108004a4 	muli	r2,r2,18
   25714:	117fffcc 	andi	r5,r2,65535
   25718:	2960001c 	xori	r5,r5,32768
   2571c:	29600004 	addi	r5,r5,-32768
   25720:	d0a02c0b 	ldhu	r2,-32592(gp)
   25724:	11bfffcc 	andi	r6,r2,65535
   25728:	31a0001c 	xori	r6,r6,32768
   2572c:	31a00004 	addi	r6,r6,-32768
   25730:	e0bffd0b 	ldhu	r2,-12(fp)
   25734:	d0e02b8b 	ldhu	r3,-32594(gp)
   25738:	18ffffcc 	andi	r3,r3,65535
   2573c:	e13ffe03 	ldbu	r4,-8(fp)
   25740:	d9000215 	stw	r4,8(sp)
   25744:	d8c00115 	stw	r3,4(sp)
   25748:	d8800015 	stw	r2,0(sp)
   2574c:	01c00804 	movi	r7,32
   25750:	e13ffb17 	ldw	r4,-20(fp)
   25754:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		cursor_x = 3*(CHARSIZE_WIDTH*size);
   25758:	e0bffe03 	ldbu	r2,-8(fp)
   2575c:	108004a4 	muli	r2,r2,18
   25760:	e0bff90d 	sth	r2,-28(fp)
   25764:	00003f06 	br	25864 <_ZN7Display9writeLineEPKcth+0x35c>
	}
	else if(_currentLine < 10) {
   25768:	d0a02b03 	ldbu	r2,-32596(gp)
   2576c:	10803fcc 	andi	r2,r2,255
   25770:	108002a8 	cmpgeui	r2,r2,10
   25774:	10003b1e 	bne	r2,zero,25864 <_ZN7Display9writeLineEPKcth+0x35c>
		drawChar(0, cursor_y, number[0], color, _bgcolor, size);
   25778:	d0a02c0b 	ldhu	r2,-32592(gp)
   2577c:	117fffcc 	andi	r5,r2,65535
   25780:	2960001c 	xori	r5,r5,32768
   25784:	29600004 	addi	r5,r5,-32768
   25788:	e0bffa03 	ldbu	r2,-24(fp)
   2578c:	11803fcc 	andi	r6,r2,255
   25790:	e0bffd0b 	ldhu	r2,-12(fp)
   25794:	d0e02b8b 	ldhu	r3,-32594(gp)
   25798:	18ffffcc 	andi	r3,r3,65535
   2579c:	e13ffe03 	ldbu	r4,-8(fp)
   257a0:	d9000215 	stw	r4,8(sp)
   257a4:	d8c00115 	stw	r3,4(sp)
   257a8:	d8800015 	stw	r2,0(sp)
   257ac:	300f883a 	mov	r7,r6
   257b0:	280d883a 	mov	r6,r5
   257b4:	000b883a 	mov	r5,zero
   257b8:	e13ffb17 	ldw	r4,-20(fp)
   257bc:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		drawChar(1*(CHARSIZE_WIDTH*size), cursor_y, ':', color, _bgcolor, size);
   257c0:	e0bffe03 	ldbu	r2,-8(fp)
   257c4:	108001a4 	muli	r2,r2,6
   257c8:	117fffcc 	andi	r5,r2,65535
   257cc:	2960001c 	xori	r5,r5,32768
   257d0:	29600004 	addi	r5,r5,-32768
   257d4:	d0a02c0b 	ldhu	r2,-32592(gp)
   257d8:	11bfffcc 	andi	r6,r2,65535
   257dc:	31a0001c 	xori	r6,r6,32768
   257e0:	31a00004 	addi	r6,r6,-32768
   257e4:	e0bffd0b 	ldhu	r2,-12(fp)
   257e8:	d0e02b8b 	ldhu	r3,-32594(gp)
   257ec:	18ffffcc 	andi	r3,r3,65535
   257f0:	e13ffe03 	ldbu	r4,-8(fp)
   257f4:	d9000215 	stw	r4,8(sp)
   257f8:	d8c00115 	stw	r3,4(sp)
   257fc:	d8800015 	stw	r2,0(sp)
   25800:	01c00e84 	movi	r7,58
   25804:	e13ffb17 	ldw	r4,-20(fp)
   25808:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		drawChar(2*(CHARSIZE_WIDTH*size), cursor_y, ' ', color, _bgcolor, size);
   2580c:	e0bffe03 	ldbu	r2,-8(fp)
   25810:	10800324 	muli	r2,r2,12
   25814:	117fffcc 	andi	r5,r2,65535
   25818:	2960001c 	xori	r5,r5,32768
   2581c:	29600004 	addi	r5,r5,-32768
   25820:	d0a02c0b 	ldhu	r2,-32592(gp)
   25824:	11bfffcc 	andi	r6,r2,65535
   25828:	31a0001c 	xori	r6,r6,32768
   2582c:	31a00004 	addi	r6,r6,-32768
   25830:	e0bffd0b 	ldhu	r2,-12(fp)
   25834:	d0e02b8b 	ldhu	r3,-32594(gp)
   25838:	18ffffcc 	andi	r3,r3,65535
   2583c:	e13ffe03 	ldbu	r4,-8(fp)
   25840:	d9000215 	stw	r4,8(sp)
   25844:	d8c00115 	stw	r3,4(sp)
   25848:	d8800015 	stw	r2,0(sp)
   2584c:	01c00804 	movi	r7,32
   25850:	e13ffb17 	ldw	r4,-20(fp)
   25854:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
		cursor_x = 2*(CHARSIZE_WIDTH*size);
   25858:	e0bffe03 	ldbu	r2,-8(fp)
   2585c:	10800324 	muli	r2,r2,12
   25860:	e0bff90d 	sth	r2,-28(fp)
	}


	for(alt_u16 i = 0; i < strlen(line); i++) {
   25864:	e03ff98d 	sth	zero,-26(fp)
   25868:	e43ff98b 	ldhu	r16,-26(fp)
   2586c:	e13ffc17 	ldw	r4,-16(fp)
   25870:	002b9f00 	call	2b9f0 <strlen>
   25874:	8080312e 	bgeu	r16,r2,2593c <_ZN7Display9writeLineEPKcth+0x434>
			if((cursor_x + (CHARSIZE_WIDTH*size)) >= _width) { // Heading off edge?
   25878:	e0fff90b 	ldhu	r3,-28(fp)
   2587c:	e0bffe03 	ldbu	r2,-8(fp)
   25880:	108001a4 	muli	r2,r2,6
   25884:	1887883a 	add	r3,r3,r2
   25888:	e0bffb17 	ldw	r2,-20(fp)
   2588c:	1080000b 	ldhu	r2,0(r2)
   25890:	10bfffcc 	andi	r2,r2,65535
   25894:	10a0001c 	xori	r2,r2,32768
   25898:	10a00004 	addi	r2,r2,-32768
   2589c:	18800716 	blt	r3,r2,258bc <_ZN7Display9writeLineEPKcth+0x3b4>
				cursor_y += CHARSIZE_HEIGHT*size;
   258a0:	e0bffe03 	ldbu	r2,-8(fp)
   258a4:	100490fa 	slli	r2,r2,3
   258a8:	1007883a 	mov	r3,r2
   258ac:	d0a02c0b 	ldhu	r2,-32592(gp)
   258b0:	1885883a 	add	r2,r3,r2
   258b4:	d0a02c0d 	sth	r2,-32592(gp)
				return;
   258b8:	00002606 	br	25954 <_ZN7Display9writeLineEPKcth+0x44c>
			}
			drawChar(cursor_x, cursor_y, line[i], color, _bgcolor, size);
   258bc:	e0bff90b 	ldhu	r2,-28(fp)
   258c0:	117fffcc 	andi	r5,r2,65535
   258c4:	2960001c 	xori	r5,r5,32768
   258c8:	29600004 	addi	r5,r5,-32768
   258cc:	d0a02c0b 	ldhu	r2,-32592(gp)
   258d0:	11bfffcc 	andi	r6,r2,65535
   258d4:	31a0001c 	xori	r6,r6,32768
   258d8:	31a00004 	addi	r6,r6,-32768
   258dc:	e0bff98b 	ldhu	r2,-26(fp)
   258e0:	e0fffc17 	ldw	r3,-16(fp)
   258e4:	1885883a 	add	r2,r3,r2
   258e8:	10800003 	ldbu	r2,0(r2)
   258ec:	11c03fcc 	andi	r7,r2,255
   258f0:	e0bffd0b 	ldhu	r2,-12(fp)
   258f4:	d0e02b8b 	ldhu	r3,-32594(gp)
   258f8:	18ffffcc 	andi	r3,r3,65535
   258fc:	e13ffe03 	ldbu	r4,-8(fp)
   25900:	d9000215 	stw	r4,8(sp)
   25904:	d8c00115 	stw	r3,4(sp)
   25908:	d8800015 	stw	r2,0(sp)
   2590c:	e13ffb17 	ldw	r4,-20(fp)
   25910:	00251ec0 	call	251ec <_ZN7Display8drawCharEsshtth>
			cursor_x += CHARSIZE_WIDTH*size;
   25914:	e0bffe03 	ldbu	r2,-8(fp)
   25918:	108001a4 	muli	r2,r2,6
   2591c:	1007883a 	mov	r3,r2
   25920:	e0bff90b 	ldhu	r2,-28(fp)
   25924:	1885883a 	add	r2,r3,r2
   25928:	e0bff90d 	sth	r2,-28(fp)
		drawChar(2*(CHARSIZE_WIDTH*size), cursor_y, ' ', color, _bgcolor, size);
		cursor_x = 2*(CHARSIZE_WIDTH*size);
	}


	for(alt_u16 i = 0; i < strlen(line); i++) {
   2592c:	e0bff98b 	ldhu	r2,-26(fp)
   25930:	10800044 	addi	r2,r2,1
   25934:	e0bff98d 	sth	r2,-26(fp)
   25938:	003fcb06 	br	25868 <__reset+0xfff85868>
				return;
			}
			drawChar(cursor_x, cursor_y, line[i], color, _bgcolor, size);
			cursor_x += CHARSIZE_WIDTH*size;
	}
	cursor_y += CHARSIZE_HEIGHT*size;
   2593c:	e0bffe03 	ldbu	r2,-8(fp)
   25940:	100490fa 	slli	r2,r2,3
   25944:	1007883a 	mov	r3,r2
   25948:	d0a02c0b 	ldhu	r2,-32592(gp)
   2594c:	1885883a 	add	r2,r3,r2
   25950:	d0a02c0d 	sth	r2,-32592(gp)
}
   25954:	e6ffff04 	addi	sp,fp,-4
   25958:	dfc00217 	ldw	ra,8(sp)
   2595c:	df000117 	ldw	fp,4(sp)
   25960:	dc000017 	ldw	r16,0(sp)
   25964:	dec00304 	addi	sp,sp,12
   25968:	f800283a 	ret

0002596c <_ZN7Display10fillScreenEt>:

void Display::fillScreen(alt_u16 color) {
   2596c:	defffa04 	addi	sp,sp,-24
   25970:	dfc00515 	stw	ra,20(sp)
   25974:	df000415 	stw	fp,16(sp)
   25978:	df000404 	addi	fp,sp,16
   2597c:	e13ffe15 	stw	r4,-8(fp)
   25980:	2805883a 	mov	r2,r5
   25984:	e0bfff0d 	sth	r2,-4(fp)
	fillRect(0, 0, _width, _height, color);
   25988:	e0bffe17 	ldw	r2,-8(fp)
   2598c:	1080000b 	ldhu	r2,0(r2)
   25990:	113fffcc 	andi	r4,r2,65535
   25994:	2120001c 	xori	r4,r4,32768
   25998:	21200004 	addi	r4,r4,-32768
   2599c:	e0bffe17 	ldw	r2,-8(fp)
   259a0:	1080008b 	ldhu	r2,2(r2)
   259a4:	10bfffcc 	andi	r2,r2,65535
   259a8:	10a0001c 	xori	r2,r2,32768
   259ac:	10a00004 	addi	r2,r2,-32768
   259b0:	e0ffff0b 	ldhu	r3,-4(fp)
   259b4:	d8c00115 	stw	r3,4(sp)
   259b8:	d8800015 	stw	r2,0(sp)
   259bc:	200f883a 	mov	r7,r4
   259c0:	000d883a 	mov	r6,zero
   259c4:	000b883a 	mov	r5,zero
   259c8:	e13ffe17 	ldw	r4,-8(fp)
   259cc:	00259e80 	call	259e8 <_ZN7Display8fillRectEsssst>
}
   259d0:	0001883a 	nop
   259d4:	e037883a 	mov	sp,fp
   259d8:	dfc00117 	ldw	ra,4(sp)
   259dc:	df000017 	ldw	fp,0(sp)
   259e0:	dec00204 	addi	sp,sp,8
   259e4:	f800283a 	ret

000259e8 <_ZN7Display8fillRectEsssst>:

void Display::fillRect(alt_16 x, alt_16 y, alt_16 w, alt_16 h, alt_u16 color) {
   259e8:	defff604 	addi	sp,sp,-40
   259ec:	dfc00915 	stw	ra,36(sp)
   259f0:	df000815 	stw	fp,32(sp)
   259f4:	df000804 	addi	fp,sp,32
   259f8:	e13ffa15 	stw	r4,-24(fp)
   259fc:	2811883a 	mov	r8,r5
   25a00:	300b883a 	mov	r5,r6
   25a04:	3809883a 	mov	r4,r7
   25a08:	e0c00217 	ldw	r3,8(fp)
   25a0c:	e0800317 	ldw	r2,12(fp)
   25a10:	e23ffb0d 	sth	r8,-20(fp)
   25a14:	e17ffc0d 	sth	r5,-16(fp)
   25a18:	e13ffd0d 	sth	r4,-12(fp)
   25a1c:	e0fffe0d 	sth	r3,-8(fp)
   25a20:	e0bfff0d 	sth	r2,-4(fp)

	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
   25a24:	e0bffa17 	ldw	r2,-24(fp)
   25a28:	1080000b 	ldhu	r2,0(r2)
   25a2c:	10bfffcc 	andi	r2,r2,65535
   25a30:	10a0001c 	xori	r2,r2,32768
   25a34:	10a00004 	addi	r2,r2,-32768
   25a38:	e0fffb0f 	ldh	r3,-20(fp)
   25a3c:	1880580e 	bge	r3,r2,25ba0 <_ZN7Display8fillRectEsssst+0x1b8>
   25a40:	e0bffa17 	ldw	r2,-24(fp)
   25a44:	1080008b 	ldhu	r2,2(r2)
   25a48:	10bfffcc 	andi	r2,r2,65535
   25a4c:	10a0001c 	xori	r2,r2,32768
   25a50:	10a00004 	addi	r2,r2,-32768
   25a54:	e0fffc0f 	ldh	r3,-16(fp)
   25a58:	1880510e 	bge	r3,r2,25ba0 <_ZN7Display8fillRectEsssst+0x1b8>
	if((x + w - 1) >= _width)  w = _width  - x;
   25a5c:	e0fffb0f 	ldh	r3,-20(fp)
   25a60:	e0bffd0f 	ldh	r2,-12(fp)
   25a64:	1885883a 	add	r2,r3,r2
   25a68:	10ffffc4 	addi	r3,r2,-1
   25a6c:	e0bffa17 	ldw	r2,-24(fp)
   25a70:	1080000b 	ldhu	r2,0(r2)
   25a74:	10bfffcc 	andi	r2,r2,65535
   25a78:	10a0001c 	xori	r2,r2,32768
   25a7c:	10a00004 	addi	r2,r2,-32768
   25a80:	18800616 	blt	r3,r2,25a9c <_ZN7Display8fillRectEsssst+0xb4>
   25a84:	e0bffa17 	ldw	r2,-24(fp)
   25a88:	1080000b 	ldhu	r2,0(r2)
   25a8c:	1007883a 	mov	r3,r2
   25a90:	e0bffb0b 	ldhu	r2,-20(fp)
   25a94:	1885c83a 	sub	r2,r3,r2
   25a98:	e0bffd0d 	sth	r2,-12(fp)
	if((y + h - 1) >= _height) h = _height - y;
   25a9c:	e0fffc0f 	ldh	r3,-16(fp)
   25aa0:	e0bffe0f 	ldh	r2,-8(fp)
   25aa4:	1885883a 	add	r2,r3,r2
   25aa8:	10ffffc4 	addi	r3,r2,-1
   25aac:	e0bffa17 	ldw	r2,-24(fp)
   25ab0:	1080008b 	ldhu	r2,2(r2)
   25ab4:	10bfffcc 	andi	r2,r2,65535
   25ab8:	10a0001c 	xori	r2,r2,32768
   25abc:	10a00004 	addi	r2,r2,-32768
   25ac0:	18800616 	blt	r3,r2,25adc <_ZN7Display8fillRectEsssst+0xf4>
   25ac4:	e0bffa17 	ldw	r2,-24(fp)
   25ac8:	1080008b 	ldhu	r2,2(r2)
   25acc:	1007883a 	mov	r3,r2
   25ad0:	e0bffc0b 	ldhu	r2,-16(fp)
   25ad4:	1885c83a 	sub	r2,r3,r2
   25ad8:	e0bffe0d 	sth	r2,-8(fp)

	setAddrWindow(x, y, x+w-1, y+h-1);
   25adc:	e0bffb0b 	ldhu	r2,-20(fp)
   25ae0:	113fffcc 	andi	r4,r2,65535
   25ae4:	e0bffc0b 	ldhu	r2,-16(fp)
   25ae8:	117fffcc 	andi	r5,r2,65535
   25aec:	e0fffb0b 	ldhu	r3,-20(fp)
   25af0:	e0bffd0b 	ldhu	r2,-12(fp)
   25af4:	1885883a 	add	r2,r3,r2
   25af8:	10bfffc4 	addi	r2,r2,-1
   25afc:	11bfffcc 	andi	r6,r2,65535
   25b00:	e0fffc0b 	ldhu	r3,-16(fp)
   25b04:	e0bffe0b 	ldhu	r2,-8(fp)
   25b08:	1885883a 	add	r2,r3,r2
   25b0c:	10bfffc4 	addi	r2,r2,-1
   25b10:	10bfffcc 	andi	r2,r2,65535
   25b14:	d8800015 	stw	r2,0(sp)
   25b18:	300f883a 	mov	r7,r6
   25b1c:	280d883a 	mov	r6,r5
   25b20:	200b883a 	mov	r5,r4
   25b24:	e13ffa17 	ldw	r4,-24(fp)
   25b28:	0025bb80 	call	25bb8 <_ZN7Display13setAddrWindowEtttt>

	alt_u8 hi = color >> 8, lo = color;
   25b2c:	e0bfff0b 	ldhu	r2,-4(fp)
   25b30:	1005d23a 	srai	r2,r2,8
   25b34:	e0bff905 	stb	r2,-28(fp)
   25b38:	e0bfff0b 	ldhu	r2,-4(fp)
   25b3c:	e0bff945 	stb	r2,-27(fp)


	set_tft_dc(true);
   25b40:	01000044 	movi	r4,1
   25b44:	00248e40 	call	248e4 <_Z10set_tft_dcb>


	for(y=h; y>0; y--) {
   25b48:	e0bffe0b 	ldhu	r2,-8(fp)
   25b4c:	e0bffc0d 	sth	r2,-16(fp)
   25b50:	e0bffc0f 	ldh	r2,-16(fp)
   25b54:	0080130e 	bge	zero,r2,25ba4 <_ZN7Display8fillRectEsssst+0x1bc>
		for(x=w; x>0; x--) {
   25b58:	e0bffd0b 	ldhu	r2,-12(fp)
   25b5c:	e0bffb0d 	sth	r2,-20(fp)
   25b60:	e0bffb0f 	ldh	r2,-20(fp)
   25b64:	00800a0e 	bge	zero,r2,25b90 <_ZN7Display8fillRectEsssst+0x1a8>
			spi_write_byte(hi);
   25b68:	e0bff903 	ldbu	r2,-28(fp)
   25b6c:	1009883a 	mov	r4,r2
   25b70:	00249500 	call	24950 <_Z14spi_write_byteh>
			spi_write_byte(lo);
   25b74:	e0bff943 	ldbu	r2,-27(fp)
   25b78:	1009883a 	mov	r4,r2
   25b7c:	00249500 	call	24950 <_Z14spi_write_byteh>

	set_tft_dc(true);


	for(y=h; y>0; y--) {
		for(x=w; x>0; x--) {
   25b80:	e0bffb0b 	ldhu	r2,-20(fp)
   25b84:	10bfffc4 	addi	r2,r2,-1
   25b88:	e0bffb0d 	sth	r2,-20(fp)
   25b8c:	003ff406 	br	25b60 <__reset+0xfff85b60>


	set_tft_dc(true);


	for(y=h; y>0; y--) {
   25b90:	e0bffc0b 	ldhu	r2,-16(fp)
   25b94:	10bfffc4 	addi	r2,r2,-1
   25b98:	e0bffc0d 	sth	r2,-16(fp)
   25b9c:	003fec06 	br	25b50 <__reset+0xfff85b50>
}

void Display::fillRect(alt_16 x, alt_16 y, alt_16 w, alt_16 h, alt_u16 color) {

	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
   25ba0:	0001883a 	nop
		for(x=w; x>0; x--) {
			spi_write_byte(hi);
			spi_write_byte(lo);
		}
	}
}
   25ba4:	e037883a 	mov	sp,fp
   25ba8:	dfc00117 	ldw	ra,4(sp)
   25bac:	df000017 	ldw	fp,0(sp)
   25bb0:	dec00204 	addi	sp,sp,8
   25bb4:	f800283a 	ret

00025bb8 <_ZN7Display13setAddrWindowEtttt>:

void Display::setAddrWindow(alt_u16 x0, alt_u16 y0, alt_u16 x1, alt_u16 y1) {
   25bb8:	defff904 	addi	sp,sp,-28
   25bbc:	dfc00615 	stw	ra,24(sp)
   25bc0:	df000515 	stw	fp,20(sp)
   25bc4:	df000504 	addi	fp,sp,20
   25bc8:	e13ffb15 	stw	r4,-20(fp)
   25bcc:	3009883a 	mov	r4,r6
   25bd0:	3807883a 	mov	r3,r7
   25bd4:	e0800217 	ldw	r2,8(fp)
   25bd8:	e17ffc0d 	sth	r5,-16(fp)
   25bdc:	e13ffd0d 	sth	r4,-12(fp)
   25be0:	e0fffe0d 	sth	r3,-8(fp)
   25be4:	e0bfff0d 	sth	r2,-4(fp)
	writecommand(ILI9341_CASET); // Column addr set
   25be8:	01400a84 	movi	r5,42
   25bec:	e13ffb17 	ldw	r4,-20(fp)
   25bf0:	00250600 	call	25060 <_ZN7Display12writecommandEh>
	writedata(x0 >> 8);
   25bf4:	e0bffc0b 	ldhu	r2,-16(fp)
   25bf8:	1004d23a 	srli	r2,r2,8
   25bfc:	10bfffcc 	andi	r2,r2,65535
   25c00:	100b883a 	mov	r5,r2
   25c04:	e13ffb17 	ldw	r4,-20(fp)
   25c08:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(x0 & 0xFF);     // XSTART
   25c0c:	e0bffc0b 	ldhu	r2,-16(fp)
   25c10:	10803fcc 	andi	r2,r2,255
   25c14:	100b883a 	mov	r5,r2
   25c18:	e13ffb17 	ldw	r4,-20(fp)
   25c1c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(x1 >> 8);
   25c20:	e0bffe0b 	ldhu	r2,-8(fp)
   25c24:	1004d23a 	srli	r2,r2,8
   25c28:	10bfffcc 	andi	r2,r2,65535
   25c2c:	100b883a 	mov	r5,r2
   25c30:	e13ffb17 	ldw	r4,-20(fp)
   25c34:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(x1 & 0xFF);     // XEND
   25c38:	e0bffe0b 	ldhu	r2,-8(fp)
   25c3c:	10803fcc 	andi	r2,r2,255
   25c40:	100b883a 	mov	r5,r2
   25c44:	e13ffb17 	ldw	r4,-20(fp)
   25c48:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_PASET); // Row addr set
   25c4c:	01400ac4 	movi	r5,43
   25c50:	e13ffb17 	ldw	r4,-20(fp)
   25c54:	00250600 	call	25060 <_ZN7Display12writecommandEh>
	writedata(y0>>8);
   25c58:	e0bffd0b 	ldhu	r2,-12(fp)
   25c5c:	1004d23a 	srli	r2,r2,8
   25c60:	10bfffcc 	andi	r2,r2,65535
   25c64:	100b883a 	mov	r5,r2
   25c68:	e13ffb17 	ldw	r4,-20(fp)
   25c6c:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(y0);     // YSTART
   25c70:	e0bffd0b 	ldhu	r2,-12(fp)
   25c74:	10803fcc 	andi	r2,r2,255
   25c78:	100b883a 	mov	r5,r2
   25c7c:	e13ffb17 	ldw	r4,-20(fp)
   25c80:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(y1>>8);
   25c84:	e0bfff0b 	ldhu	r2,-4(fp)
   25c88:	1004d23a 	srli	r2,r2,8
   25c8c:	10bfffcc 	andi	r2,r2,65535
   25c90:	100b883a 	mov	r5,r2
   25c94:	e13ffb17 	ldw	r4,-20(fp)
   25c98:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
	writedata(y1);     // YEND
   25c9c:	e0bfff0b 	ldhu	r2,-4(fp)
   25ca0:	10803fcc 	andi	r2,r2,255
   25ca4:	100b883a 	mov	r5,r2
   25ca8:	e13ffb17 	ldw	r4,-20(fp)
   25cac:	00250a80 	call	250a8 <_ZN7Display9writedataEh>

	writecommand(ILI9341_RAMWR); // write to RAM
   25cb0:	01400b04 	movi	r5,44
   25cb4:	e13ffb17 	ldw	r4,-20(fp)
   25cb8:	00250600 	call	25060 <_ZN7Display12writecommandEh>
}
   25cbc:	0001883a 	nop
   25cc0:	e037883a 	mov	sp,fp
   25cc4:	dfc00117 	ldw	ra,4(sp)
   25cc8:	df000017 	ldw	fp,0(sp)
   25ccc:	dec00204 	addi	sp,sp,8
   25cd0:	f800283a 	ret

00025cd4 <_ZN7Display5cp437Eb>:

void Display::cp437(bool x=true) {
   25cd4:	defffd04 	addi	sp,sp,-12
   25cd8:	df000215 	stw	fp,8(sp)
   25cdc:	df000204 	addi	fp,sp,8
   25ce0:	e13ffe15 	stw	r4,-8(fp)
   25ce4:	2805883a 	mov	r2,r5
   25ce8:	e0bfff05 	stb	r2,-4(fp)
	_cp437 = x;
   25cec:	e0bffe17 	ldw	r2,-8(fp)
   25cf0:	e0ffff03 	ldbu	r3,-4(fp)
   25cf4:	10c00145 	stb	r3,5(r2)
}
   25cf8:	0001883a 	nop
   25cfc:	e037883a 	mov	sp,fp
   25d00:	df000017 	ldw	fp,0(sp)
   25d04:	dec00104 	addi	sp,sp,4
   25d08:	f800283a 	ret

00025d0c <_ZN7Display11setRotationEh>:

void Display::setRotation(alt_u8 m) {
   25d0c:	defffc04 	addi	sp,sp,-16
   25d10:	dfc00315 	stw	ra,12(sp)
   25d14:	df000215 	stw	fp,8(sp)
   25d18:	df000204 	addi	fp,sp,8
   25d1c:	e13ffe15 	stw	r4,-8(fp)
   25d20:	2805883a 	mov	r2,r5
   25d24:	e0bfff05 	stb	r2,-4(fp)

  writecommand(ILI9341_MADCTL);
   25d28:	01400d84 	movi	r5,54
   25d2c:	e13ffe17 	ldw	r4,-8(fp)
   25d30:	00250600 	call	25060 <_ZN7Display12writecommandEh>
  _rotation = m % 4; // can't be higher than 3
   25d34:	e0bfff03 	ldbu	r2,-4(fp)
   25d38:	108000cc 	andi	r2,r2,3
   25d3c:	1007883a 	mov	r3,r2
   25d40:	e0bffe17 	ldw	r2,-8(fp)
   25d44:	10c00105 	stb	r3,4(r2)
  switch (_rotation) {
   25d48:	e0bffe17 	ldw	r2,-8(fp)
   25d4c:	10800103 	ldbu	r2,4(r2)
   25d50:	10803fcc 	andi	r2,r2,255
   25d54:	10c00060 	cmpeqi	r3,r2,1
   25d58:	1800131e 	bne	r3,zero,25da8 <_ZN7Display11setRotationEh+0x9c>
   25d5c:	10c00088 	cmpgei	r3,r2,2
   25d60:	1800021e 	bne	r3,zero,25d6c <_ZN7Display11setRotationEh+0x60>
   25d64:	10000626 	beq	r2,zero,25d80 <_ZN7Display11setRotationEh+0x74>
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
     _width  = ILI9341_TFTHEIGHT;
     _height = ILI9341_TFTWIDTH;
     break;
  }
}
   25d68:	00002d06 	br	25e20 <_ZN7Display11setRotationEh+0x114>

void Display::setRotation(alt_u8 m) {

  writecommand(ILI9341_MADCTL);
  _rotation = m % 4; // can't be higher than 3
  switch (_rotation) {
   25d6c:	10c000a0 	cmpeqi	r3,r2,2
   25d70:	1800171e 	bne	r3,zero,25dd0 <_ZN7Display11setRotationEh+0xc4>
   25d74:	108000e0 	cmpeqi	r2,r2,3
   25d78:	10001f1e 	bne	r2,zero,25df8 <_ZN7Display11setRotationEh+0xec>
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
     _width  = ILI9341_TFTHEIGHT;
     _height = ILI9341_TFTWIDTH;
     break;
  }
}
   25d7c:	00002806 	br	25e20 <_ZN7Display11setRotationEh+0x114>

  writecommand(ILI9341_MADCTL);
  _rotation = m % 4; // can't be higher than 3
  switch (_rotation) {
   case 0:
     writedata(MADCTL_MX | MADCTL_BGR);
   25d80:	01401204 	movi	r5,72
   25d84:	e13ffe17 	ldw	r4,-8(fp)
   25d88:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
     _width  = ILI9341_TFTWIDTH;
   25d8c:	e0bffe17 	ldw	r2,-8(fp)
   25d90:	00c03c04 	movi	r3,240
   25d94:	10c0000d 	sth	r3,0(r2)
     _height = ILI9341_TFTHEIGHT;
   25d98:	e0bffe17 	ldw	r2,-8(fp)
   25d9c:	00c05004 	movi	r3,320
   25da0:	10c0008d 	sth	r3,2(r2)
     break;
   25da4:	00001e06 	br	25e20 <_ZN7Display11setRotationEh+0x114>
   case 1:
     writedata(MADCTL_MV | MADCTL_BGR);
   25da8:	01400a04 	movi	r5,40
   25dac:	e13ffe17 	ldw	r4,-8(fp)
   25db0:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
     _width  = ILI9341_TFTHEIGHT;
   25db4:	e0bffe17 	ldw	r2,-8(fp)
   25db8:	00c05004 	movi	r3,320
   25dbc:	10c0000d 	sth	r3,0(r2)
     _height = ILI9341_TFTWIDTH;
   25dc0:	e0bffe17 	ldw	r2,-8(fp)
   25dc4:	00c03c04 	movi	r3,240
   25dc8:	10c0008d 	sth	r3,2(r2)
     break;
   25dcc:	00001406 	br	25e20 <_ZN7Display11setRotationEh+0x114>
  case 2:
    writedata(MADCTL_MY | MADCTL_BGR);
   25dd0:	01402204 	movi	r5,136
   25dd4:	e13ffe17 	ldw	r4,-8(fp)
   25dd8:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
     _width  = ILI9341_TFTWIDTH;
   25ddc:	e0bffe17 	ldw	r2,-8(fp)
   25de0:	00c03c04 	movi	r3,240
   25de4:	10c0000d 	sth	r3,0(r2)
     _height = ILI9341_TFTHEIGHT;
   25de8:	e0bffe17 	ldw	r2,-8(fp)
   25dec:	00c05004 	movi	r3,320
   25df0:	10c0008d 	sth	r3,2(r2)
    break;
   25df4:	00000a06 	br	25e20 <_ZN7Display11setRotationEh+0x114>
   case 3:
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
   25df8:	01403a04 	movi	r5,232
   25dfc:	e13ffe17 	ldw	r4,-8(fp)
   25e00:	00250a80 	call	250a8 <_ZN7Display9writedataEh>
     _width  = ILI9341_TFTHEIGHT;
   25e04:	e0bffe17 	ldw	r2,-8(fp)
   25e08:	00c05004 	movi	r3,320
   25e0c:	10c0000d 	sth	r3,0(r2)
     _height = ILI9341_TFTWIDTH;
   25e10:	e0bffe17 	ldw	r2,-8(fp)
   25e14:	00c03c04 	movi	r3,240
   25e18:	10c0008d 	sth	r3,2(r2)
     break;
   25e1c:	0001883a 	nop
  }
}
   25e20:	0001883a 	nop
   25e24:	e037883a 	mov	sp,fp
   25e28:	dfc00117 	ldw	ra,4(sp)
   25e2c:	df000017 	ldw	fp,0(sp)
   25e30:	dec00204 	addi	sp,sp,8
   25e34:	f800283a 	ret

00025e38 <_ZN5Drive13SetDriveSpeedEhh>:
bool Drive::block_front_dir = false;
bool Drive::block_rear_dir = false;
alt_u8 Drive::current_speed = 0;
alt_u8 Drive::current_direction = 0;

void Drive::SetDriveSpeed(alt_u8 direction, alt_u8 speed) {
   25e38:	defffb04 	addi	sp,sp,-20
   25e3c:	dfc00415 	stw	ra,16(sp)
   25e40:	df000315 	stw	fp,12(sp)
   25e44:	df000304 	addi	fp,sp,12
   25e48:	2007883a 	mov	r3,r4
   25e4c:	2805883a 	mov	r2,r5
   25e50:	e0fffe05 	stb	r3,-8(fp)
   25e54:	e0bfff05 	stb	r2,-4(fp)

	if(direction == 1) { //backwards
   25e58:	e0bffe03 	ldbu	r2,-8(fp)
   25e5c:	10800058 	cmpnei	r2,r2,1
   25e60:	10000d1e 	bne	r2,zero,25e98 <_ZN5Drive13SetDriveSpeedEhh+0x60>
		alt_u8 i = IORD_8DIRECT(GARFIELD_GPIO_BASE,0);
   25e64:	00801c04 	movi	r2,112
   25e68:	10800023 	ldbuio	r2,0(r2)
   25e6c:	10803fcc 	andi	r2,r2,255
   25e70:	e0bffd05 	stb	r2,-12(fp)
		i |= 1 << mot_dir_pin;
   25e74:	e0bffd03 	ldbu	r2,-12(fp)
   25e78:	10800054 	ori	r2,r2,1
   25e7c:	e0bffd05 	stb	r2,-12(fp)
		IOWR(GARFIELD_GPIO_BASE, 0, i);
   25e80:	e0fffd03 	ldbu	r3,-12(fp)
   25e84:	00801c04 	movi	r2,112
   25e88:	10c00035 	stwio	r3,0(r2)
		current_direction = 1;
   25e8c:	00800044 	movi	r2,1
   25e90:	d0a02d45 	stb	r2,-32587(gp)
   25e94:	00000c06 	br	25ec8 <_ZN5Drive13SetDriveSpeedEhh+0x90>
	}
	else { //default is forward
		alt_u8 i = IORD_8DIRECT(GARFIELD_GPIO_BASE,0);
   25e98:	00801c04 	movi	r2,112
   25e9c:	10800023 	ldbuio	r2,0(r2)
   25ea0:	10803fcc 	andi	r2,r2,255
   25ea4:	e0bffd45 	stb	r2,-11(fp)
		i &= ~(1 << mot_dir_pin);
   25ea8:	e0fffd43 	ldbu	r3,-11(fp)
   25eac:	00bfff84 	movi	r2,-2
   25eb0:	1884703a 	and	r2,r3,r2
   25eb4:	e0bffd45 	stb	r2,-11(fp)
		IOWR(GARFIELD_GPIO_BASE, 0, i);
   25eb8:	e0fffd43 	ldbu	r3,-11(fp)
   25ebc:	00801c04 	movi	r2,112
   25ec0:	10c00035 	stwio	r3,0(r2)
		current_direction = 0;
   25ec4:	d0202d45 	stb	zero,-32587(gp)
	}
	current_speed = speed;
   25ec8:	e0bfff03 	ldbu	r2,-4(fp)
   25ecc:	d0a02d05 	stb	r2,-32588(gp)
	PWMGen_Set_DutyCycle(DRIVE_PWM_BASE, (((alt_u32)max_speed_percent*(alt_u32)speed))/100);
   25ed0:	d0a000c3 	ldbu	r2,-32765(gp)
   25ed4:	10c03fcc 	andi	r3,r2,255
   25ed8:	e0bfff03 	ldbu	r2,-4(fp)
   25edc:	1885383a 	mul	r2,r3,r2
   25ee0:	01401904 	movi	r5,100
   25ee4:	1009883a 	mov	r4,r2
   25ee8:	0027dec0 	call	27dec <__udivsi3>
   25eec:	100b883a 	mov	r5,r2
   25ef0:	01002004 	movi	r4,128
   25ef4:	002ecdc0 	call	2ecdc <PWMGen_Set_DutyCycle>
}
   25ef8:	0001883a 	nop
   25efc:	e037883a 	mov	sp,fp
   25f00:	dfc00117 	ldw	ra,4(sp)
   25f04:	df000017 	ldw	fp,0(sp)
   25f08:	dec00204 	addi	sp,sp,8
   25f0c:	f800283a 	ret

00025f10 <_ZN5Drive11SetMaxSpeedEh>:

void Drive::SetMaxSpeed(alt_u8 max_percent_speed) {
   25f10:	defffe04 	addi	sp,sp,-8
   25f14:	df000115 	stw	fp,4(sp)
   25f18:	df000104 	addi	fp,sp,4
   25f1c:	2005883a 	mov	r2,r4
   25f20:	e0bfff05 	stb	r2,-4(fp)
	if(max_percent_speed >= 100) {
   25f24:	e0bfff03 	ldbu	r2,-4(fp)
   25f28:	10801930 	cmpltui	r2,r2,100
   25f2c:	1000021e 	bne	r2,zero,25f38 <_ZN5Drive11SetMaxSpeedEh+0x28>
		max_percent_speed = 100;
   25f30:	00801904 	movi	r2,100
   25f34:	e0bfff05 	stb	r2,-4(fp)
	}
	max_speed_percent = max_percent_speed;
   25f38:	e0bfff03 	ldbu	r2,-4(fp)
   25f3c:	d0a000c5 	stb	r2,-32765(gp)
}
   25f40:	0001883a 	nop
   25f44:	e037883a 	mov	sp,fp
   25f48:	df000017 	ldw	fp,0(sp)
   25f4c:	dec00104 	addi	sp,sp,4
   25f50:	f800283a 	ret

00025f54 <_ZN5Drive14setBlock_FrontEb>:

void Drive::setBlock_Front(bool val)
{
   25f54:	defffe04 	addi	sp,sp,-8
   25f58:	df000115 	stw	fp,4(sp)
   25f5c:	df000104 	addi	fp,sp,4
   25f60:	2005883a 	mov	r2,r4
   25f64:	e0bfff05 	stb	r2,-4(fp)
	Drive::block_front_dir = val;
   25f68:	e0bfff03 	ldbu	r2,-4(fp)
   25f6c:	d0a02c85 	stb	r2,-32590(gp)
}
   25f70:	0001883a 	nop
   25f74:	e037883a 	mov	sp,fp
   25f78:	df000017 	ldw	fp,0(sp)
   25f7c:	dec00104 	addi	sp,sp,4
   25f80:	f800283a 	ret

00025f84 <_ZN5Drive13SetBlock_RearEb>:
void Drive::SetBlock_Rear(bool val)
{
   25f84:	defffe04 	addi	sp,sp,-8
   25f88:	df000115 	stw	fp,4(sp)
   25f8c:	df000104 	addi	fp,sp,4
   25f90:	2005883a 	mov	r2,r4
   25f94:	e0bfff05 	stb	r2,-4(fp)
	Drive::block_rear_dir = val;
   25f98:	e0bfff03 	ldbu	r2,-4(fp)
   25f9c:	d0a02cc5 	stb	r2,-32589(gp)
}
   25fa0:	0001883a 	nop
   25fa4:	e037883a 	mov	sp,fp
   25fa8:	df000017 	ldw	fp,0(sp)
   25fac:	dec00104 	addi	sp,sp,4
   25fb0:	f800283a 	ret

00025fb4 <_ZN5Drive20GetCurrent_directionEv>:
alt_u8 Drive::GetCurrent_direction(void)
{
   25fb4:	deffff04 	addi	sp,sp,-4
   25fb8:	df000015 	stw	fp,0(sp)
   25fbc:	d839883a 	mov	fp,sp
	return current_direction;
   25fc0:	d0a02d43 	ldbu	r2,-32587(gp)
}
   25fc4:	e037883a 	mov	sp,fp
   25fc8:	df000017 	ldw	fp,0(sp)
   25fcc:	dec00104 	addi	sp,sp,4
   25fd0:	f800283a 	ret

00025fd4 <_ZN5Drive16GetCurrent_speedEv>:
alt_u8 Drive::GetCurrent_speed(void)
{
   25fd4:	deffff04 	addi	sp,sp,-4
   25fd8:	df000015 	stw	fp,0(sp)
   25fdc:	d839883a 	mov	fp,sp
	return current_speed;
   25fe0:	d0a02d03 	ldbu	r2,-32588(gp)
}
   25fe4:	e037883a 	mov	sp,fp
   25fe8:	df000017 	ldw	fp,0(sp)
   25fec:	dec00104 	addi	sp,sp,4
   25ff0:	f800283a 	ret

00025ff4 <_ZN5Drive20GetMax_Speed_PercentEv>:
alt_u8 Drive::GetMax_Speed_Percent(void)
{
   25ff4:	deffff04 	addi	sp,sp,-4
   25ff8:	df000015 	stw	fp,0(sp)
   25ffc:	d839883a 	mov	fp,sp
	return max_speed_percent;
   26000:	d0a000c3 	ldbu	r2,-32765(gp)
}
   26004:	e037883a 	mov	sp,fp
   26008:	df000017 	ldw	fp,0(sp)
   2600c:	dec00104 	addi	sp,sp,4
   26010:	f800283a 	ret

00026014 <_ZN5Drive14GetBlock_FrontEv>:
bool Drive::GetBlock_Front(void)
{
   26014:	deffff04 	addi	sp,sp,-4
   26018:	df000015 	stw	fp,0(sp)
   2601c:	d839883a 	mov	fp,sp
	return block_front_dir;
   26020:	d0a02c83 	ldbu	r2,-32590(gp)
}
   26024:	e037883a 	mov	sp,fp
   26028:	df000017 	ldw	fp,0(sp)
   2602c:	dec00104 	addi	sp,sp,4
   26030:	f800283a 	ret

00026034 <_ZN5Drive13GetBlock_RearEv>:
bool Drive::GetBlock_Rear(void)
{
   26034:	deffff04 	addi	sp,sp,-4
   26038:	df000015 	stw	fp,0(sp)
   2603c:	d839883a 	mov	fp,sp
	return block_rear_dir;
   26040:	d0a02cc3 	ldbu	r2,-32589(gp)
}
   26044:	e037883a 	mov	sp,fp
   26048:	df000017 	ldw	fp,0(sp)
   2604c:	dec00104 	addi	sp,sp,4
   26050:	f800283a 	ret

00026054 <_ZN8Steering4InitEh>:
#include "Steering.hpp"

alt_u8 Steering::max_angle_delta = 40;
float Steering::val_per_deg = 0;

void Steering::Init(alt_u8 max_angle) {
   26054:	defffd04 	addi	sp,sp,-12
   26058:	dfc00215 	stw	ra,8(sp)
   2605c:	df000115 	stw	fp,4(sp)
   26060:	df000104 	addi	fp,sp,4
   26064:	2005883a 	mov	r2,r4
   26068:	e0bfff05 	stb	r2,-4(fp)
	if(max_angle > MAX_STEERING_ANGLE) {
   2606c:	e0bfff03 	ldbu	r2,-4(fp)
   26070:	10800f70 	cmpltui	r2,r2,61
   26074:	1000031e 	bne	r2,zero,26084 <_ZN8Steering4InitEh+0x30>
		max_angle_delta = MAX_STEERING_ANGLE;
   26078:	00800f04 	movi	r2,60
   2607c:	d0a00105 	stb	r2,-32764(gp)
   26080:	00000206 	br	2608c <_ZN8Steering4InitEh+0x38>
	}
	else {
		max_angle_delta = max_angle;
   26084:	e0bfff03 	ldbu	r2,-4(fp)
   26088:	d0a00105 	stb	r2,-32764(gp)
	}
	val_per_deg = 19.0/60.0*((float)max_angle_delta/(float)max_steering_value);
   2608c:	d0a00103 	ldbu	r2,-32764(gp)
   26090:	10803fcc 	andi	r2,r2,255
   26094:	1009883a 	mov	r4,r2
   26098:	0028e180 	call	28e18 <__floatunsisf>
   2609c:	1007883a 	mov	r3,r2
   260a0:	0150ad34 	movhi	r5,17076
   260a4:	1809883a 	mov	r4,r3
   260a8:	0027ea80 	call	27ea8 <__divsf3>
   260ac:	1007883a 	mov	r3,r2
   260b0:	1805883a 	mov	r2,r3
   260b4:	1009883a 	mov	r4,r2
   260b8:	002b3900 	call	2b390 <__extendsfdf2>
   260bc:	1011883a 	mov	r8,r2
   260c0:	1813883a 	mov	r9,r3
   260c4:	01911134 	movhi	r6,17476
   260c8:	31911104 	addi	r6,r6,17476
   260cc:	01cff534 	movhi	r7,16340
   260d0:	39d11104 	addi	r7,r7,17476
   260d4:	4009883a 	mov	r4,r8
   260d8:	480b883a 	mov	r5,r9
   260dc:	002a1780 	call	2a178 <__muldf3>
   260e0:	1009883a 	mov	r4,r2
   260e4:	180b883a 	mov	r5,r3
   260e8:	2005883a 	mov	r2,r4
   260ec:	2807883a 	mov	r3,r5
   260f0:	1009883a 	mov	r4,r2
   260f4:	180b883a 	mov	r5,r3
   260f8:	002b4a00 	call	2b4a0 <__truncdfsf2>
   260fc:	1007883a 	mov	r3,r2
   26100:	d0e02e15 	stw	r3,-32584(gp)
}
   26104:	0001883a 	nop
   26108:	e037883a 	mov	sp,fp
   2610c:	dfc00117 	ldw	ra,4(sp)
   26110:	df000017 	ldw	fp,0(sp)
   26114:	dec00204 	addi	sp,sp,8
   26118:	f800283a 	ret

0002611c <_ZN8Steering3SetEa>:

void Steering::Set(alt_8 angle) {
   2611c:	defffd04 	addi	sp,sp,-12
   26120:	dfc00215 	stw	ra,8(sp)
   26124:	df000115 	stw	fp,4(sp)
   26128:	df000104 	addi	fp,sp,4
   2612c:	2005883a 	mov	r2,r4
   26130:	e0bfff05 	stb	r2,-4(fp)
	if(angle > max_steering_value) {
   26134:	e0bfff07 	ldb	r2,-4(fp)
   26138:	108016d0 	cmplti	r2,r2,91
   2613c:	1000031e 	bne	r2,zero,2614c <_ZN8Steering3SetEa+0x30>
		angle = max_steering_value;
   26140:	00801684 	movi	r2,90
   26144:	e0bfff05 	stb	r2,-4(fp)
   26148:	00000506 	br	26160 <_ZN8Steering3SetEa+0x44>
	}
	else if(angle < max_steering_value * -1) {
   2614c:	e0bfff07 	ldb	r2,-4(fp)
   26150:	10bfe988 	cmpgei	r2,r2,-90
   26154:	1000021e 	bne	r2,zero,26160 <_ZN8Steering3SetEa+0x44>
		angle = max_steering_value * -1;
   26158:	00bfe984 	movi	r2,-90
   2615c:	e0bfff05 	stb	r2,-4(fp)
	}
	PWMGen_Set_DutyCycle(STEERING_PWM_BASE, NEUTRAL_POS_VALUE - (val_per_deg*angle));
   26160:	e0bfff07 	ldb	r2,-4(fp)
   26164:	1009883a 	mov	r4,r2
   26168:	0028cf40 	call	28cf4 <__floatsisf>
   2616c:	1007883a 	mov	r3,r2
   26170:	d0a02e17 	ldw	r2,-32584(gp)
   26174:	100b883a 	mov	r5,r2
   26178:	1809883a 	mov	r4,r3
   2617c:	00283a40 	call	283a4 <__mulsf3>
   26180:	1007883a 	mov	r3,r2
   26184:	1805883a 	mov	r2,r3
   26188:	100b883a 	mov	r5,r2
   2618c:	01109334 	movhi	r4,16972
   26190:	00287a00 	call	287a0 <__subsf3>
   26194:	1007883a 	mov	r3,r2
   26198:	1805883a 	mov	r2,r3
   2619c:	1009883a 	mov	r4,r2
   261a0:	0027c200 	call	27c20 <__fixunssfsi>
   261a4:	100b883a 	mov	r5,r2
   261a8:	01002404 	movi	r4,144
   261ac:	002ecdc0 	call	2ecdc <PWMGen_Set_DutyCycle>
}
   261b0:	0001883a 	nop
   261b4:	e037883a 	mov	sp,fp
   261b8:	dfc00117 	ldw	ra,4(sp)
   261bc:	df000017 	ldw	fp,0(sp)
   261c0:	dec00204 	addi	sp,sp,8
   261c4:	f800283a 	ret

000261c8 <_ZN7mpu6050C1E17MPU6050_Addresses>:
#include "i2c_opencores.h"
#include "system.h"

#include "mpu6050.hpp"

mpu6050::mpu6050(MPU6050_Addresses deviceAddress) : __deviceAddress(deviceAddress), gyro_sens_factor(0.0), acc_sens_factor(0.0)
   261c8:	defffd04 	addi	sp,sp,-12
   261cc:	df000215 	stw	fp,8(sp)
   261d0:	df000204 	addi	fp,sp,8
   261d4:	e13ffe15 	stw	r4,-8(fp)
   261d8:	2805883a 	mov	r2,r5
   261dc:	e0bfff05 	stb	r2,-4(fp)
   261e0:	e0bffe17 	ldw	r2,-8(fp)
   261e4:	e0ffff03 	ldbu	r3,-4(fp)
   261e8:	10c00005 	stb	r3,0(r2)
   261ec:	e0bffe17 	ldw	r2,-8(fp)
   261f0:	10000115 	stw	zero,4(r2)
   261f4:	e0bffe17 	ldw	r2,-8(fp)
   261f8:	10000215 	stw	zero,8(r2)
{

}
   261fc:	0001883a 	nop
   26200:	e037883a 	mov	sp,fp
   26204:	df000017 	ldw	fp,0(sp)
   26208:	dec00104 	addi	sp,sp,4
   2620c:	f800283a 	ret

00026210 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings>:


alt_u8 mpu6050::InitMPU6050(AccelerometerSettings acc_sens, GyroscopeSettings gyro_sens)
{
   26210:	defffa04 	addi	sp,sp,-24
   26214:	dfc00515 	stw	ra,20(sp)
   26218:	df000415 	stw	fp,16(sp)
   2621c:	df000404 	addi	fp,sp,16
   26220:	e13ffd15 	stw	r4,-12(fp)
   26224:	2807883a 	mov	r3,r5
   26228:	3005883a 	mov	r2,r6
   2622c:	e0fffe05 	stb	r3,-8(fp)
   26230:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   26234:	00800044 	movi	r2,1
   26238:	e0bffc05 	stb	r2,-16(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   2623c:	e0bffd17 	ldw	r2,-12(fp)
   26240:	10800003 	ldbu	r2,0(r2)
   26244:	10803fcc 	andi	r2,r2,255
   26248:	000d883a 	mov	r6,zero
   2624c:	100b883a 	mov	r5,r2
   26250:	01200014 	movui	r4,32768
   26254:	00318f80 	call	318f8 <I2C_start>
	// wakes up the mpu6050 from sleep mode by writing to pwr_mgmt register
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::PWR_MGMT_1), 0);
   26258:	000d883a 	mov	r6,zero
   2625c:	01401ac4 	movi	r5,107
   26260:	01200014 	movui	r4,32768
   26264:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, 0x00, 1);
   26268:	01800044 	movi	r6,1
   2626c:	000b883a 	mov	r5,zero
   26270:	01200014 	movui	r4,32768
   26274:	0031a080 	call	31a08 <I2C_write>

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26278:	e0bffd17 	ldw	r2,-12(fp)
   2627c:	10800003 	ldbu	r2,0(r2)
   26280:	10803fcc 	andi	r2,r2,255
   26284:	000d883a 	mov	r6,zero
   26288:	100b883a 	mov	r5,r2
   2628c:	01200014 	movui	r4,32768
   26290:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_CONFIG), 0);
   26294:	000d883a 	mov	r6,zero
   26298:	01400704 	movi	r5,28
   2629c:	01200014 	movui	r4,32768
   262a0:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(acc_sens), 1);
   262a4:	e0bffe03 	ldbu	r2,-8(fp)
   262a8:	01800044 	movi	r6,1
   262ac:	100b883a 	mov	r5,r2
   262b0:	01200014 	movui	r4,32768
   262b4:	0031a080 	call	31a08 <I2C_write>

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   262b8:	e0bffd17 	ldw	r2,-12(fp)
   262bc:	10800003 	ldbu	r2,0(r2)
   262c0:	10803fcc 	andi	r2,r2,255
   262c4:	000d883a 	mov	r6,zero
   262c8:	100b883a 	mov	r5,r2
   262cc:	01200014 	movui	r4,32768
   262d0:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_CONFIG), 0);
   262d4:	000d883a 	mov	r6,zero
   262d8:	014006c4 	movi	r5,27
   262dc:	01200014 	movui	r4,32768
   262e0:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(gyro_sens), 1);
   262e4:	e0bfff03 	ldbu	r2,-4(fp)
   262e8:	01800044 	movi	r6,1
   262ec:	100b883a 	mov	r5,r2
   262f0:	01200014 	movui	r4,32768
   262f4:	0031a080 	call	31a08 <I2C_write>

	switch (gyro_sens)
   262f8:	e0bfff03 	ldbu	r2,-4(fp)
   262fc:	10c00220 	cmpeqi	r3,r2,8
   26300:	18000e1e 	bne	r3,zero,2633c <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x12c>
   26304:	10c00268 	cmpgeui	r3,r2,9
   26308:	1800021e 	bne	r3,zero,26314 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x104>
   2630c:	10000626 	beq	r2,zero,26328 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x118>
   26310:	00001906 	br	26378 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x168>
   26314:	10c00420 	cmpeqi	r3,r2,16
   26318:	18000d1e 	bne	r3,zero,26350 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x140>
   2631c:	10800620 	cmpeqi	r2,r2,24
   26320:	1000101e 	bne	r2,zero,26364 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x154>
   26324:	00001406 	br	26378 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x168>
	{
	case GyroscopeSettings::RANGE_250_DEG:
		gyro_sens_factor = gyroscope_sensitivity_250_degree;
   26328:	e0fffd17 	ldw	r3,-12(fp)
   2632c:	008efeb4 	movhi	r2,15354
   26330:	1088cb44 	addi	r2,r2,9005
   26334:	18800115 	stw	r2,4(r3)
		break;
   26338:	00000f06 	br	26378 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x168>
	case GyroscopeSettings::RANGE_500_DEG:
		gyro_sens_factor = gyroscope_sensitivity_500_degree;
   2633c:	e0fffd17 	ldw	r3,-12(fp)
   26340:	008f1eb4 	movhi	r2,15482
   26344:	1088cb44 	addi	r2,r2,9005
   26348:	18800115 	stw	r2,4(r3)
		break;
   2634c:	00000a06 	br	26378 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x168>
	case GyroscopeSettings::RANGE_1000_DEG:
		gyro_sens_factor = gyroscope_sensitivity_1000_degree;
   26350:	e0fffd17 	ldw	r3,-12(fp)
   26354:	008f3eb4 	movhi	r2,15610
   26358:	10b06404 	addi	r2,r2,-15984
   2635c:	18800115 	stw	r2,4(r3)
		break;
   26360:	00000506 	br	26378 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x168>
	case GyroscopeSettings::RANGE_2000_DEG:
		gyro_sens_factor = gyroscope_sensitivity_2000_degree;
   26364:	e0fffd17 	ldw	r3,-12(fp)
   26368:	008f5eb4 	movhi	r2,15738
   2636c:	10b06404 	addi	r2,r2,-15984
   26370:	18800115 	stw	r2,4(r3)
		break;
   26374:	0001883a 	nop
	}

	switch ( acc_sens )
   26378:	e0bffe03 	ldbu	r2,-8(fp)
   2637c:	10c00220 	cmpeqi	r3,r2,8
   26380:	18000d1e 	bne	r3,zero,263b8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1a8>
   26384:	10c00268 	cmpgeui	r3,r2,9
   26388:	1800021e 	bne	r3,zero,26394 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x184>
   2638c:	10000626 	beq	r2,zero,263a8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x198>
   26390:	00001506 	br	263e8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1d8>
   26394:	10c00420 	cmpeqi	r3,r2,16
   26398:	18000b1e 	bne	r3,zero,263c8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1b8>
   2639c:	10800620 	cmpeqi	r2,r2,24
   263a0:	10000d1e 	bne	r2,zero,263d8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1c8>
   263a4:	00001006 	br	263e8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1d8>
	{
	case AccelerometerSettings::RANGE_2G:
		acc_sens_factor = accelerometer_sensitivity_2g;
   263a8:	e0bffd17 	ldw	r2,-12(fp)
   263ac:	00ce2034 	movhi	r3,14464
   263b0:	10c00215 	stw	r3,8(r2)
		break;
   263b4:	00000c06 	br	263e8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1d8>
	case AccelerometerSettings::RANGE_4G:
		acc_sens_factor = accelerometer_sensitivity_4g;
   263b8:	e0bffd17 	ldw	r2,-12(fp)
   263bc:	00ce4034 	movhi	r3,14592
   263c0:	10c00215 	stw	r3,8(r2)
		break;
   263c4:	00000806 	br	263e8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1d8>
	case AccelerometerSettings::RANGE_8G:
		acc_sens_factor = accelerometer_sensitivity_8g;
   263c8:	e0bffd17 	ldw	r2,-12(fp)
   263cc:	00ce6034 	movhi	r3,14720
   263d0:	10c00215 	stw	r3,8(r2)
		break;
   263d4:	00000406 	br	263e8 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings+0x1d8>
	case AccelerometerSettings::RANGE_16G:
		acc_sens_factor = accelerometer_sensitivity_16g;
   263d8:	e0bffd17 	ldw	r2,-12(fp)
   263dc:	00ce8034 	movhi	r3,14848
   263e0:	10c00215 	stw	r3,8(r2)
		break;
   263e4:	0001883a 	nop
	}

	return result;
   263e8:	e0bffc03 	ldbu	r2,-16(fp)
}
   263ec:	e037883a 	mov	sp,fp
   263f0:	dfc00117 	ldw	ra,4(sp)
   263f4:	df000017 	ldw	fp,0(sp)
   263f8:	dec00204 	addi	sp,sp,8
   263fc:	f800283a 	ret

00026400 <_ZN7mpu605017ReadAccelerometerERNS_17AccelerometerDataE>:

alt_u8 mpu6050::ReadAccelerometer(AccelerometerData& acc_data)
{
   26400:	defffb04 	addi	sp,sp,-20
   26404:	dfc00415 	stw	ra,16(sp)
   26408:	df000315 	stw	fp,12(sp)
   2640c:	df000304 	addi	fp,sp,12
   26410:	e13ffe15 	stw	r4,-8(fp)
   26414:	e17fff15 	stw	r5,-4(fp)
	alt_u8 result = 1;
   26418:	00800044 	movi	r2,1
   2641c:	e0bffd05 	stb	r2,-12(fp)
	alt_16 acc_data_tmp = 0;
   26420:	e03ffd8d 	sth	zero,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26424:	e0bffe17 	ldw	r2,-8(fp)
   26428:	10800003 	ldbu	r2,0(r2)
   2642c:	10803fcc 	andi	r2,r2,255
   26430:	000d883a 	mov	r6,zero
   26434:	100b883a 	mov	r5,r2
   26438:	01200014 	movui	r4,32768
   2643c:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_XOUT_H), 1);
   26440:	01800044 	movi	r6,1
   26444:	01400ec4 	movi	r5,59
   26448:	01200014 	movui	r4,32768
   2644c:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26450:	e0bffe17 	ldw	r2,-8(fp)
   26454:	10800003 	ldbu	r2,0(r2)
   26458:	10803fcc 	andi	r2,r2,255
   2645c:	01800044 	movi	r6,1
   26460:	100b883a 	mov	r5,r2
   26464:	01200014 	movui	r4,32768
   26468:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   2646c:	01400044 	movi	r5,1
   26470:	01200014 	movui	r4,32768
   26474:	003198c0 	call	3198c <I2C_read>
   26478:	1004923a 	slli	r2,r2,8
   2647c:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26480:	e0bffe17 	ldw	r2,-8(fp)
   26484:	10800003 	ldbu	r2,0(r2)
   26488:	10803fcc 	andi	r2,r2,255
   2648c:	000d883a 	mov	r6,zero
   26490:	100b883a 	mov	r5,r2
   26494:	01200014 	movui	r4,32768
   26498:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_XOUT_L), 1);
   2649c:	01800044 	movi	r6,1
   264a0:	01400f04 	movi	r5,60
   264a4:	01200014 	movui	r4,32768
   264a8:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   264ac:	e0bffe17 	ldw	r2,-8(fp)
   264b0:	10800003 	ldbu	r2,0(r2)
   264b4:	10803fcc 	andi	r2,r2,255
   264b8:	01800044 	movi	r6,1
   264bc:	100b883a 	mov	r5,r2
   264c0:	01200014 	movui	r4,32768
   264c4:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   264c8:	01400044 	movi	r5,1
   264cc:	01200014 	movui	r4,32768
   264d0:	003198c0 	call	3198c <I2C_read>
   264d4:	1007883a 	mov	r3,r2
   264d8:	e0bffd8b 	ldhu	r2,-10(fp)
   264dc:	1884b03a 	or	r2,r3,r2
   264e0:	e0bffd8d 	sth	r2,-10(fp)

	acc_data.acc_x = acc_data_tmp * acc_sens_factor;
   264e4:	e0bffd8f 	ldh	r2,-10(fp)
   264e8:	1009883a 	mov	r4,r2
   264ec:	0028cf40 	call	28cf4 <__floatsisf>
   264f0:	1009883a 	mov	r4,r2
   264f4:	e0bffe17 	ldw	r2,-8(fp)
   264f8:	10c00217 	ldw	r3,8(r2)
   264fc:	180b883a 	mov	r5,r3
   26500:	00283a40 	call	283a4 <__mulsf3>
   26504:	1009883a 	mov	r4,r2
   26508:	2007883a 	mov	r3,r4
   2650c:	e0bfff17 	ldw	r2,-4(fp)
   26510:	10c00015 	stw	r3,0(r2)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26514:	e0bffe17 	ldw	r2,-8(fp)
   26518:	10800003 	ldbu	r2,0(r2)
   2651c:	10803fcc 	andi	r2,r2,255
   26520:	000d883a 	mov	r6,zero
   26524:	100b883a 	mov	r5,r2
   26528:	01200014 	movui	r4,32768
   2652c:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_YOUT_H), 1);
   26530:	01800044 	movi	r6,1
   26534:	01400f44 	movi	r5,61
   26538:	01200014 	movui	r4,32768
   2653c:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26540:	e0bffe17 	ldw	r2,-8(fp)
   26544:	10800003 	ldbu	r2,0(r2)
   26548:	10803fcc 	andi	r2,r2,255
   2654c:	01800044 	movi	r6,1
   26550:	100b883a 	mov	r5,r2
   26554:	01200014 	movui	r4,32768
   26558:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   2655c:	01400044 	movi	r5,1
   26560:	01200014 	movui	r4,32768
   26564:	003198c0 	call	3198c <I2C_read>
   26568:	1004923a 	slli	r2,r2,8
   2656c:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26570:	e0bffe17 	ldw	r2,-8(fp)
   26574:	10800003 	ldbu	r2,0(r2)
   26578:	10803fcc 	andi	r2,r2,255
   2657c:	000d883a 	mov	r6,zero
   26580:	100b883a 	mov	r5,r2
   26584:	01200014 	movui	r4,32768
   26588:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_YOUT_L), 1);
   2658c:	01800044 	movi	r6,1
   26590:	01400f84 	movi	r5,62
   26594:	01200014 	movui	r4,32768
   26598:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   2659c:	e0bffe17 	ldw	r2,-8(fp)
   265a0:	10800003 	ldbu	r2,0(r2)
   265a4:	10803fcc 	andi	r2,r2,255
   265a8:	01800044 	movi	r6,1
   265ac:	100b883a 	mov	r5,r2
   265b0:	01200014 	movui	r4,32768
   265b4:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   265b8:	01400044 	movi	r5,1
   265bc:	01200014 	movui	r4,32768
   265c0:	003198c0 	call	3198c <I2C_read>
   265c4:	1007883a 	mov	r3,r2
   265c8:	e0bffd8b 	ldhu	r2,-10(fp)
   265cc:	1884b03a 	or	r2,r3,r2
   265d0:	e0bffd8d 	sth	r2,-10(fp)

	acc_data.acc_y = acc_data_tmp * acc_sens_factor;
   265d4:	e0bffd8f 	ldh	r2,-10(fp)
   265d8:	1009883a 	mov	r4,r2
   265dc:	0028cf40 	call	28cf4 <__floatsisf>
   265e0:	1009883a 	mov	r4,r2
   265e4:	e0bffe17 	ldw	r2,-8(fp)
   265e8:	10c00217 	ldw	r3,8(r2)
   265ec:	180b883a 	mov	r5,r3
   265f0:	00283a40 	call	283a4 <__mulsf3>
   265f4:	1009883a 	mov	r4,r2
   265f8:	2007883a 	mov	r3,r4
   265fc:	e0bfff17 	ldw	r2,-4(fp)
   26600:	10c00115 	stw	r3,4(r2)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26604:	e0bffe17 	ldw	r2,-8(fp)
   26608:	10800003 	ldbu	r2,0(r2)
   2660c:	10803fcc 	andi	r2,r2,255
   26610:	000d883a 	mov	r6,zero
   26614:	100b883a 	mov	r5,r2
   26618:	01200014 	movui	r4,32768
   2661c:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_ZOUT_H), 1);
   26620:	01800044 	movi	r6,1
   26624:	01400fc4 	movi	r5,63
   26628:	01200014 	movui	r4,32768
   2662c:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26630:	e0bffe17 	ldw	r2,-8(fp)
   26634:	10800003 	ldbu	r2,0(r2)
   26638:	10803fcc 	andi	r2,r2,255
   2663c:	01800044 	movi	r6,1
   26640:	100b883a 	mov	r5,r2
   26644:	01200014 	movui	r4,32768
   26648:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   2664c:	01400044 	movi	r5,1
   26650:	01200014 	movui	r4,32768
   26654:	003198c0 	call	3198c <I2C_read>
   26658:	1004923a 	slli	r2,r2,8
   2665c:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26660:	e0bffe17 	ldw	r2,-8(fp)
   26664:	10800003 	ldbu	r2,0(r2)
   26668:	10803fcc 	andi	r2,r2,255
   2666c:	000d883a 	mov	r6,zero
   26670:	100b883a 	mov	r5,r2
   26674:	01200014 	movui	r4,32768
   26678:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::ACCEL_ZOUT_L), 1);
   2667c:	01800044 	movi	r6,1
   26680:	01401004 	movi	r5,64
   26684:	01200014 	movui	r4,32768
   26688:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   2668c:	e0bffe17 	ldw	r2,-8(fp)
   26690:	10800003 	ldbu	r2,0(r2)
   26694:	10803fcc 	andi	r2,r2,255
   26698:	01800044 	movi	r6,1
   2669c:	100b883a 	mov	r5,r2
   266a0:	01200014 	movui	r4,32768
   266a4:	00318f80 	call	318f8 <I2C_start>
	acc_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   266a8:	01400044 	movi	r5,1
   266ac:	01200014 	movui	r4,32768
   266b0:	003198c0 	call	3198c <I2C_read>
   266b4:	1007883a 	mov	r3,r2
   266b8:	e0bffd8b 	ldhu	r2,-10(fp)
   266bc:	1884b03a 	or	r2,r3,r2
   266c0:	e0bffd8d 	sth	r2,-10(fp)

	acc_data.acc_z = acc_data_tmp * acc_sens_factor;
   266c4:	e0bffd8f 	ldh	r2,-10(fp)
   266c8:	1009883a 	mov	r4,r2
   266cc:	0028cf40 	call	28cf4 <__floatsisf>
   266d0:	1009883a 	mov	r4,r2
   266d4:	e0bffe17 	ldw	r2,-8(fp)
   266d8:	10c00217 	ldw	r3,8(r2)
   266dc:	180b883a 	mov	r5,r3
   266e0:	00283a40 	call	283a4 <__mulsf3>
   266e4:	1009883a 	mov	r4,r2
   266e8:	2007883a 	mov	r3,r4
   266ec:	e0bfff17 	ldw	r2,-4(fp)
   266f0:	10c00215 	stw	r3,8(r2)

	return result;
   266f4:	e0bffd03 	ldbu	r2,-12(fp)
}
   266f8:	e037883a 	mov	sp,fp
   266fc:	dfc00117 	ldw	ra,4(sp)
   26700:	df000017 	ldw	fp,0(sp)
   26704:	dec00204 	addi	sp,sp,8
   26708:	f800283a 	ret

0002670c <_ZN7mpu605013ReadGyroscopeERNS_13GyroscopeDataE>:

alt_u8 mpu6050::ReadGyroscope(GyroscopeData& gyro_data)
{
   2670c:	defffb04 	addi	sp,sp,-20
   26710:	dfc00415 	stw	ra,16(sp)
   26714:	df000315 	stw	fp,12(sp)
   26718:	df000304 	addi	fp,sp,12
   2671c:	e13ffe15 	stw	r4,-8(fp)
   26720:	e17fff15 	stw	r5,-4(fp)
	alt_u8 result = 1;
   26724:	00800044 	movi	r2,1
   26728:	e0bffd05 	stb	r2,-12(fp)
	alt_16 gyro_data_tmp = 0;
   2672c:	e03ffd8d 	sth	zero,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26730:	e0bffe17 	ldw	r2,-8(fp)
   26734:	10800003 	ldbu	r2,0(r2)
   26738:	10803fcc 	andi	r2,r2,255
   2673c:	000d883a 	mov	r6,zero
   26740:	100b883a 	mov	r5,r2
   26744:	01200014 	movui	r4,32768
   26748:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_XOUT_H), 1);
   2674c:	01800044 	movi	r6,1
   26750:	014010c4 	movi	r5,67
   26754:	01200014 	movui	r4,32768
   26758:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   2675c:	e0bffe17 	ldw	r2,-8(fp)
   26760:	10800003 	ldbu	r2,0(r2)
   26764:	10803fcc 	andi	r2,r2,255
   26768:	01800044 	movi	r6,1
   2676c:	100b883a 	mov	r5,r2
   26770:	01200014 	movui	r4,32768
   26774:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   26778:	01400044 	movi	r5,1
   2677c:	01200014 	movui	r4,32768
   26780:	003198c0 	call	3198c <I2C_read>
   26784:	1004923a 	slli	r2,r2,8
   26788:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   2678c:	e0bffe17 	ldw	r2,-8(fp)
   26790:	10800003 	ldbu	r2,0(r2)
   26794:	10803fcc 	andi	r2,r2,255
   26798:	000d883a 	mov	r6,zero
   2679c:	100b883a 	mov	r5,r2
   267a0:	01200014 	movui	r4,32768
   267a4:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_XOUT_L), 1);
   267a8:	01800044 	movi	r6,1
   267ac:	01401104 	movi	r5,68
   267b0:	01200014 	movui	r4,32768
   267b4:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   267b8:	e0bffe17 	ldw	r2,-8(fp)
   267bc:	10800003 	ldbu	r2,0(r2)
   267c0:	10803fcc 	andi	r2,r2,255
   267c4:	01800044 	movi	r6,1
   267c8:	100b883a 	mov	r5,r2
   267cc:	01200014 	movui	r4,32768
   267d0:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   267d4:	01400044 	movi	r5,1
   267d8:	01200014 	movui	r4,32768
   267dc:	003198c0 	call	3198c <I2C_read>
   267e0:	1007883a 	mov	r3,r2
   267e4:	e0bffd8b 	ldhu	r2,-10(fp)
   267e8:	1884b03a 	or	r2,r3,r2
   267ec:	e0bffd8d 	sth	r2,-10(fp)

	gyro_data.gyro_x = gyro_data_tmp * gyro_sens_factor;
   267f0:	e0bffd8f 	ldh	r2,-10(fp)
   267f4:	1009883a 	mov	r4,r2
   267f8:	0028cf40 	call	28cf4 <__floatsisf>
   267fc:	1009883a 	mov	r4,r2
   26800:	e0bffe17 	ldw	r2,-8(fp)
   26804:	10c00117 	ldw	r3,4(r2)
   26808:	180b883a 	mov	r5,r3
   2680c:	00283a40 	call	283a4 <__mulsf3>
   26810:	1009883a 	mov	r4,r2
   26814:	2007883a 	mov	r3,r4
   26818:	e0bfff17 	ldw	r2,-4(fp)
   2681c:	10c00015 	stw	r3,0(r2)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26820:	e0bffe17 	ldw	r2,-8(fp)
   26824:	10800003 	ldbu	r2,0(r2)
   26828:	10803fcc 	andi	r2,r2,255
   2682c:	000d883a 	mov	r6,zero
   26830:	100b883a 	mov	r5,r2
   26834:	01200014 	movui	r4,32768
   26838:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_YOUT_H), 1);
   2683c:	01800044 	movi	r6,1
   26840:	01401144 	movi	r5,69
   26844:	01200014 	movui	r4,32768
   26848:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   2684c:	e0bffe17 	ldw	r2,-8(fp)
   26850:	10800003 	ldbu	r2,0(r2)
   26854:	10803fcc 	andi	r2,r2,255
   26858:	01800044 	movi	r6,1
   2685c:	100b883a 	mov	r5,r2
   26860:	01200014 	movui	r4,32768
   26864:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   26868:	01400044 	movi	r5,1
   2686c:	01200014 	movui	r4,32768
   26870:	003198c0 	call	3198c <I2C_read>
   26874:	1004923a 	slli	r2,r2,8
   26878:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   2687c:	e0bffe17 	ldw	r2,-8(fp)
   26880:	10800003 	ldbu	r2,0(r2)
   26884:	10803fcc 	andi	r2,r2,255
   26888:	000d883a 	mov	r6,zero
   2688c:	100b883a 	mov	r5,r2
   26890:	01200014 	movui	r4,32768
   26894:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_YOUT_L), 1);
   26898:	01800044 	movi	r6,1
   2689c:	01401184 	movi	r5,70
   268a0:	01200014 	movui	r4,32768
   268a4:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   268a8:	e0bffe17 	ldw	r2,-8(fp)
   268ac:	10800003 	ldbu	r2,0(r2)
   268b0:	10803fcc 	andi	r2,r2,255
   268b4:	01800044 	movi	r6,1
   268b8:	100b883a 	mov	r5,r2
   268bc:	01200014 	movui	r4,32768
   268c0:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   268c4:	01400044 	movi	r5,1
   268c8:	01200014 	movui	r4,32768
   268cc:	003198c0 	call	3198c <I2C_read>
   268d0:	1007883a 	mov	r3,r2
   268d4:	e0bffd8b 	ldhu	r2,-10(fp)
   268d8:	1884b03a 	or	r2,r3,r2
   268dc:	e0bffd8d 	sth	r2,-10(fp)

	gyro_data.gyro_y = gyro_data_tmp * gyro_sens_factor;
   268e0:	e0bffd8f 	ldh	r2,-10(fp)
   268e4:	1009883a 	mov	r4,r2
   268e8:	0028cf40 	call	28cf4 <__floatsisf>
   268ec:	1009883a 	mov	r4,r2
   268f0:	e0bffe17 	ldw	r2,-8(fp)
   268f4:	10c00117 	ldw	r3,4(r2)
   268f8:	180b883a 	mov	r5,r3
   268fc:	00283a40 	call	283a4 <__mulsf3>
   26900:	1009883a 	mov	r4,r2
   26904:	2007883a 	mov	r3,r4
   26908:	e0bfff17 	ldw	r2,-4(fp)
   2690c:	10c00115 	stw	r3,4(r2)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26910:	e0bffe17 	ldw	r2,-8(fp)
   26914:	10800003 	ldbu	r2,0(r2)
   26918:	10803fcc 	andi	r2,r2,255
   2691c:	000d883a 	mov	r6,zero
   26920:	100b883a 	mov	r5,r2
   26924:	01200014 	movui	r4,32768
   26928:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_ZOUT_H), 1);
   2692c:	01800044 	movi	r6,1
   26930:	014011c4 	movi	r5,71
   26934:	01200014 	movui	r4,32768
   26938:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   2693c:	e0bffe17 	ldw	r2,-8(fp)
   26940:	10800003 	ldbu	r2,0(r2)
   26944:	10803fcc 	andi	r2,r2,255
   26948:	01800044 	movi	r6,1
   2694c:	100b883a 	mov	r5,r2
   26950:	01200014 	movui	r4,32768
   26954:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   26958:	01400044 	movi	r5,1
   2695c:	01200014 	movui	r4,32768
   26960:	003198c0 	call	3198c <I2C_read>
   26964:	1004923a 	slli	r2,r2,8
   26968:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   2696c:	e0bffe17 	ldw	r2,-8(fp)
   26970:	10800003 	ldbu	r2,0(r2)
   26974:	10803fcc 	andi	r2,r2,255
   26978:	000d883a 	mov	r6,zero
   2697c:	100b883a 	mov	r5,r2
   26980:	01200014 	movui	r4,32768
   26984:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::GYRO_ZOUT_L), 1);
   26988:	01800044 	movi	r6,1
   2698c:	01401204 	movi	r5,72
   26990:	01200014 	movui	r4,32768
   26994:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26998:	e0bffe17 	ldw	r2,-8(fp)
   2699c:	10800003 	ldbu	r2,0(r2)
   269a0:	10803fcc 	andi	r2,r2,255
   269a4:	01800044 	movi	r6,1
   269a8:	100b883a 	mov	r5,r2
   269ac:	01200014 	movui	r4,32768
   269b0:	00318f80 	call	318f8 <I2C_start>
	gyro_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   269b4:	01400044 	movi	r5,1
   269b8:	01200014 	movui	r4,32768
   269bc:	003198c0 	call	3198c <I2C_read>
   269c0:	1007883a 	mov	r3,r2
   269c4:	e0bffd8b 	ldhu	r2,-10(fp)
   269c8:	1884b03a 	or	r2,r3,r2
   269cc:	e0bffd8d 	sth	r2,-10(fp)

	gyro_data.gyro_z = gyro_data_tmp * gyro_sens_factor;
   269d0:	e0bffd8f 	ldh	r2,-10(fp)
   269d4:	1009883a 	mov	r4,r2
   269d8:	0028cf40 	call	28cf4 <__floatsisf>
   269dc:	1009883a 	mov	r4,r2
   269e0:	e0bffe17 	ldw	r2,-8(fp)
   269e4:	10c00117 	ldw	r3,4(r2)
   269e8:	180b883a 	mov	r5,r3
   269ec:	00283a40 	call	283a4 <__mulsf3>
   269f0:	1009883a 	mov	r4,r2
   269f4:	2007883a 	mov	r3,r4
   269f8:	e0bfff17 	ldw	r2,-4(fp)
   269fc:	10c00215 	stw	r3,8(r2)

	return result;
   26a00:	e0bffd03 	ldbu	r2,-12(fp)
}
   26a04:	e037883a 	mov	sp,fp
   26a08:	dfc00117 	ldw	ra,4(sp)
   26a0c:	df000017 	ldw	fp,0(sp)
   26a10:	dec00204 	addi	sp,sp,8
   26a14:	f800283a 	ret

00026a18 <_ZN7mpu605015ReadTemperatureERf>:

alt_u8 mpu6050::ReadTemperature(temp& temp_data)
{
   26a18:	defffb04 	addi	sp,sp,-20
   26a1c:	dfc00415 	stw	ra,16(sp)
   26a20:	df000315 	stw	fp,12(sp)
   26a24:	df000304 	addi	fp,sp,12
   26a28:	e13ffe15 	stw	r4,-8(fp)
   26a2c:	e17fff15 	stw	r5,-4(fp)
	alt_u8 result = 1;
   26a30:	00800044 	movi	r2,1
   26a34:	e0bffd05 	stb	r2,-12(fp)
	alt_16 temp_data_tmp = 0;
   26a38:	e03ffd8d 	sth	zero,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26a3c:	e0bffe17 	ldw	r2,-8(fp)
   26a40:	10800003 	ldbu	r2,0(r2)
   26a44:	10803fcc 	andi	r2,r2,255
   26a48:	000d883a 	mov	r6,zero
   26a4c:	100b883a 	mov	r5,r2
   26a50:	01200014 	movui	r4,32768
   26a54:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::TEMP_OUT_H), 1);
   26a58:	01800044 	movi	r6,1
   26a5c:	01401044 	movi	r5,65
   26a60:	01200014 	movui	r4,32768
   26a64:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26a68:	e0bffe17 	ldw	r2,-8(fp)
   26a6c:	10800003 	ldbu	r2,0(r2)
   26a70:	10803fcc 	andi	r2,r2,255
   26a74:	01800044 	movi	r6,1
   26a78:	100b883a 	mov	r5,r2
   26a7c:	01200014 	movui	r4,32768
   26a80:	00318f80 	call	318f8 <I2C_start>
	temp_data_tmp = (I2C_read(I2C_OPENCORES_0_BASE, 1) << 8);
   26a84:	01400044 	movi	r5,1
   26a88:	01200014 	movui	r4,32768
   26a8c:	003198c0 	call	3198c <I2C_read>
   26a90:	1004923a 	slli	r2,r2,8
   26a94:	e0bffd8d 	sth	r2,-10(fp)

	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26a98:	e0bffe17 	ldw	r2,-8(fp)
   26a9c:	10800003 	ldbu	r2,0(r2)
   26aa0:	10803fcc 	andi	r2,r2,255
   26aa4:	000d883a 	mov	r6,zero
   26aa8:	100b883a 	mov	r5,r2
   26aac:	01200014 	movui	r4,32768
   26ab0:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::TEMP_OUT_L), 1);
   26ab4:	01800044 	movi	r6,1
   26ab8:	01401084 	movi	r5,66
   26abc:	01200014 	movui	r4,32768
   26ac0:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26ac4:	e0bffe17 	ldw	r2,-8(fp)
   26ac8:	10800003 	ldbu	r2,0(r2)
   26acc:	10803fcc 	andi	r2,r2,255
   26ad0:	01800044 	movi	r6,1
   26ad4:	100b883a 	mov	r5,r2
   26ad8:	01200014 	movui	r4,32768
   26adc:	00318f80 	call	318f8 <I2C_start>
	temp_data_tmp |= I2C_read(I2C_OPENCORES_0_BASE, 1);
   26ae0:	01400044 	movi	r5,1
   26ae4:	01200014 	movui	r4,32768
   26ae8:	003198c0 	call	3198c <I2C_read>
   26aec:	1007883a 	mov	r3,r2
   26af0:	e0bffd8b 	ldhu	r2,-10(fp)
   26af4:	1884b03a 	or	r2,r3,r2
   26af8:	e0bffd8d 	sth	r2,-10(fp)

	temp_data = (temp_data_tmp / 340) + 36.53;
   26afc:	e0bffd8f 	ldh	r2,-10(fp)
   26b00:	01405504 	movi	r5,340
   26b04:	1009883a 	mov	r4,r2
   26b08:	0027cf40 	call	27cf4 <__divsi3>
   26b0c:	10bfffcc 	andi	r2,r2,65535
   26b10:	10a0001c 	xori	r2,r2,32768
   26b14:	10a00004 	addi	r2,r2,-32768
   26b18:	1009883a 	mov	r4,r2
   26b1c:	002b20c0 	call	2b20c <__floatsidf>
   26b20:	1011883a 	mov	r8,r2
   26b24:	1813883a 	mov	r9,r3
   26b28:	01828f74 	movhi	r6,2621
   26b2c:	319c2904 	addi	r6,r6,28836
   26b30:	01d010b4 	movhi	r7,16450
   26b34:	39d0f5c4 	addi	r7,r7,17367
   26b38:	4009883a 	mov	r4,r8
   26b3c:	480b883a 	mov	r5,r9
   26b40:	0028f080 	call	28f08 <__adddf3>
   26b44:	1009883a 	mov	r4,r2
   26b48:	180b883a 	mov	r5,r3
   26b4c:	2005883a 	mov	r2,r4
   26b50:	2807883a 	mov	r3,r5
   26b54:	1009883a 	mov	r4,r2
   26b58:	180b883a 	mov	r5,r3
   26b5c:	002b4a00 	call	2b4a0 <__truncdfsf2>
   26b60:	1007883a 	mov	r3,r2
   26b64:	e0bfff17 	ldw	r2,-4(fp)
   26b68:	10c00015 	stw	r3,0(r2)

	return result;
   26b6c:	e0bffd03 	ldbu	r2,-12(fp)
}
   26b70:	e037883a 	mov	sp,fp
   26b74:	dfc00117 	ldw	ra,4(sp)
   26b78:	df000017 	ldw	fp,0(sp)
   26b7c:	dec00204 	addi	sp,sp,8
   26b80:	f800283a 	ret

00026b84 <_ZN7mpu605010readStatusEv>:

alt_u8 mpu6050::readStatus(void)
{
   26b84:	defffd04 	addi	sp,sp,-12
   26b88:	dfc00215 	stw	ra,8(sp)
   26b8c:	df000115 	stw	fp,4(sp)
   26b90:	df000104 	addi	fp,sp,4
   26b94:	e13fff15 	stw	r4,-4(fp)
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26b98:	e0bfff17 	ldw	r2,-4(fp)
   26b9c:	10800003 	ldbu	r2,0(r2)
   26ba0:	10803fcc 	andi	r2,r2,255
   26ba4:	000d883a 	mov	r6,zero
   26ba8:	100b883a 	mov	r5,r2
   26bac:	01200014 	movui	r4,32768
   26bb0:	00318f80 	call	318f8 <I2C_start>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(MPU6050_Register::INT_STATUS), 1);
   26bb4:	01800044 	movi	r6,1
   26bb8:	01400e84 	movi	r5,58
   26bbc:	01200014 	movui	r4,32768
   26bc0:	0031a080 	call	31a08 <I2C_write>
	I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26bc4:	e0bfff17 	ldw	r2,-4(fp)
   26bc8:	10800003 	ldbu	r2,0(r2)
   26bcc:	10803fcc 	andi	r2,r2,255
   26bd0:	01800044 	movi	r6,1
   26bd4:	100b883a 	mov	r5,r2
   26bd8:	01200014 	movui	r4,32768
   26bdc:	00318f80 	call	318f8 <I2C_start>
	return (I2C_read(I2C_OPENCORES_0_BASE, 1) & 1);
   26be0:	01400044 	movi	r5,1
   26be4:	01200014 	movui	r4,32768
   26be8:	003198c0 	call	3198c <I2C_read>
   26bec:	1080004c 	andi	r2,r2,1
}
   26bf0:	e037883a 	mov	sp,fp
   26bf4:	dfc00117 	ldw	ra,4(sp)
   26bf8:	df000017 	ldw	fp,0(sp)
   26bfc:	dec00204 	addi	sp,sp,8
   26c00:	f800283a 	ret

00026c04 <_ZN16UltraSonicDeviceC1E17UltraSonicAddress>:
#include "i2c_opencores.h"
#include "system.h"

#include "ultrasonic.hpp"

UltraSonicDevice::UltraSonicDevice(const UltraSonicAddress deviceAddress) : __deviceAddress(deviceAddress)
   26c04:	defffd04 	addi	sp,sp,-12
   26c08:	df000215 	stw	fp,8(sp)
   26c0c:	df000204 	addi	fp,sp,8
   26c10:	e13ffe15 	stw	r4,-8(fp)
   26c14:	2805883a 	mov	r2,r5
   26c18:	e0bfff05 	stb	r2,-4(fp)
   26c1c:	e0bffe17 	ldw	r2,-8(fp)
   26c20:	e0ffff03 	ldbu	r3,-4(fp)
   26c24:	10c00005 	stb	r3,0(r2)
{

}
   26c28:	0001883a 	nop
   26c2c:	e037883a 	mov	sp,fp
   26c30:	df000017 	ldw	fp,0(sp)
   26c34:	dec00104 	addi	sp,sp,4
   26c38:	f800283a 	ret

00026c3c <_ZNK16UltraSonicDevice16writeCMDRegisterE18UltraSonicCommandsb>:


alt_u8 UltraSonicDevice::writeCMDRegister(const UltraSonicCommands val, const bool broadcast) const
{
   26c3c:	defffa04 	addi	sp,sp,-24
   26c40:	dfc00515 	stw	ra,20(sp)
   26c44:	df000415 	stw	fp,16(sp)
   26c48:	df000404 	addi	fp,sp,16
   26c4c:	e13ffd15 	stw	r4,-12(fp)
   26c50:	2807883a 	mov	r3,r5
   26c54:	3005883a 	mov	r2,r6
   26c58:	e0fffe05 	stb	r3,-8(fp)
   26c5c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   26c60:	00800044 	movi	r2,1
   26c64:	e0bffc05 	stb	r2,-16(fp)

	if( broadcast == false )
   26c68:	e0bfff03 	ldbu	r2,-4(fp)
   26c6c:	1080005c 	xori	r2,r2,1
   26c70:	10803fcc 	andi	r2,r2,255
   26c74:	10000926 	beq	r2,zero,26c9c <_ZNK16UltraSonicDevice16writeCMDRegisterE18UltraSonicCommandsb+0x60>
		result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26c78:	e0bffd17 	ldw	r2,-12(fp)
   26c7c:	10800003 	ldbu	r2,0(r2)
   26c80:	10803fcc 	andi	r2,r2,255
   26c84:	000d883a 	mov	r6,zero
   26c88:	100b883a 	mov	r5,r2
   26c8c:	01200014 	movui	r4,32768
   26c90:	00318f80 	call	318f8 <I2C_start>
   26c94:	e0bffc05 	stb	r2,-16(fp)
   26c98:	00000506 	br	26cb0 <_ZNK16UltraSonicDevice16writeCMDRegisterE18UltraSonicCommandsb+0x74>
	else
		result =I2C_start(I2C_OPENCORES_0_BASE, 0x00, 0);
   26c9c:	000d883a 	mov	r6,zero
   26ca0:	000b883a 	mov	r5,zero
   26ca4:	01200014 	movui	r4,32768
   26ca8:	00318f80 	call	318f8 <I2C_start>
   26cac:	e0bffc05 	stb	r2,-16(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND), 0);
   26cb0:	000d883a 	mov	r6,zero
   26cb4:	000b883a 	mov	r5,zero
   26cb8:	01200014 	movui	r4,32768
   26cbc:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(val), 1);
   26cc0:	e0bffe03 	ldbu	r2,-8(fp)
   26cc4:	01800044 	movi	r6,1
   26cc8:	100b883a 	mov	r5,r2
   26ccc:	01200014 	movui	r4,32768
   26cd0:	0031a080 	call	31a08 <I2C_write>

	return result;
   26cd4:	e0bffc03 	ldbu	r2,-16(fp)
}
   26cd8:	e037883a 	mov	sp,fp
   26cdc:	dfc00117 	ldw	ra,4(sp)
   26ce0:	df000017 	ldw	fp,0(sp)
   26ce4:	dec00204 	addi	sp,sp,8
   26ce8:	f800283a 	ret

00026cec <_ZNK16UltraSonicDevice17writeGAINRegisterEh>:

alt_u8 UltraSonicDevice::writeGAINRegister(const alt_u8 val) const
{
   26cec:	defffb04 	addi	sp,sp,-20
   26cf0:	dfc00415 	stw	ra,16(sp)
   26cf4:	df000315 	stw	fp,12(sp)
   26cf8:	df000304 	addi	fp,sp,12
   26cfc:	e13ffe15 	stw	r4,-8(fp)
   26d00:	2805883a 	mov	r2,r5
   26d04:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   26d08:	00800044 	movi	r2,1
   26d0c:	e0bffd05 	stb	r2,-12(fp)

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26d10:	e0bffe17 	ldw	r2,-8(fp)
   26d14:	10800003 	ldbu	r2,0(r2)
   26d18:	10803fcc 	andi	r2,r2,255
   26d1c:	000d883a 	mov	r6,zero
   26d20:	100b883a 	mov	r5,r2
   26d24:	01200014 	movui	r4,32768
   26d28:	00318f80 	call	318f8 <I2C_start>
   26d2c:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::MAX_GAIN), 0);
   26d30:	000d883a 	mov	r6,zero
   26d34:	01400044 	movi	r5,1
   26d38:	01200014 	movui	r4,32768
   26d3c:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(val), 1);
   26d40:	e0bfff03 	ldbu	r2,-4(fp)
   26d44:	01800044 	movi	r6,1
   26d48:	100b883a 	mov	r5,r2
   26d4c:	01200014 	movui	r4,32768
   26d50:	0031a080 	call	31a08 <I2C_write>

	return result;
   26d54:	e0bffd03 	ldbu	r2,-12(fp)
}
   26d58:	e037883a 	mov	sp,fp
   26d5c:	dfc00117 	ldw	ra,4(sp)
   26d60:	df000017 	ldw	fp,0(sp)
   26d64:	dec00204 	addi	sp,sp,8
   26d68:	f800283a 	ret

00026d6c <_ZNK16UltraSonicDevice18writeRANGERegisterEh>:

alt_u8 UltraSonicDevice::writeRANGERegister(const alt_u8 val) const
{
   26d6c:	defffb04 	addi	sp,sp,-20
   26d70:	dfc00415 	stw	ra,16(sp)
   26d74:	df000315 	stw	fp,12(sp)
   26d78:	df000304 	addi	fp,sp,12
   26d7c:	e13ffe15 	stw	r4,-8(fp)
   26d80:	2805883a 	mov	r2,r5
   26d84:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   26d88:	00800044 	movi	r2,1
   26d8c:	e0bffd05 	stb	r2,-12(fp)

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26d90:	e0bffe17 	ldw	r2,-8(fp)
   26d94:	10800003 	ldbu	r2,0(r2)
   26d98:	10803fcc 	andi	r2,r2,255
   26d9c:	000d883a 	mov	r6,zero
   26da0:	100b883a 	mov	r5,r2
   26da4:	01200014 	movui	r4,32768
   26da8:	00318f80 	call	318f8 <I2C_start>
   26dac:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::RANGE), 0);
   26db0:	000d883a 	mov	r6,zero
   26db4:	01400084 	movi	r5,2
   26db8:	01200014 	movui	r4,32768
   26dbc:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(val), 1);
   26dc0:	e0bfff03 	ldbu	r2,-4(fp)
   26dc4:	01800044 	movi	r6,1
   26dc8:	100b883a 	mov	r5,r2
   26dcc:	01200014 	movui	r4,32768
   26dd0:	0031a080 	call	31a08 <I2C_write>

	return result;
   26dd4:	e0bffd03 	ldbu	r2,-12(fp)
}
   26dd8:	e037883a 	mov	sp,fp
   26ddc:	dfc00117 	ldw	ra,4(sp)
   26de0:	df000017 	ldw	fp,0(sp)
   26de4:	dec00204 	addi	sp,sp,8
   26de8:	f800283a 	ret

00026dec <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt>:

alt_u8 UltraSonicDevice::readRegister(const UltraSonicRegisterRead reg, alt_u16& readPtr) const
{
   26dec:	defffa04 	addi	sp,sp,-24
   26df0:	dfc00515 	stw	ra,20(sp)
   26df4:	df000415 	stw	fp,16(sp)
   26df8:	df000404 	addi	fp,sp,16
   26dfc:	e13ffd15 	stw	r4,-12(fp)
   26e00:	2805883a 	mov	r2,r5
   26e04:	e1bfff15 	stw	r6,-4(fp)
   26e08:	e0bffe05 	stb	r2,-8(fp)
	alt_u8 result = 1;
   26e0c:	00800044 	movi	r2,1
   26e10:	e0bffc05 	stb	r2,-16(fp)
	alt_u8 hlp;

	// start IIC communication
	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26e14:	e0bffd17 	ldw	r2,-12(fp)
   26e18:	10800003 	ldbu	r2,0(r2)
   26e1c:	10803fcc 	andi	r2,r2,255
   26e20:	000d883a 	mov	r6,zero
   26e24:	100b883a 	mov	r5,r2
   26e28:	01200014 	movui	r4,32768
   26e2c:	00318f80 	call	318f8 <I2C_start>
   26e30:	e0bffc05 	stb	r2,-16(fp)
	// write which register must be read
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(reg), 1);
   26e34:	e0bffe03 	ldbu	r2,-8(fp)
   26e38:	01800044 	movi	r6,1
   26e3c:	100b883a 	mov	r5,r2
   26e40:	01200014 	movui	r4,32768
   26e44:	0031a080 	call	31a08 <I2C_write>

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26e48:	e0bffd17 	ldw	r2,-12(fp)
   26e4c:	10800003 	ldbu	r2,0(r2)
   26e50:	10803fcc 	andi	r2,r2,255
   26e54:	01800044 	movi	r6,1
   26e58:	100b883a 	mov	r5,r2
   26e5c:	01200014 	movui	r4,32768
   26e60:	00318f80 	call	318f8 <I2C_start>
   26e64:	e0bffc05 	stb	r2,-16(fp)
	// read the actual register
	hlp = I2C_read(I2C_OPENCORES_0_BASE, 1);
   26e68:	01400044 	movi	r5,1
   26e6c:	01200014 	movui	r4,32768
   26e70:	003198c0 	call	3198c <I2C_read>
   26e74:	e0bffc45 	stb	r2,-15(fp)

	if( reg != UltraSonicRegisterRead::SW_REVISION && reg != UltraSonicRegisterRead::LIGHT_SENSOR)
   26e78:	e0bffe03 	ldbu	r2,-8(fp)
   26e7c:	10002426 	beq	r2,zero,26f10 <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt+0x124>
   26e80:	e0bffe03 	ldbu	r2,-8(fp)
   26e84:	10800060 	cmpeqi	r2,r2,1
   26e88:	1000211e 	bne	r2,zero,26f10 <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt+0x124>
	{
			result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26e8c:	e0bffd17 	ldw	r2,-12(fp)
   26e90:	10800003 	ldbu	r2,0(r2)
   26e94:	10803fcc 	andi	r2,r2,255
   26e98:	000d883a 	mov	r6,zero
   26e9c:	100b883a 	mov	r5,r2
   26ea0:	01200014 	movui	r4,32768
   26ea4:	00318f80 	call	318f8 <I2C_start>
   26ea8:	e0bffc05 	stb	r2,-16(fp)
			I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(reg) + 1, 1); // read the low byte
   26eac:	e0bffe03 	ldbu	r2,-8(fp)
   26eb0:	10800044 	addi	r2,r2,1
   26eb4:	10803fcc 	andi	r2,r2,255
   26eb8:	01800044 	movi	r6,1
   26ebc:	100b883a 	mov	r5,r2
   26ec0:	01200014 	movui	r4,32768
   26ec4:	0031a080 	call	31a08 <I2C_write>

			result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26ec8:	e0bffd17 	ldw	r2,-12(fp)
   26ecc:	10800003 	ldbu	r2,0(r2)
   26ed0:	10803fcc 	andi	r2,r2,255
   26ed4:	01800044 	movi	r6,1
   26ed8:	100b883a 	mov	r5,r2
   26edc:	01200014 	movui	r4,32768
   26ee0:	00318f80 	call	318f8 <I2C_start>
   26ee4:	e0bffc05 	stb	r2,-16(fp)
			readPtr = I2C_read(I2C_OPENCORES_0_BASE, 1) + ( hlp << 8);
   26ee8:	01400044 	movi	r5,1
   26eec:	01200014 	movui	r4,32768
   26ef0:	003198c0 	call	3198c <I2C_read>
   26ef4:	1007883a 	mov	r3,r2
   26ef8:	e0bffc43 	ldbu	r2,-15(fp)
   26efc:	1004923a 	slli	r2,r2,8
   26f00:	1885883a 	add	r2,r3,r2
   26f04:	1007883a 	mov	r3,r2
   26f08:	e0bfff17 	ldw	r2,-4(fp)
   26f0c:	10c0000d 	sth	r3,0(r2)
	}

	return result ;
   26f10:	e0bffc03 	ldbu	r2,-16(fp)
}
   26f14:	e037883a 	mov	sp,fp
   26f18:	dfc00117 	ldw	ra,4(sp)
   26f1c:	df000017 	ldw	fp,0(sp)
   26f20:	dec00204 	addi	sp,sp,8
   26f24:	f800283a 	ret

00026f28 <_ZNK16UltraSonicDevice15readMeasurementEPhh>:

alt_u8 UltraSonicDevice::readMeasurement(alt_u8* ultrasonic_measurement, const alt_u8 length) const
{
   26f28:	defffa04 	addi	sp,sp,-24
   26f2c:	dfc00515 	stw	ra,20(sp)
   26f30:	df000415 	stw	fp,16(sp)
   26f34:	df000404 	addi	fp,sp,16
   26f38:	e13ffd15 	stw	r4,-12(fp)
   26f3c:	e17ffe15 	stw	r5,-8(fp)
   26f40:	3005883a 	mov	r2,r6
   26f44:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   26f48:	00800044 	movi	r2,1
   26f4c:	e0bffc05 	stb	r2,-16(fp)

	if( length == 0 )
   26f50:	e0bfff03 	ldbu	r2,-4(fp)
   26f54:	1000021e 	bne	r2,zero,26f60 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0x38>
		result = 0;
   26f58:	e03ffc05 	stb	zero,-16(fp)
   26f5c:	00003206 	br	27028 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0x100>
	else
	{
		for(alt_u8 i = 1; i <= (length > 34 ? 34 : length); ++i) // start from register 1 to length, but max is 34
   26f60:	00800044 	movi	r2,1
   26f64:	e0bffc45 	stb	r2,-15(fp)
   26f68:	e0fffc43 	ldbu	r3,-15(fp)
   26f6c:	e0bfff03 	ldbu	r2,-4(fp)
   26f70:	108008e8 	cmpgeui	r2,r2,35
   26f74:	1000021e 	bne	r2,zero,26f80 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0x58>
   26f78:	e0bfff03 	ldbu	r2,-4(fp)
   26f7c:	00000106 	br	26f84 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0x5c>
   26f80:	00800884 	movi	r2,34
   26f84:	10c02816 	blt	r2,r3,27028 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0x100>
		{
			// write which register must be read; start with light sensor register
			result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   26f88:	e0bffd17 	ldw	r2,-12(fp)
   26f8c:	10800003 	ldbu	r2,0(r2)
   26f90:	10803fcc 	andi	r2,r2,255
   26f94:	000d883a 	mov	r6,zero
   26f98:	100b883a 	mov	r5,r2
   26f9c:	01200014 	movui	r4,32768
   26fa0:	00318f80 	call	318f8 <I2C_start>
   26fa4:	e0bffc05 	stb	r2,-16(fp)
			I2C_write(I2C_OPENCORES_0_BASE, i, 1);
   26fa8:	e0bffc43 	ldbu	r2,-15(fp)
   26fac:	01800044 	movi	r6,1
   26fb0:	100b883a 	mov	r5,r2
   26fb4:	01200014 	movui	r4,32768
   26fb8:	0031a080 	call	31a08 <I2C_write>

			// read the actual value from the register
			result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   26fbc:	e0bffd17 	ldw	r2,-12(fp)
   26fc0:	10800003 	ldbu	r2,0(r2)
   26fc4:	10803fcc 	andi	r2,r2,255
   26fc8:	01800044 	movi	r6,1
   26fcc:	100b883a 	mov	r5,r2
   26fd0:	01200014 	movui	r4,32768
   26fd4:	00318f80 	call	318f8 <I2C_start>
   26fd8:	e0bffc05 	stb	r2,-16(fp)
			*ultrasonic_measurement = I2C_read(I2C_OPENCORES_0_BASE, 1);
   26fdc:	01400044 	movi	r5,1
   26fe0:	01200014 	movui	r4,32768
   26fe4:	003198c0 	call	3198c <I2C_read>
   26fe8:	1007883a 	mov	r3,r2
   26fec:	e0bffe17 	ldw	r2,-8(fp)
   26ff0:	10c00005 	stb	r3,0(r2)
			if(*ultrasonic_measurement++ == 0x00) // no more objects were found, return
   26ff4:	e0bffe17 	ldw	r2,-8(fp)
   26ff8:	10c00044 	addi	r3,r2,1
   26ffc:	e0fffe15 	stw	r3,-8(fp)
   27000:	10800003 	ldbu	r2,0(r2)
   27004:	10803fcc 	andi	r2,r2,255
   27008:	1005003a 	cmpeq	r2,r2,zero
   2700c:	10803fcc 	andi	r2,r2,255
   27010:	1000041e 	bne	r2,zero,27024 <_ZNK16UltraSonicDevice15readMeasurementEPhh+0xfc>

	if( length == 0 )
		result = 0;
	else
	{
		for(alt_u8 i = 1; i <= (length > 34 ? 34 : length); ++i) // start from register 1 to length, but max is 34
   27014:	e0bffc43 	ldbu	r2,-15(fp)
   27018:	10800044 	addi	r2,r2,1
   2701c:	e0bffc45 	stb	r2,-15(fp)
   27020:	003fd106 	br	26f68 <__reset+0xfff86f68>

			// read the actual value from the register
			result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
			*ultrasonic_measurement = I2C_read(I2C_OPENCORES_0_BASE, 1);
			if(*ultrasonic_measurement++ == 0x00) // no more objects were found, return
				break;
   27024:	0001883a 	nop
		}
	}
	return result;
   27028:	e0bffc03 	ldbu	r2,-16(fp)
}
   2702c:	e037883a 	mov	sp,fp
   27030:	dfc00117 	ldw	ra,4(sp)
   27034:	df000017 	ldw	fp,0(sp)
   27038:	dec00204 	addi	sp,sp,8
   2703c:	f800283a 	ret

00027040 <_ZN16UltraSonicDevice13changeAddressE17UltraSonicAddress>:

alt_u8 UltraSonicDevice::changeAddress(const UltraSonicAddress newAddress)
{
   27040:	defffb04 	addi	sp,sp,-20
   27044:	dfc00415 	stw	ra,16(sp)
   27048:	df000315 	stw	fp,12(sp)
   2704c:	df000304 	addi	fp,sp,12
   27050:	e13ffe15 	stw	r4,-8(fp)
   27054:	2805883a 	mov	r2,r5
   27058:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 result = 1;
   2705c:	00800044 	movi	r2,1
   27060:	e0bffd05 	stb	r2,-12(fp)

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   27064:	e0bffe17 	ldw	r2,-8(fp)
   27068:	10800003 	ldbu	r2,0(r2)
   2706c:	10803fcc 	andi	r2,r2,255
   27070:	000d883a 	mov	r6,zero
   27074:	100b883a 	mov	r5,r2
   27078:	01200014 	movui	r4,32768
   2707c:	00318f80 	call	318f8 <I2C_start>
   27080:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND),0);
   27084:	000d883a 	mov	r6,zero
   27088:	000b883a 	mov	r5,zero
   2708c:	01200014 	movui	r4,32768
   27090:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicCommands::CHANGE_ADDRESS_COMMAND_1),1);
   27094:	01800044 	movi	r6,1
   27098:	01402804 	movi	r5,160
   2709c:	01200014 	movui	r4,32768
   270a0:	0031a080 	call	31a08 <I2C_write>

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   270a4:	e0bffe17 	ldw	r2,-8(fp)
   270a8:	10800003 	ldbu	r2,0(r2)
   270ac:	10803fcc 	andi	r2,r2,255
   270b0:	000d883a 	mov	r6,zero
   270b4:	100b883a 	mov	r5,r2
   270b8:	01200014 	movui	r4,32768
   270bc:	00318f80 	call	318f8 <I2C_start>
   270c0:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND),0);
   270c4:	000d883a 	mov	r6,zero
   270c8:	000b883a 	mov	r5,zero
   270cc:	01200014 	movui	r4,32768
   270d0:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicCommands::CHANGE_ADDRESS_COMMAND_2),1);
   270d4:	01800044 	movi	r6,1
   270d8:	01402a84 	movi	r5,170
   270dc:	01200014 	movui	r4,32768
   270e0:	0031a080 	call	31a08 <I2C_write>

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   270e4:	e0bffe17 	ldw	r2,-8(fp)
   270e8:	10800003 	ldbu	r2,0(r2)
   270ec:	10803fcc 	andi	r2,r2,255
   270f0:	000d883a 	mov	r6,zero
   270f4:	100b883a 	mov	r5,r2
   270f8:	01200014 	movui	r4,32768
   270fc:	00318f80 	call	318f8 <I2C_start>
   27100:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND),0);
   27104:	000d883a 	mov	r6,zero
   27108:	000b883a 	mov	r5,zero
   2710c:	01200014 	movui	r4,32768
   27110:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicCommands::CHANGE_ADDRESS_COMMAND_3),1);
   27114:	01800044 	movi	r6,1
   27118:	01402944 	movi	r5,165
   2711c:	01200014 	movui	r4,32768
   27120:	0031a080 	call	31a08 <I2C_write>

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   27124:	e0bffe17 	ldw	r2,-8(fp)
   27128:	10800003 	ldbu	r2,0(r2)
   2712c:	10803fcc 	andi	r2,r2,255
   27130:	000d883a 	mov	r6,zero
   27134:	100b883a 	mov	r5,r2
   27138:	01200014 	movui	r4,32768
   2713c:	00318f80 	call	318f8 <I2C_start>
   27140:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND),0);
   27144:	000d883a 	mov	r6,zero
   27148:	000b883a 	mov	r5,zero
   2714c:	01200014 	movui	r4,32768
   27150:	0031a080 	call	31a08 <I2C_write>
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(newAddress),1);
   27154:	e0bfff03 	ldbu	r2,-4(fp)
   27158:	01800044 	movi	r6,1
   2715c:	100b883a 	mov	r5,r2
   27160:	01200014 	movui	r4,32768
   27164:	0031a080 	call	31a08 <I2C_write>


	if( result == 0){ //all write operations were successful, save new device address
   27168:	e0bffd03 	ldbu	r2,-12(fp)
   2716c:	1000031e 	bne	r2,zero,2717c <_ZN16UltraSonicDevice13changeAddressE17UltraSonicAddress+0x13c>
		__deviceAddress = newAddress;
   27170:	e0bffe17 	ldw	r2,-8(fp)
   27174:	e0ffff03 	ldbu	r3,-4(fp)
   27178:	10c00005 	stb	r3,0(r2)
	}

	return result;
   2717c:	e0bffd03 	ldbu	r2,-12(fp)
}
   27180:	e037883a 	mov	sp,fp
   27184:	dfc00117 	ldw	ra,4(sp)
   27188:	df000017 	ldw	fp,0(sp)
   2718c:	dec00204 	addi	sp,sp,8
   27190:	f800283a 	ret

00027194 <_ZNK16UltraSonicDevice20checkUltraSonicStateERb>:

alt_u8 UltraSonicDevice::checkUltraSonicState(bool& check) const
{
   27194:	defffb04 	addi	sp,sp,-20
   27198:	dfc00415 	stw	ra,16(sp)
   2719c:	df000315 	stw	fp,12(sp)
   271a0:	df000304 	addi	fp,sp,12
   271a4:	e13ffe15 	stw	r4,-8(fp)
   271a8:	e17fff15 	stw	r5,-4(fp)
	alt_u8 result = 1;
   271ac:	00800044 	movi	r2,1
   271b0:	e0bffd05 	stb	r2,-12(fp)

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 0);
   271b4:	e0bffe17 	ldw	r2,-8(fp)
   271b8:	10800003 	ldbu	r2,0(r2)
   271bc:	10803fcc 	andi	r2,r2,255
   271c0:	000d883a 	mov	r6,zero
   271c4:	100b883a 	mov	r5,r2
   271c8:	01200014 	movui	r4,32768
   271cc:	00318f80 	call	318f8 <I2C_start>
   271d0:	e0bffd05 	stb	r2,-12(fp)
	I2C_write(I2C_OPENCORES_0_BASE, static_cast<alt_u8>(UltraSonicRegistersWrite::COMMAND), 1);
   271d4:	01800044 	movi	r6,1
   271d8:	000b883a 	mov	r5,zero
   271dc:	01200014 	movui	r4,32768
   271e0:	0031a080 	call	31a08 <I2C_write>

	result = I2C_start(I2C_OPENCORES_0_BASE, static_cast<alt_u32>(__deviceAddress), 1);
   271e4:	e0bffe17 	ldw	r2,-8(fp)
   271e8:	10800003 	ldbu	r2,0(r2)
   271ec:	10803fcc 	andi	r2,r2,255
   271f0:	01800044 	movi	r6,1
   271f4:	100b883a 	mov	r5,r2
   271f8:	01200014 	movui	r4,32768
   271fc:	00318f80 	call	318f8 <I2C_start>
   27200:	e0bffd05 	stb	r2,-12(fp)
	if( I2C_read(I2C_OPENCORES_0_BASE, 1) == 0xFF )
   27204:	01400044 	movi	r5,1
   27208:	01200014 	movui	r4,32768
   2720c:	003198c0 	call	3198c <I2C_read>
   27210:	10803fe0 	cmpeqi	r2,r2,255
   27214:	10803fcc 	andi	r2,r2,255
   27218:	10000426 	beq	r2,zero,2722c <_ZNK16UltraSonicDevice20checkUltraSonicStateERb+0x98>
		check = true;
   2721c:	e0bfff17 	ldw	r2,-4(fp)
   27220:	00c00044 	movi	r3,1
   27224:	10c00005 	stb	r3,0(r2)
   27228:	00000206 	br	27234 <_ZNK16UltraSonicDevice20checkUltraSonicStateERb+0xa0>
	else
		check = false;
   2722c:	e0bfff17 	ldw	r2,-4(fp)
   27230:	10000005 	stb	zero,0(r2)

	return result;
   27234:	e0bffd03 	ldbu	r2,-12(fp)
}
   27238:	e037883a 	mov	sp,fp
   2723c:	dfc00117 	ldw	ra,4(sp)
   27240:	df000017 	ldw	fp,0(sp)
   27244:	dec00204 	addi	sp,sp,8
   27248:	f800283a 	ret

0002724c <main>:
#include "tasks_nios.hpp"
#include "i2c_opencores.h"
#include "stdio.h"

int main()
{
   2724c:	defff904 	addi	sp,sp,-28
   27250:	dfc00615 	stw	ra,24(sp)
   27254:	df000515 	stw	fp,20(sp)
   27258:	df000504 	addi	fp,sp,20
	printf("Hello from Nios II!\n");
   2725c:	010000f4 	movhi	r4,3
   27260:	210ba204 	addi	r4,r4,11912
   27264:	002b9dc0 	call	2b9dc <puts>
	//lcd.setRotation(3);

	//lcd.writeLine("Start Application", ILI9341_DARKGREEN, 2);


	IOWR_ALTERA_AVALON_PIO_DATA(ONBOARD_LED_BASE, 0x0F);
   27268:	00c003c4 	movi	r3,15
   2726c:	00800074 	movhi	r2,1
   27270:	10801404 	addi	r2,r2,80
   27274:	10c00035 	stwio	r3,0(r2)
	/* init section */
	alt_irq_register(MAILBOX_ARM2NIOS_0_IRQ, 0, Mailbox_isr);
   27278:	018000b4 	movhi	r6,2
   2727c:	319e9104 	addi	r6,r6,31300
   27280:	000b883a 	mov	r5,zero
   27284:	010000c4 	movi	r4,3
   27288:	0020f9c0 	call	20f9c <alt_irq_register>
	I2C_init(I2C_OPENCORES_0_BASE, ALT_CPU_CPU_FREQ, 100000);
   2728c:	018000b4 	movhi	r6,2
   27290:	31a1a804 	addi	r6,r6,-31072
   27294:	0140bef4 	movhi	r5,763
   27298:	297c2004 	addi	r5,r5,-3968
   2729c:	01200014 	movui	r4,32768
   272a0:	00318440 	call	31844 <I2C_init>
	sharedMem.Init(SHARED_MEMORY_MASTER_NIOS_0_BASE, SHARED_MEMORY_MUTEX_MASTER_NIOS_0_BASE, MAILBOX_NIOS2ARM_0_BASE, SHARED_MEMORY_MASTER_HPS_0_BASE, SHARED_MEMORY_MUTEX_MASTER_HPS_0_BASE, MAILBOX_ARM2NIOS_0_BASE, 0x03, 0);
   272a4:	d8000415 	stw	zero,16(sp)
   272a8:	008000c4 	movi	r2,3
   272ac:	d8800315 	stw	r2,12(sp)
   272b0:	00803004 	movi	r2,192
   272b4:	d8800215 	stw	r2,8(sp)
   272b8:	00800174 	movhi	r2,5
   272bc:	d8800115 	stw	r2,4(sp)
   272c0:	008001b4 	movhi	r2,6
   272c4:	d8800015 	stw	r2,0(sp)
   272c8:	01c00074 	movhi	r7,1
   272cc:	39c00c04 	addi	r7,r7,48
   272d0:	01800234 	movhi	r6,8
   272d4:	01400274 	movhi	r5,9
   272d8:	01000134 	movhi	r4,4
   272dc:	21238304 	addi	r4,r4,-29172
   272e0:	00239c00 	call	239c0 <_ZN20Alf_SharedMemoryComm4InitEmmmmmmtm>
	sharedMem.EnableMailboxInterrupt();
   272e4:	01000134 	movhi	r4,4
   272e8:	21238304 	addi	r4,r4,-29172
   272ec:	0023c300 	call	23c30 <_ZN20Alf_SharedMemoryComm22EnableMailboxInterruptEv>
	Drive::SetDriveSpeed(0,0);
   272f0:	000b883a 	mov	r5,zero
   272f4:	0009883a 	mov	r4,zero
   272f8:	0025e380 	call	25e38 <_ZN5Drive13SetDriveSpeedEhh>

	/* set up of all needed NIOS tasks which will run periodically */
	xTaskCreate(readUltraSonic, "1", 512, NULL, 3, NULL);
   272fc:	d8000115 	stw	zero,4(sp)
   27300:	008000c4 	movi	r2,3
   27304:	d8800015 	stw	r2,0(sp)
   27308:	000f883a 	mov	r7,zero
   2730c:	01808004 	movi	r6,512
   27310:	014000f4 	movhi	r5,3
   27314:	294ba704 	addi	r5,r5,11932
   27318:	010000b4 	movhi	r4,2
   2731c:	211d4604 	addi	r4,r4,29976
   27320:	0021f300 	call	21f30 <xTaskCreate>
	xTaskCreate(readMPU, "2", 512, NULL, 2, NULL);
   27324:	d8000115 	stw	zero,4(sp)
   27328:	00800084 	movi	r2,2
   2732c:	d8800015 	stw	r2,0(sp)
   27330:	000f883a 	mov	r7,zero
   27334:	01808004 	movi	r6,512
   27338:	014000f4 	movhi	r5,3
   2733c:	294ba804 	addi	r5,r5,11936
   27340:	010000b4 	movhi	r4,2
   27344:	211cf904 	addi	r4,r4,29668
   27348:	0021f300 	call	21f30 <xTaskCreate>
	xTaskCreate(readRotary, "3", 512, NULL, 2, NULL);
   2734c:	d8000115 	stw	zero,4(sp)
   27350:	00800084 	movi	r2,2
   27354:	d8800015 	stw	r2,0(sp)
   27358:	000f883a 	mov	r7,zero
   2735c:	01808004 	movi	r6,512
   27360:	014000f4 	movhi	r5,3
   27364:	294ba904 	addi	r5,r5,11940
   27368:	010000b4 	movhi	r4,2
   2736c:	211dc804 	addi	r4,r4,30496
   27370:	0021f300 	call	21f30 <xTaskCreate>
	xTaskCreate(setMotor_and_Steering, "4", 512, NULL, 3, NULL);
   27374:	d8000115 	stw	zero,4(sp)
   27378:	008000c4 	movi	r2,3
   2737c:	d8800015 	stw	r2,0(sp)
   27380:	000f883a 	mov	r7,zero
   27384:	01808004 	movi	r6,512
   27388:	014000f4 	movhi	r5,3
   2738c:	294baa04 	addi	r5,r5,11944
   27390:	010000b4 	movhi	r4,2
   27394:	211e0e04 	addi	r4,r4,30776
   27398:	0021f300 	call	21f30 <xTaskCreate>
	xTaskCreate(setDriveInfo, "5", 256, NULL, 1, &writeTask);
   2739c:	d0a02f04 	addi	r2,gp,-32580
   273a0:	d8800115 	stw	r2,4(sp)
   273a4:	00800044 	movi	r2,1
   273a8:	d8800015 	stw	r2,0(sp)
   273ac:	000f883a 	mov	r7,zero
   273b0:	01804004 	movi	r6,256
   273b4:	014000f4 	movhi	r5,3
   273b8:	294bab04 	addi	r5,r5,11948
   273bc:	010000b4 	movhi	r4,2
   273c0:	211e7e04 	addi	r4,r4,31224
   273c4:	0021f300 	call	21f30 <xTaskCreate>

	vTaskStartScheduler();
   273c8:	00226380 	call	22638 <vTaskStartScheduler>
	return 0;
   273cc:	0005883a 	mov	r2,zero
}
   273d0:	e037883a 	mov	sp,fp
   273d4:	dfc00117 	ldw	ra,4(sp)
   273d8:	df000017 	ldw	fp,0(sp)
   273dc:	dec00204 	addi	sp,sp,8
   273e0:	f800283a 	ret

000273e4 <_Z7readMPUPv>:
static alt_u16 global_us_rear_left_data = 0;
static alt_u16 global_us_rear_right_data = 0;


void readMPU( void* p)
{
   273e4:	defff804 	addi	sp,sp,-32
   273e8:	dfc00715 	stw	ra,28(sp)
   273ec:	df000615 	stw	fp,24(sp)
   273f0:	df000604 	addi	fp,sp,24
   273f4:	e13fff15 	stw	r4,-4(fp)
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 50;
   273f8:	00800c84 	movi	r2,50
   273fc:	e0bffa15 	stw	r2,-24(fp)

	/* mpu */
	mpu6050 mpu(MPU6050_Addresses::DEVICE_0);
   27400:	e0bffc04 	addi	r2,fp,-16
   27404:	017ff404 	movi	r5,-48
   27408:	1009883a 	mov	r4,r2
   2740c:	00261c80 	call	261c8 <_ZN7mpu6050C1E17MPU6050_Addresses>
	mpu.InitMPU6050(AccelerometerSettings::RANGE_2G, GyroscopeSettings::RANGE_250_DEG);
   27410:	e0bffc04 	addi	r2,fp,-16
   27414:	000d883a 	mov	r6,zero
   27418:	000b883a 	mov	r5,zero
   2741c:	1009883a 	mov	r4,r2
   27420:	00262100 	call	26210 <_ZN7mpu605011InitMPU6050E21AccelerometerSettings17GyroscopeSettings>


	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
   27424:	00228a40 	call	228a4 <xTaskGetTickCount>
   27428:	e0bffb15 	stw	r2,-20(fp)

	while(1)
	{
		// Wait for the next cycle ( every 50ms )
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   2742c:	e0bffb04 	addi	r2,fp,-20
   27430:	01400c84 	movi	r5,50
   27434:	1009883a 	mov	r4,r2
   27438:	00222ac0 	call	222ac <vTaskDelayUntil>

		// if the IIC communication is failing due to the FreeRTOS scheduler (interrupted) make this a critical section by suspending other task
		// or by using the FreeRTOS critical section handling, currently not a problem
		mpu.ReadAccelerometer(global_acc_data);
   2743c:	e0bffc04 	addi	r2,fp,-16
   27440:	01400134 	movhi	r5,4
   27444:	2963b604 	addi	r5,r5,-28968
   27448:	1009883a 	mov	r4,r2
   2744c:	00264000 	call	26400 <_ZN7mpu605017ReadAccelerometerERNS_17AccelerometerDataE>
		mpu.ReadGyroscope(global_gyro_data);
   27450:	e0bffc04 	addi	r2,fp,-16
   27454:	01400134 	movhi	r5,4
   27458:	2963b904 	addi	r5,r5,-28956
   2745c:	1009883a 	mov	r4,r2
   27460:	002670c0 	call	2670c <_ZN7mpu605013ReadGyroscopeERNS_13GyroscopeDataE>
		mpu.ReadTemperature(global_temp_data);
   27464:	e0bffc04 	addi	r2,fp,-16
   27468:	d1603004 	addi	r5,gp,-32576
   2746c:	1009883a 	mov	r4,r2
   27470:	0026a180 	call	26a18 <_ZN7mpu605015ReadTemperatureERf>

		global_drive_info.acceleration = global_acc_data.acc_x;
   27474:	00800134 	movhi	r2,4
   27478:	10a3b604 	addi	r2,r2,-28968
   2747c:	10c00017 	ldw	r3,0(r2)
   27480:	00800134 	movhi	r2,4
   27484:	10a37b04 	addi	r2,r2,-29204
   27488:	10c00115 	stw	r3,4(r2)
		global_drive_info.lateral_acceleration = global_acc_data.acc_y;
   2748c:	00800134 	movhi	r2,4
   27490:	10a3b604 	addi	r2,r2,-28968
   27494:	10c00117 	ldw	r3,4(r2)
   27498:	00800134 	movhi	r2,4
   2749c:	10a37b04 	addi	r2,r2,-29204
   274a0:	10c00215 	stw	r3,8(r2)
		global_drive_info.z_acceleration = global_acc_data.acc_z;
   274a4:	00800134 	movhi	r2,4
   274a8:	10a3b604 	addi	r2,r2,-28968
   274ac:	10c00217 	ldw	r3,8(r2)
   274b0:	00800134 	movhi	r2,4
   274b4:	10a37b04 	addi	r2,r2,-29204
   274b8:	10c00315 	stw	r3,12(r2)
		global_drive_info.Gyroscope_X = global_gyro_data.gyro_x;
   274bc:	00800134 	movhi	r2,4
   274c0:	10a3b904 	addi	r2,r2,-28956
   274c4:	10c00017 	ldw	r3,0(r2)
   274c8:	00800134 	movhi	r2,4
   274cc:	10a37b04 	addi	r2,r2,-29204
   274d0:	10c00415 	stw	r3,16(r2)
		global_drive_info.Gyroscope_Y = global_gyro_data.gyro_y;
   274d4:	00800134 	movhi	r2,4
   274d8:	10a3b904 	addi	r2,r2,-28956
   274dc:	10c00117 	ldw	r3,4(r2)
   274e0:	00800134 	movhi	r2,4
   274e4:	10a37b04 	addi	r2,r2,-29204
   274e8:	10c00515 	stw	r3,20(r2)
		global_drive_info.Gyroscope_Z = global_gyro_data.gyro_z;
   274ec:	00800134 	movhi	r2,4
   274f0:	10a3b904 	addi	r2,r2,-28956
   274f4:	10c00217 	ldw	r3,8(r2)
   274f8:	00800134 	movhi	r2,4
   274fc:	10a37b04 	addi	r2,r2,-29204
   27500:	10c00615 	stw	r3,24(r2)
		global_drive_info.temperature = global_temp_data;
   27504:	d0e03017 	ldw	r3,-32576(gp)
   27508:	00800134 	movhi	r2,4
   2750c:	10a37b04 	addi	r2,r2,-29204
   27510:	10c00715 	stw	r3,28(r2)


	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();

	while(1)
   27514:	003fc506 	br	2742c <__reset+0xfff8742c>

00027518 <_Z14readUltraSonicPv>:
		global_drive_info.temperature = global_temp_data;
	}
}

void readUltraSonic ( void* p )
{
   27518:	defff804 	addi	sp,sp,-32
   2751c:	dfc00715 	stw	ra,28(sp)
   27520:	df000615 	stw	fp,24(sp)
   27524:	df000604 	addi	fp,sp,24
   27528:	e13fff15 	stw	r4,-4(fp)
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 75;
   2752c:	008012c4 	movi	r2,75
   27530:	e0bffb15 	stw	r2,-20(fp)

	 // Initialise the xLastWakeTime variable with the current time.
	 xLastWakeTime = xTaskGetTickCount();
   27534:	00228a40 	call	228a4 <xTaskGetTickCount>
   27538:	e0bffd15 	stw	r2,-12(fp)

	 UltraSonicDevice us_front_left(UltraSonicAddress::DEVICE_00);
   2753c:	e0bffe04 	addi	r2,fp,-8
   27540:	017ff804 	movi	r5,-32
   27544:	1009883a 	mov	r4,r2
   27548:	0026c040 	call	26c04 <_ZN16UltraSonicDeviceC1E17UltraSonicAddress>
	 UltraSonicDevice us_front_right(UltraSonicAddress::DEVICE_01);
   2754c:	e0bffe44 	addi	r2,fp,-7
   27550:	017ff884 	movi	r5,-30
   27554:	1009883a 	mov	r4,r2
   27558:	0026c040 	call	26c04 <_ZN16UltraSonicDeviceC1E17UltraSonicAddress>
	 UltraSonicDevice us_rear_left(UltraSonicAddress::DEVICE_03);
   2755c:	e0bffe84 	addi	r2,fp,-6
   27560:	017ff984 	movi	r5,-26
   27564:	1009883a 	mov	r4,r2
   27568:	0026c040 	call	26c04 <_ZN16UltraSonicDeviceC1E17UltraSonicAddress>
	 UltraSonicDevice us_rear_right(UltraSonicAddress::DEVICE_02);
   2756c:	e0bffec4 	addi	r2,fp,-5
   27570:	017ff904 	movi	r5,-28
   27574:	1009883a 	mov	r4,r2
   27578:	0026c040 	call	26c04 <_ZN16UltraSonicDeviceC1E17UltraSonicAddress>

	 const alt_u8 maxSpeed = max_drive_speed;
   2757c:	008008c4 	movi	r2,35
   27580:	e0bffc05 	stb	r2,-16(fp)
	 bool close_range_front = false;
   27584:	e03ffa05 	stb	zero,-24(fp)
	 bool close_range_rear = false;
   27588:	e03ffa45 	stb	zero,-23(fp)

	 while(1)
	 {
		 us_front_left.writeCMDRegister(UltraSonicCommands::START_MEAS_CM, true);
   2758c:	e0bffe04 	addi	r2,fp,-8
   27590:	01800044 	movi	r6,1
   27594:	01401444 	movi	r5,81
   27598:	1009883a 	mov	r4,r2
   2759c:	0026c3c0 	call	26c3c <_ZNK16UltraSonicDevice16writeCMDRegisterE18UltraSonicCommandsb>
		 // Wait for the next cycle ( every 65ms )
		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
   275a0:	e0bffd04 	addi	r2,fp,-12
   275a4:	014012c4 	movi	r5,75
   275a8:	1009883a 	mov	r4,r2
   275ac:	00222ac0 	call	222ac <vTaskDelayUntil>

		 us_front_left.readRegister(UltraSonicRegisterRead::ECHO_0x01, global_us_front_left_data);
   275b0:	e0bffe04 	addi	r2,fp,-8
   275b4:	d1a03104 	addi	r6,gp,-32572
   275b8:	01400084 	movi	r5,2
   275bc:	1009883a 	mov	r4,r2
   275c0:	0026dec0 	call	26dec <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt>
		 us_front_right.readRegister(UltraSonicRegisterRead::ECHO_0x01, global_us_front_right_data);
   275c4:	e0bffe44 	addi	r2,fp,-7
   275c8:	d1a03184 	addi	r6,gp,-32570
   275cc:	01400084 	movi	r5,2
   275d0:	1009883a 	mov	r4,r2
   275d4:	0026dec0 	call	26dec <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt>
		 us_rear_left.readRegister(UltraSonicRegisterRead::ECHO_0x01, global_us_rear_left_data);
   275d8:	e0bffe84 	addi	r2,fp,-6
   275dc:	d1a03204 	addi	r6,gp,-32568
   275e0:	01400084 	movi	r5,2
   275e4:	1009883a 	mov	r4,r2
   275e8:	0026dec0 	call	26dec <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt>
		 us_rear_right.readRegister(UltraSonicRegisterRead::ECHO_0x01, global_us_rear_right_data);
   275ec:	e0bffec4 	addi	r2,fp,-5
   275f0:	d1a03284 	addi	r6,gp,-32566
   275f4:	01400084 	movi	r5,2
   275f8:	1009883a 	mov	r4,r2
   275fc:	0026dec0 	call	26dec <_ZNK16UltraSonicDevice12readRegisterE22UltraSonicRegisterReadRt>

		 // check front
		 if(global_us_front_left_data < emergency_stop_distance || global_us_front_right_data < emergency_stop_distance)
   27600:	d0a0310b 	ldhu	r2,-32572(gp)
   27604:	10bfffcc 	andi	r2,r2,65535
   27608:	10800330 	cmpltui	r2,r2,12
   2760c:	1000041e 	bne	r2,zero,27620 <_Z14readUltraSonicPv+0x108>
   27610:	d0a0318b 	ldhu	r2,-32570(gp)
   27614:	10bfffcc 	andi	r2,r2,65535
   27618:	10800328 	cmpgeui	r2,r2,12
   2761c:	1000051e 	bne	r2,zero,27634 <_Z14readUltraSonicPv+0x11c>
		 { // emergency stop front
			 Drive::setBlock_Front(true);
   27620:	01000044 	movi	r4,1
   27624:	0025f540 	call	25f54 <_ZN5Drive14setBlock_FrontEb>
			 close_range_front = true;
   27628:	00800044 	movi	r2,1
   2762c:	e0bffa05 	stb	r2,-24(fp)
   27630:	00001206 	br	2767c <_Z14readUltraSonicPv+0x164>
		 }
		 else if (global_us_front_left_data < close_range_distance || global_us_front_right_data < close_range_distance)
   27634:	d0a0310b 	ldhu	r2,-32572(gp)
   27638:	10bfffcc 	andi	r2,r2,65535
   2763c:	10800670 	cmpltui	r2,r2,25
   27640:	1000041e 	bne	r2,zero,27654 <_Z14readUltraSonicPv+0x13c>
   27644:	d0a0318b 	ldhu	r2,-32570(gp)
   27648:	10bfffcc 	andi	r2,r2,65535
   2764c:	10800668 	cmpgeui	r2,r2,25
   27650:	1000051e 	bne	r2,zero,27668 <_Z14readUltraSonicPv+0x150>
		 { // close range, careful
			 close_range_front = true;
   27654:	00800044 	movi	r2,1
   27658:	e0bffa05 	stb	r2,-24(fp)
			 Drive::setBlock_Front(false);
   2765c:	0009883a 	mov	r4,zero
   27660:	0025f540 	call	25f54 <_ZN5Drive14setBlock_FrontEb>
   27664:	00000506 	br	2767c <_Z14readUltraSonicPv+0x164>
		 }
		 else
		 { // nothing in sight -> full throttle
			 Drive::SetMaxSpeed(maxSpeed);
   27668:	010008c4 	movi	r4,35
   2766c:	0025f100 	call	25f10 <_ZN5Drive11SetMaxSpeedEh>
			 Drive::setBlock_Front(false);
   27670:	0009883a 	mov	r4,zero
   27674:	0025f540 	call	25f54 <_ZN5Drive14setBlock_FrontEb>
			 close_range_front = false;
   27678:	e03ffa05 	stb	zero,-24(fp)
		 }

		 // check rear
		 if(global_us_rear_left_data < emergency_stop_distance || global_us_rear_right_data < emergency_stop_distance)
   2767c:	d0a0320b 	ldhu	r2,-32568(gp)
   27680:	10bfffcc 	andi	r2,r2,65535
   27684:	10800330 	cmpltui	r2,r2,12
   27688:	1000041e 	bne	r2,zero,2769c <_Z14readUltraSonicPv+0x184>
   2768c:	d0a0328b 	ldhu	r2,-32566(gp)
   27690:	10bfffcc 	andi	r2,r2,65535
   27694:	10800328 	cmpgeui	r2,r2,12
   27698:	1000051e 	bne	r2,zero,276b0 <_Z14readUltraSonicPv+0x198>
		 { // emergency stop back
			 Drive::SetBlock_Rear(true);
   2769c:	01000044 	movi	r4,1
   276a0:	0025f840 	call	25f84 <_ZN5Drive13SetBlock_RearEb>
			 close_range_rear = true;
   276a4:	00800044 	movi	r2,1
   276a8:	e0bffa45 	stb	r2,-23(fp)
   276ac:	00001206 	br	276f8 <_Z14readUltraSonicPv+0x1e0>
		 }
		 else if (global_us_rear_left_data < close_range_distance || global_us_rear_right_data < close_range_distance)
   276b0:	d0a0320b 	ldhu	r2,-32568(gp)
   276b4:	10bfffcc 	andi	r2,r2,65535
   276b8:	10800670 	cmpltui	r2,r2,25
   276bc:	1000041e 	bne	r2,zero,276d0 <_Z14readUltraSonicPv+0x1b8>
   276c0:	d0a0328b 	ldhu	r2,-32566(gp)
   276c4:	10bfffcc 	andi	r2,r2,65535
   276c8:	10800668 	cmpgeui	r2,r2,25
   276cc:	1000051e 	bne	r2,zero,276e4 <_Z14readUltraSonicPv+0x1cc>
		 { // close range, careful
			 close_range_rear = true;
   276d0:	00800044 	movi	r2,1
   276d4:	e0bffa45 	stb	r2,-23(fp)
			 Drive::SetBlock_Rear(false);
   276d8:	0009883a 	mov	r4,zero
   276dc:	0025f840 	call	25f84 <_ZN5Drive13SetBlock_RearEb>
   276e0:	00000506 	br	276f8 <_Z14readUltraSonicPv+0x1e0>
		 }
		 else
		 { // nothing in sight -> full throttle
			 Drive::SetMaxSpeed(maxSpeed);
   276e4:	010008c4 	movi	r4,35
   276e8:	0025f100 	call	25f10 <_ZN5Drive11SetMaxSpeedEh>
			 Drive::SetBlock_Rear(false);
   276ec:	0009883a 	mov	r4,zero
   276f0:	0025f840 	call	25f84 <_ZN5Drive13SetBlock_RearEb>
			 close_range_rear = false;
   276f4:	e03ffa45 	stb	zero,-23(fp)
		 }

		 // evaluate close range results
		 if(close_range_front || close_range_rear)
   276f8:	e0bffa03 	ldbu	r2,-24(fp)
   276fc:	1000021e 	bne	r2,zero,27708 <_Z14readUltraSonicPv+0x1f0>
   27700:	e0bffa43 	ldbu	r2,-23(fp)
   27704:	10000326 	beq	r2,zero,27714 <_Z14readUltraSonicPv+0x1fc>
			 Drive::SetMaxSpeed(close_range_speed);
   27708:	01000504 	movi	r4,20
   2770c:	0025f100 	call	25f10 <_ZN5Drive11SetMaxSpeedEh>
   27710:	00000206 	br	2771c <_Z14readUltraSonicPv+0x204>
		 else
			 Drive::SetMaxSpeed(maxSpeed);
   27714:	010008c4 	movi	r4,35
   27718:	0025f100 	call	25f10 <_ZN5Drive11SetMaxSpeedEh>

	 const alt_u8 maxSpeed = max_drive_speed;
	 bool close_range_front = false;
	 bool close_range_rear = false;

	 while(1)
   2771c:	003f9b06 	br	2758c <__reset+0xfff8758c>

00027720 <_Z10readRotaryPv>:
			 Drive::SetMaxSpeed(maxSpeed);
	 }
}

void readRotary ( void* p )
{
   27720:	defff604 	addi	sp,sp,-40
   27724:	dfc00915 	stw	ra,36(sp)
   27728:	df000815 	stw	fp,32(sp)
   2772c:	dc400715 	stw	r17,28(sp)
   27730:	dc000615 	stw	r16,24(sp)
   27734:	df000804 	addi	fp,sp,32
   27738:	e13ffd15 	stw	r4,-12(fp)
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 50;
   2773c:	00800c84 	movi	r2,50
   27740:	e0bff815 	stw	r2,-32(fp)

	 // Initialise the xLastWakeTime variable with the current time.
	 xLastWakeTime = xTaskGetTickCount();
   27744:	00228a40 	call	228a4 <xTaskGetTickCount>
   27748:	e0bffc15 	stw	r2,-16(fp)

	 while(1)
	 {
         TickType_t old_value = xLastWakeTime;
   2774c:	e0bffc17 	ldw	r2,-16(fp)
   27750:	e0bff915 	stw	r2,-28(fp)
		 // Wait for the next cycle ( every 50ms )
		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
   27754:	e0bffc04 	addi	r2,fp,-16
   27758:	01400c84 	movi	r5,50
   2775c:	1009883a 	mov	r4,r2
   27760:	00222ac0 	call	222ac <vTaskDelayUntil>
         
         //Calculation of current speed
         alt_u32 curr_value = ROT_ENC_GetRotations(ROTARY_ENCODER_0_BASE);
   27764:	01002804 	movi	r4,160
   27768:	002ed100 	call	2ed10 <ROT_ENC_GetRotations>
   2776c:	e0bffa15 	stw	r2,-24(fp)
         ROT_ENC_ClearCounter();
   27770:	002ed740 	call	2ed74 <ROT_ENC_ClearCounter>
         alt_u8 speed = (curr_value * pulses_to_meter) / ((xLastWakeTime-old_value)*(1.0/configTICK_RATE_HZ));
   27774:	e13ffa17 	ldw	r4,-24(fp)
   27778:	0028e180 	call	28e18 <__floatunsisf>
   2777c:	1007883a 	mov	r3,r2
   27780:	008fe034 	movhi	r2,16256
   27784:	100b883a 	mov	r5,r2
   27788:	1809883a 	mov	r4,r3
   2778c:	00283a40 	call	283a4 <__mulsf3>
   27790:	1007883a 	mov	r3,r2
   27794:	1805883a 	mov	r2,r3
   27798:	1009883a 	mov	r4,r2
   2779c:	002b3900 	call	2b390 <__extendsfdf2>
   277a0:	1021883a 	mov	r16,r2
   277a4:	1823883a 	mov	r17,r3
   277a8:	e0fffc17 	ldw	r3,-16(fp)
   277ac:	e0bff917 	ldw	r2,-28(fp)
   277b0:	1885c83a 	sub	r2,r3,r2
   277b4:	1009883a 	mov	r4,r2
   277b8:	002b2e80 	call	2b2e8 <__floatunsidf>
   277bc:	1011883a 	mov	r8,r2
   277c0:	1813883a 	mov	r9,r3
   277c4:	0191ebb4 	movhi	r6,18350
   277c8:	31851ec4 	addi	r6,r6,5243
   277cc:	01cfdd34 	movhi	r7,16244
   277d0:	39deb844 	addi	r7,r7,31457
   277d4:	4009883a 	mov	r4,r8
   277d8:	480b883a 	mov	r5,r9
   277dc:	002a1780 	call	2a178 <__muldf3>
   277e0:	1009883a 	mov	r4,r2
   277e4:	180b883a 	mov	r5,r3
   277e8:	2005883a 	mov	r2,r4
   277ec:	2807883a 	mov	r3,r5
   277f0:	100d883a 	mov	r6,r2
   277f4:	180f883a 	mov	r7,r3
   277f8:	8009883a 	mov	r4,r16
   277fc:	880b883a 	mov	r5,r17
   27800:	00297b40 	call	297b4 <__divdf3>
   27804:	1009883a 	mov	r4,r2
   27808:	180b883a 	mov	r5,r3
   2780c:	2005883a 	mov	r2,r4
   27810:	2807883a 	mov	r3,r5
   27814:	1009883a 	mov	r4,r2
   27818:	180b883a 	mov	r5,r3
   2781c:	0027c800 	call	27c80 <__fixunsdfsi>
   27820:	e0bffb05 	stb	r2,-20(fp)
         global_drive_info.speed = speed;
   27824:	00800134 	movhi	r2,4
   27828:	10a37b04 	addi	r2,r2,-29204
   2782c:	e0fffb03 	ldbu	r3,-20(fp)
   27830:	10c00005 	stb	r3,0(r2)
	const TickType_t xFrequency = 50;

	 // Initialise the xLastWakeTime variable with the current time.
	 xLastWakeTime = xTaskGetTickCount();

	 while(1)
   27834:	003fc506 	br	2774c <__reset+0xfff8774c>

00027838 <_Z21setMotor_and_SteeringPv>:
         global_drive_info.speed = speed;
	 }
}

void setMotor_and_Steering ( void* p )
{
   27838:	defff904 	addi	sp,sp,-28
   2783c:	dfc00615 	stw	ra,24(sp)
   27840:	df000515 	stw	fp,20(sp)
   27844:	df000504 	addi	fp,sp,20
   27848:	e13fff15 	stw	r4,-4(fp)
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 20;
   2784c:	00800504 	movi	r2,20
   27850:	e0bffc15 	stw	r2,-16(fp)

	Steering::Init(max_steering_angle);
   27854:	01000a04 	movi	r4,40
   27858:	00260540 	call	26054 <_ZN8Steering4InitEh>
	Drive::SetMaxSpeed(max_drive_speed);
   2785c:	010008c4 	movi	r4,35
   27860:	0025f100 	call	25f10 <_ZN5Drive11SetMaxSpeedEh>

	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
   27864:	00228a40 	call	228a4 <xTaskGetTickCount>
   27868:	e0bffd15 	stw	r2,-12(fp)

	Alf_Drive_Command drive{};
   2786c:	e03ffe15 	stw	zero,-8(fp)

	alt_u8 real_speed = 0;
   27870:	e03ffb05 	stb	zero,-20(fp)
	alt_u8 real_direction = 0;
   27874:	e03ffb45 	stb	zero,-19(fp)

	while(1)
	{
		// Wait for the next cycle ( every 20ms )
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   27878:	e0bffd04 	addi	r2,fp,-12
   2787c:	01400504 	movi	r5,20
   27880:	1009883a 	mov	r4,r2
   27884:	00222ac0 	call	222ac <vTaskDelayUntil>

		sharedMem.Read(drive);
   27888:	e0bffe04 	addi	r2,fp,-8
   2788c:	100b883a 	mov	r5,r2
   27890:	01000134 	movhi	r4,4
   27894:	21238304 	addi	r4,r4,-29172
   27898:	00240040 	call	24004 <_ZN20Alf_SharedMemoryComm4ReadER17Alf_Drive_Command>

		real_speed = drive.speed;
   2789c:	e0bffe03 	ldbu	r2,-8(fp)
   278a0:	e0bffb05 	stb	r2,-20(fp)
		real_direction = drive.direction;
   278a4:	e0bffe43 	ldbu	r2,-7(fp)
   278a8:	e0bffb45 	stb	r2,-19(fp)

		// set light pins active low
		IOWR(GARFIELD_LIGHTING_BASE, 0, static_cast<alt_u8>(drive.light) == true ? 0 : 1);
   278ac:	e0bffec3 	ldbu	r2,-5(fp)
   278b0:	10803fcc 	andi	r2,r2,255
   278b4:	10000226 	beq	r2,zero,278c0 <_Z21setMotor_and_SteeringPv+0x88>
   278b8:	0005883a 	mov	r2,zero
   278bc:	00000106 	br	278c4 <_Z21setMotor_and_SteeringPv+0x8c>
   278c0:	00800044 	movi	r2,1
   278c4:	00c01804 	movi	r3,96
   278c8:	18800035 	stwio	r2,0(r3)
		IOWR(GARFIELD_LIGHTING_BASE, 1, static_cast<alt_u8>(drive.light) == true ? 0 : 1);
   278cc:	e0bffec3 	ldbu	r2,-5(fp)
   278d0:	10803fcc 	andi	r2,r2,255
   278d4:	10000226 	beq	r2,zero,278e0 <_Z21setMotor_and_SteeringPv+0xa8>
   278d8:	0005883a 	mov	r2,zero
   278dc:	00000106 	br	278e4 <_Z21setMotor_and_SteeringPv+0xac>
   278e0:	00800044 	movi	r2,1
   278e4:	00c01904 	movi	r3,100
   278e8:	18800035 	stwio	r2,0(r3)
		IOWR(GARFIELD_LIGHTING_BASE, 2, static_cast<alt_u8>(drive.light) == true ? 0 : 1);
   278ec:	e0bffec3 	ldbu	r2,-5(fp)
   278f0:	10803fcc 	andi	r2,r2,255
   278f4:	10000226 	beq	r2,zero,27900 <_Z21setMotor_and_SteeringPv+0xc8>
   278f8:	0005883a 	mov	r2,zero
   278fc:	00000106 	br	27904 <_Z21setMotor_and_SteeringPv+0xcc>
   27900:	00800044 	movi	r2,1
   27904:	00c01a04 	movi	r3,104
   27908:	18800035 	stwio	r2,0(r3)
		IOWR(GARFIELD_LIGHTING_BASE, 3, static_cast<alt_u8>(drive.light) == true ? 0 : 1);
   2790c:	e0bffec3 	ldbu	r2,-5(fp)
   27910:	10803fcc 	andi	r2,r2,255
   27914:	10000226 	beq	r2,zero,27920 <_Z21setMotor_and_SteeringPv+0xe8>
   27918:	0005883a 	mov	r2,zero
   2791c:	00000106 	br	27924 <_Z21setMotor_and_SteeringPv+0xec>
   27920:	00800044 	movi	r2,1
   27924:	00c01b04 	movi	r3,108
   27928:	18800035 	stwio	r2,0(r3)


		Steering::Set(drive.angle);
   2792c:	e0bffe83 	ldbu	r2,-6(fp)
   27930:	10803fcc 	andi	r2,r2,255
   27934:	1080201c 	xori	r2,r2,128
   27938:	10bfe004 	addi	r2,r2,-128
   2793c:	1009883a 	mov	r4,r2
   27940:	002611c0 	call	2611c <_ZN8Steering3SetEa>

		if(Drive::GetBlock_Front() == true && real_direction == 0)
   27944:	00260140 	call	26014 <_ZN5Drive14GetBlock_FrontEv>
   27948:	10803fcc 	andi	r2,r2,255
   2794c:	10000426 	beq	r2,zero,27960 <_Z21setMotor_and_SteeringPv+0x128>
   27950:	e0bffb43 	ldbu	r2,-19(fp)
   27954:	1000021e 	bne	r2,zero,27960 <_Z21setMotor_and_SteeringPv+0x128>
   27958:	00800044 	movi	r2,1
   2795c:	00000106 	br	27964 <_Z21setMotor_and_SteeringPv+0x12c>
   27960:	0005883a 	mov	r2,zero
   27964:	10803fcc 	andi	r2,r2,255
   27968:	10000226 	beq	r2,zero,27974 <_Z21setMotor_and_SteeringPv+0x13c>
		{ //drive forward -> stop motor
			real_speed = 0;
   2796c:	e03ffb05 	stb	zero,-20(fp)
			real_direction = 0;
   27970:	e03ffb45 	stb	zero,-19(fp)
		}
		if(Drive::GetBlock_Rear() == true && real_direction == 1)
   27974:	00260340 	call	26034 <_ZN5Drive13GetBlock_RearEv>
   27978:	10803fcc 	andi	r2,r2,255
   2797c:	10000526 	beq	r2,zero,27994 <_Z21setMotor_and_SteeringPv+0x15c>
   27980:	e0bffb43 	ldbu	r2,-19(fp)
   27984:	10800058 	cmpnei	r2,r2,1
   27988:	1000021e 	bne	r2,zero,27994 <_Z21setMotor_and_SteeringPv+0x15c>
   2798c:	00800044 	movi	r2,1
   27990:	00000106 	br	27998 <_Z21setMotor_and_SteeringPv+0x160>
   27994:	0005883a 	mov	r2,zero
   27998:	10803fcc 	andi	r2,r2,255
   2799c:	10000326 	beq	r2,zero,279ac <_Z21setMotor_and_SteeringPv+0x174>
		{ //drive backward -> stop motor
			real_speed = 0;
   279a0:	e03ffb05 	stb	zero,-20(fp)
			real_direction = 1;
   279a4:	00800044 	movi	r2,1
   279a8:	e0bffb45 	stb	r2,-19(fp)
		}
		// timeout happened, meaning no interrupt occurred and therefore no new data was received
		if(timeout == 0)
   279ac:	d0a00543 	ldbu	r2,-32747(gp)
   279b0:	10803fcc 	andi	r2,r2,255
   279b4:	1005003a 	cmpeq	r2,r2,zero
   279b8:	10803fcc 	andi	r2,r2,255
   279bc:	10000526 	beq	r2,zero,279d4 <_Z21setMotor_and_SteeringPv+0x19c>
		{
			Drive::SetDriveSpeed(real_direction, 0);
   279c0:	e0bffb43 	ldbu	r2,-19(fp)
   279c4:	000b883a 	mov	r5,zero
   279c8:	1009883a 	mov	r4,r2
   279cc:	0025e380 	call	25e38 <_ZN5Drive13SetDriveSpeedEhh>
   279d0:	003fa906 	br	27878 <__reset+0xfff87878>
		}
		else
		{
			--timeout;
   279d4:	d0a00543 	ldbu	r2,-32747(gp)
   279d8:	10bfffc4 	addi	r2,r2,-1
   279dc:	d0a00545 	stb	r2,-32747(gp)
			Drive::SetDriveSpeed(real_direction, real_speed);
   279e0:	e0bffb43 	ldbu	r2,-19(fp)
   279e4:	e0fffb03 	ldbu	r3,-20(fp)
   279e8:	180b883a 	mov	r5,r3
   279ec:	1009883a 	mov	r4,r2
   279f0:	0025e380 	call	25e38 <_ZN5Drive13SetDriveSpeedEhh>
	Alf_Drive_Command drive{};

	alt_u8 real_speed = 0;
	alt_u8 real_direction = 0;

	while(1)
   279f4:	003fa006 	br	27878 <__reset+0xfff87878>

000279f8 <_Z12setDriveInfoPv>:
		}
	}
}

void setDriveInfo(void* p)
{
   279f8:	defffb04 	addi	sp,sp,-20
   279fc:	dfc00415 	stw	ra,16(sp)
   27a00:	df000315 	stw	fp,12(sp)
   27a04:	df000304 	addi	fp,sp,12
   27a08:	e13fff15 	stw	r4,-4(fp)
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 200;
   27a0c:	00803204 	movi	r2,200
   27a10:	e0bffd15 	stw	r2,-12(fp)

	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
   27a14:	00228a40 	call	228a4 <xTaskGetTickCount>
   27a18:	e0bffe15 	stw	r2,-8(fp)

	while(1)
	{
		// Wait for the next cycle ( every 200ms )
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   27a1c:	e0bffe04 	addi	r2,fp,-8
   27a20:	01403204 	movi	r5,200
   27a24:	1009883a 	mov	r4,r2
   27a28:	00222ac0 	call	222ac <vTaskDelayUntil>
		// write the current drive info into the shared memory
		sharedMem.Write(global_drive_info);
   27a2c:	01400134 	movhi	r5,4
   27a30:	29637b04 	addi	r5,r5,-29204
   27a34:	01000134 	movhi	r4,4
   27a38:	21238304 	addi	r4,r4,-29172
   27a3c:	0023da00 	call	23da0 <_ZN20Alf_SharedMemoryComm5WriteERK14Alf_Drive_Info>
	const TickType_t xFrequency = 200;

	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();

	while(1)
   27a40:	003ff606 	br	27a1c <__reset+0xfff87a1c>

00027a44 <_Z11Mailbox_isrPvm>:
#endif
	}
}

void Mailbox_isr(void* ptr, alt_u32 a)
{
   27a44:	defff904 	addi	sp,sp,-28
   27a48:	dfc00615 	stw	ra,24(sp)
   27a4c:	df000515 	stw	fp,20(sp)
   27a50:	df000504 	addi	fp,sp,20
   27a54:	e13ffe15 	stw	r4,-8(fp)
   27a58:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   27a5c:	0005303a 	rdctl	r2,status
   27a60:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27a64:	e0fffd17 	ldw	r3,-12(fp)
   27a68:	00bfff84 	movi	r2,-2
   27a6c:	1884703a 	and	r2,r3,r2
   27a70:	1001703a 	wrctl	status,r2
  
  return context;
   27a74:	e0bffd17 	ldw	r2,-12(fp)
	alt_u32 h = alt_irq_disable_all();
   27a78:	e0bffb15 	stw	r2,-20(fp)
	sharedMem.ReadInterruptHandler();
   27a7c:	01000134 	movhi	r4,4
   27a80:	21238304 	addi	r4,r4,-29172
   27a84:	0023e900 	call	23e90 <_ZN20Alf_SharedMemoryComm20ReadInterruptHandlerEv>
	IORD(MAILBOX_ARM2NIOS_0_BASE, 0);
   27a88:	00803004 	movi	r2,192
   27a8c:	10800037 	ldwio	r2,0(r2)
	timeout = 20;
   27a90:	00800504 	movi	r2,20
   27a94:	d0a00545 	stb	r2,-32747(gp)
	alt_irq_enable_all(h);
   27a98:	e0bffb17 	ldw	r2,-20(fp)
   27a9c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   27aa0:	e0bffc17 	ldw	r2,-16(fp)
   27aa4:	1001703a 	wrctl	status,r2
}
   27aa8:	0001883a 	nop
   27aac:	e037883a 	mov	sp,fp
   27ab0:	dfc00117 	ldw	ra,4(sp)
   27ab4:	df000017 	ldw	fp,0(sp)
   27ab8:	dec00204 	addi	sp,sp,8
   27abc:	f800283a 	ret

00027ac0 <_Z41__static_initialization_and_destruction_0ii>:
   27ac0:	defffc04 	addi	sp,sp,-16
   27ac4:	dfc00315 	stw	ra,12(sp)
   27ac8:	df000215 	stw	fp,8(sp)
   27acc:	df000204 	addi	fp,sp,8
   27ad0:	e13ffe15 	stw	r4,-8(fp)
   27ad4:	e17fff15 	stw	r5,-4(fp)
   27ad8:	e0bffe17 	ldw	r2,-8(fp)
   27adc:	10800058 	cmpnei	r2,r2,1
   27ae0:	10000e1e 	bne	r2,zero,27b1c <_Z41__static_initialization_and_destruction_0ii+0x5c>
   27ae4:	e0ffff17 	ldw	r3,-4(fp)
   27ae8:	00bfffd4 	movui	r2,65535
   27aec:	18800b1e 	bne	r3,r2,27b1c <_Z41__static_initialization_and_destruction_0ii+0x5c>
char RunTimeStats_Buffer[2048];
volatile unsigned long TimerTicks = 0;
#endif

/* global section */
Alf_SharedMemoryComm sharedMem{};
   27af0:	00800134 	movhi	r2,4
   27af4:	10a38304 	addi	r2,r2,-29172
   27af8:	1007883a 	mov	r3,r2
   27afc:	00803304 	movi	r2,204
   27b00:	100d883a 	mov	r6,r2
   27b04:	000b883a 	mov	r5,zero
   27b08:	1809883a 	mov	r4,r3
   27b0c:	002b7f40 	call	2b7f4 <memset>
   27b10:	01000134 	movhi	r4,4
   27b14:	21238304 	addi	r4,r4,-29172
   27b18:	0027bb00 	call	27bb0 <_ZN20Alf_SharedMemoryCommC1Ev>
	alt_u32 h = alt_irq_disable_all();
	sharedMem.ReadInterruptHandler();
	IORD(MAILBOX_ARM2NIOS_0_BASE, 0);
	timeout = 20;
	alt_irq_enable_all(h);
}
   27b1c:	0001883a 	nop
   27b20:	e037883a 	mov	sp,fp
   27b24:	dfc00117 	ldw	ra,4(sp)
   27b28:	df000017 	ldw	fp,0(sp)
   27b2c:	dec00204 	addi	sp,sp,8
   27b30:	f800283a 	ret

00027b34 <_GLOBAL__sub_I_sharedMem>:
   27b34:	defffe04 	addi	sp,sp,-8
   27b38:	dfc00115 	stw	ra,4(sp)
   27b3c:	df000015 	stw	fp,0(sp)
   27b40:	d839883a 	mov	fp,sp
   27b44:	017fffd4 	movui	r5,65535
   27b48:	01000044 	movi	r4,1
   27b4c:	0027ac00 	call	27ac0 <_Z41__static_initialization_and_destruction_0ii>
   27b50:	e037883a 	mov	sp,fp
   27b54:	dfc00117 	ldw	ra,4(sp)
   27b58:	df000017 	ldw	fp,0(sp)
   27b5c:	dec00204 	addi	sp,sp,8
   27b60:	f800283a 	ret

00027b64 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EEC1Ev>:

/**
 * @brief Implementation of a ringbuffer with fixed size. If the queue is full, the oldest element will be overwritten.
 */
template <class obj, uint32_t size>
class Garifield_RingBuffer {
   27b64:	defffe04 	addi	sp,sp,-8
   27b68:	df000115 	stw	fp,4(sp)
   27b6c:	df000104 	addi	fp,sp,4
   27b70:	e13fff15 	stw	r4,-4(fp)
   27b74:	e0bfff17 	ldw	r2,-4(fp)
   27b78:	00c00304 	movi	r3,12
   27b7c:	10c00015 	stw	r3,0(r2)
   27b80:	e0bfff17 	ldw	r2,-4(fp)
   27b84:	10000d15 	stw	zero,52(r2)
   27b88:	e0bfff17 	ldw	r2,-4(fp)
   27b8c:	10000e15 	stw	zero,56(r2)
   27b90:	e0bfff17 	ldw	r2,-4(fp)
   27b94:	00c00044 	movi	r3,1
   27b98:	10c00f05 	stb	r3,60(r2)
   27b9c:	0001883a 	nop
   27ba0:	e037883a 	mov	sp,fp
   27ba4:	df000017 	ldw	fp,0(sp)
   27ba8:	dec00104 	addi	sp,sp,4
   27bac:	f800283a 	ret

00027bb0 <_ZN20Alf_SharedMemoryCommC1Ev>:
};

/**
 * @brief Implementation for communcatiing via a shared memory section on the fpga. Abstraction for the mailbox, the hardware mutex and the shared memory in both directions.
 */
class Alf_SharedMemoryComm{
   27bb0:	defffd04 	addi	sp,sp,-12
   27bb4:	dfc00215 	stw	ra,8(sp)
   27bb8:	df000115 	stw	fp,4(sp)
   27bbc:	df000104 	addi	fp,sp,4
   27bc0:	e13fff15 	stw	r4,-4(fp)
   27bc4:	e0bfff17 	ldw	r2,-4(fp)
   27bc8:	00c20004 	movi	r3,2048
   27bcc:	10c00f15 	stw	r3,60(r2)
   27bd0:	e0bfff17 	ldw	r2,-4(fp)
   27bd4:	00c00404 	movi	r3,16
   27bd8:	10c01015 	stw	r3,64(r2)
   27bdc:	e0bfff17 	ldw	r2,-4(fp)
   27be0:	00c00204 	movi	r3,8
   27be4:	10c01115 	stw	r3,68(r2)
   27be8:	e0bfff17 	ldw	r2,-4(fp)
   27bec:	10801204 	addi	r2,r2,72
   27bf0:	1009883a 	mov	r4,r2
   27bf4:	0027b640 	call	27b64 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EEC1Ev>
   27bf8:	e0bfff17 	ldw	r2,-4(fp)
   27bfc:	10802204 	addi	r2,r2,136
   27c00:	1009883a 	mov	r4,r2
   27c04:	0027b640 	call	27b64 <_ZN20Garifield_RingBufferIN20Alf_SharedMemoryComm9mailbox_sELm12EEC1Ev>
   27c08:	0001883a 	nop
   27c0c:	e037883a 	mov	sp,fp
   27c10:	dfc00117 	ldw	ra,4(sp)
   27c14:	df000017 	ldw	fp,0(sp)
   27c18:	dec00204 	addi	sp,sp,8
   27c1c:	f800283a 	ret

00027c20 <__fixunssfsi>:
   27c20:	defffd04 	addi	sp,sp,-12
   27c24:	dc000015 	stw	r16,0(sp)
   27c28:	0413c034 	movhi	r16,20224
   27c2c:	800b883a 	mov	r5,r16
   27c30:	dc400115 	stw	r17,4(sp)
   27c34:	dfc00215 	stw	ra,8(sp)
   27c38:	2023883a 	mov	r17,r4
   27c3c:	00282e80 	call	282e8 <__gesf2>
   27c40:	1000070e 	bge	r2,zero,27c60 <__fixunssfsi+0x40>
   27c44:	8809883a 	mov	r4,r17
   27c48:	0028c840 	call	28c84 <__fixsfsi>
   27c4c:	dfc00217 	ldw	ra,8(sp)
   27c50:	dc400117 	ldw	r17,4(sp)
   27c54:	dc000017 	ldw	r16,0(sp)
   27c58:	dec00304 	addi	sp,sp,12
   27c5c:	f800283a 	ret
   27c60:	800b883a 	mov	r5,r16
   27c64:	8809883a 	mov	r4,r17
   27c68:	00287a00 	call	287a0 <__subsf3>
   27c6c:	1009883a 	mov	r4,r2
   27c70:	0028c840 	call	28c84 <__fixsfsi>
   27c74:	00e00034 	movhi	r3,32768
   27c78:	10c5883a 	add	r2,r2,r3
   27c7c:	003ff306 	br	27c4c <__reset+0xfff87c4c>

00027c80 <__fixunsdfsi>:
   27c80:	defffd04 	addi	sp,sp,-12
   27c84:	000d883a 	mov	r6,zero
   27c88:	01d07834 	movhi	r7,16864
   27c8c:	dc400115 	stw	r17,4(sp)
   27c90:	dc000015 	stw	r16,0(sp)
   27c94:	dfc00215 	stw	ra,8(sp)
   27c98:	2023883a 	mov	r17,r4
   27c9c:	2821883a 	mov	r16,r5
   27ca0:	002a09c0 	call	2a09c <__gedf2>
   27ca4:	1000080e 	bge	r2,zero,27cc8 <__fixunsdfsi+0x48>
   27ca8:	8809883a 	mov	r4,r17
   27cac:	800b883a 	mov	r5,r16
   27cb0:	002b18c0 	call	2b18c <__fixdfsi>
   27cb4:	dfc00217 	ldw	ra,8(sp)
   27cb8:	dc400117 	ldw	r17,4(sp)
   27cbc:	dc000017 	ldw	r16,0(sp)
   27cc0:	dec00304 	addi	sp,sp,12
   27cc4:	f800283a 	ret
   27cc8:	000d883a 	mov	r6,zero
   27ccc:	01d07834 	movhi	r7,16864
   27cd0:	8809883a 	mov	r4,r17
   27cd4:	800b883a 	mov	r5,r16
   27cd8:	002a8900 	call	2a890 <__subdf3>
   27cdc:	180b883a 	mov	r5,r3
   27ce0:	1009883a 	mov	r4,r2
   27ce4:	002b18c0 	call	2b18c <__fixdfsi>
   27ce8:	00e00034 	movhi	r3,32768
   27cec:	10c5883a 	add	r2,r2,r3
   27cf0:	003ff006 	br	27cb4 <__reset+0xfff87cb4>

00027cf4 <__divsi3>:
   27cf4:	20001b16 	blt	r4,zero,27d64 <__divsi3+0x70>
   27cf8:	000f883a 	mov	r7,zero
   27cfc:	28001616 	blt	r5,zero,27d58 <__divsi3+0x64>
   27d00:	200d883a 	mov	r6,r4
   27d04:	29001a2e 	bgeu	r5,r4,27d70 <__divsi3+0x7c>
   27d08:	00800804 	movi	r2,32
   27d0c:	00c00044 	movi	r3,1
   27d10:	00000106 	br	27d18 <__divsi3+0x24>
   27d14:	10000d26 	beq	r2,zero,27d4c <__divsi3+0x58>
   27d18:	294b883a 	add	r5,r5,r5
   27d1c:	10bfffc4 	addi	r2,r2,-1
   27d20:	18c7883a 	add	r3,r3,r3
   27d24:	293ffb36 	bltu	r5,r4,27d14 <__reset+0xfff87d14>
   27d28:	0005883a 	mov	r2,zero
   27d2c:	18000726 	beq	r3,zero,27d4c <__divsi3+0x58>
   27d30:	0005883a 	mov	r2,zero
   27d34:	31400236 	bltu	r6,r5,27d40 <__divsi3+0x4c>
   27d38:	314dc83a 	sub	r6,r6,r5
   27d3c:	10c4b03a 	or	r2,r2,r3
   27d40:	1806d07a 	srli	r3,r3,1
   27d44:	280ad07a 	srli	r5,r5,1
   27d48:	183ffa1e 	bne	r3,zero,27d34 <__reset+0xfff87d34>
   27d4c:	38000126 	beq	r7,zero,27d54 <__divsi3+0x60>
   27d50:	0085c83a 	sub	r2,zero,r2
   27d54:	f800283a 	ret
   27d58:	014bc83a 	sub	r5,zero,r5
   27d5c:	39c0005c 	xori	r7,r7,1
   27d60:	003fe706 	br	27d00 <__reset+0xfff87d00>
   27d64:	0109c83a 	sub	r4,zero,r4
   27d68:	01c00044 	movi	r7,1
   27d6c:	003fe306 	br	27cfc <__reset+0xfff87cfc>
   27d70:	00c00044 	movi	r3,1
   27d74:	003fee06 	br	27d30 <__reset+0xfff87d30>

00027d78 <__modsi3>:
   27d78:	20001716 	blt	r4,zero,27dd8 <__modsi3+0x60>
   27d7c:	000f883a 	mov	r7,zero
   27d80:	2005883a 	mov	r2,r4
   27d84:	28001216 	blt	r5,zero,27dd0 <__modsi3+0x58>
   27d88:	2900162e 	bgeu	r5,r4,27de4 <__modsi3+0x6c>
   27d8c:	01800804 	movi	r6,32
   27d90:	00c00044 	movi	r3,1
   27d94:	00000106 	br	27d9c <__modsi3+0x24>
   27d98:	30000a26 	beq	r6,zero,27dc4 <__modsi3+0x4c>
   27d9c:	294b883a 	add	r5,r5,r5
   27da0:	31bfffc4 	addi	r6,r6,-1
   27da4:	18c7883a 	add	r3,r3,r3
   27da8:	293ffb36 	bltu	r5,r4,27d98 <__reset+0xfff87d98>
   27dac:	18000526 	beq	r3,zero,27dc4 <__modsi3+0x4c>
   27db0:	1806d07a 	srli	r3,r3,1
   27db4:	11400136 	bltu	r2,r5,27dbc <__modsi3+0x44>
   27db8:	1145c83a 	sub	r2,r2,r5
   27dbc:	280ad07a 	srli	r5,r5,1
   27dc0:	183ffb1e 	bne	r3,zero,27db0 <__reset+0xfff87db0>
   27dc4:	38000126 	beq	r7,zero,27dcc <__modsi3+0x54>
   27dc8:	0085c83a 	sub	r2,zero,r2
   27dcc:	f800283a 	ret
   27dd0:	014bc83a 	sub	r5,zero,r5
   27dd4:	003fec06 	br	27d88 <__reset+0xfff87d88>
   27dd8:	0109c83a 	sub	r4,zero,r4
   27ddc:	01c00044 	movi	r7,1
   27de0:	003fe706 	br	27d80 <__reset+0xfff87d80>
   27de4:	00c00044 	movi	r3,1
   27de8:	003ff106 	br	27db0 <__reset+0xfff87db0>

00027dec <__udivsi3>:
   27dec:	200d883a 	mov	r6,r4
   27df0:	2900152e 	bgeu	r5,r4,27e48 <__udivsi3+0x5c>
   27df4:	28001416 	blt	r5,zero,27e48 <__udivsi3+0x5c>
   27df8:	00800804 	movi	r2,32
   27dfc:	00c00044 	movi	r3,1
   27e00:	00000206 	br	27e0c <__udivsi3+0x20>
   27e04:	10000e26 	beq	r2,zero,27e40 <__udivsi3+0x54>
   27e08:	28000516 	blt	r5,zero,27e20 <__udivsi3+0x34>
   27e0c:	294b883a 	add	r5,r5,r5
   27e10:	10bfffc4 	addi	r2,r2,-1
   27e14:	18c7883a 	add	r3,r3,r3
   27e18:	293ffa36 	bltu	r5,r4,27e04 <__reset+0xfff87e04>
   27e1c:	18000826 	beq	r3,zero,27e40 <__udivsi3+0x54>
   27e20:	0005883a 	mov	r2,zero
   27e24:	31400236 	bltu	r6,r5,27e30 <__udivsi3+0x44>
   27e28:	314dc83a 	sub	r6,r6,r5
   27e2c:	10c4b03a 	or	r2,r2,r3
   27e30:	1806d07a 	srli	r3,r3,1
   27e34:	280ad07a 	srli	r5,r5,1
   27e38:	183ffa1e 	bne	r3,zero,27e24 <__reset+0xfff87e24>
   27e3c:	f800283a 	ret
   27e40:	0005883a 	mov	r2,zero
   27e44:	f800283a 	ret
   27e48:	00c00044 	movi	r3,1
   27e4c:	003ff406 	br	27e20 <__reset+0xfff87e20>

00027e50 <__umodsi3>:
   27e50:	2005883a 	mov	r2,r4
   27e54:	2900122e 	bgeu	r5,r4,27ea0 <__umodsi3+0x50>
   27e58:	28001116 	blt	r5,zero,27ea0 <__umodsi3+0x50>
   27e5c:	01800804 	movi	r6,32
   27e60:	00c00044 	movi	r3,1
   27e64:	00000206 	br	27e70 <__umodsi3+0x20>
   27e68:	30000c26 	beq	r6,zero,27e9c <__umodsi3+0x4c>
   27e6c:	28000516 	blt	r5,zero,27e84 <__umodsi3+0x34>
   27e70:	294b883a 	add	r5,r5,r5
   27e74:	31bfffc4 	addi	r6,r6,-1
   27e78:	18c7883a 	add	r3,r3,r3
   27e7c:	293ffa36 	bltu	r5,r4,27e68 <__reset+0xfff87e68>
   27e80:	18000626 	beq	r3,zero,27e9c <__umodsi3+0x4c>
   27e84:	1806d07a 	srli	r3,r3,1
   27e88:	11400136 	bltu	r2,r5,27e90 <__umodsi3+0x40>
   27e8c:	1145c83a 	sub	r2,r2,r5
   27e90:	280ad07a 	srli	r5,r5,1
   27e94:	183ffb1e 	bne	r3,zero,27e84 <__reset+0xfff87e84>
   27e98:	f800283a 	ret
   27e9c:	f800283a 	ret
   27ea0:	00c00044 	movi	r3,1
   27ea4:	003ff706 	br	27e84 <__reset+0xfff87e84>

00027ea8 <__divsf3>:
   27ea8:	defff504 	addi	sp,sp,-44
   27eac:	200cd5fa 	srli	r6,r4,23
   27eb0:	dcc00415 	stw	r19,16(sp)
   27eb4:	2026d7fa 	srli	r19,r4,31
   27eb8:	00c02034 	movhi	r3,128
   27ebc:	dd800715 	stw	r22,28(sp)
   27ec0:	dd000515 	stw	r20,20(sp)
   27ec4:	dc800315 	stw	r18,12(sp)
   27ec8:	18ffffc4 	addi	r3,r3,-1
   27ecc:	dfc00a15 	stw	ra,40(sp)
   27ed0:	df000915 	stw	fp,36(sp)
   27ed4:	ddc00815 	stw	r23,32(sp)
   27ed8:	dd400615 	stw	r21,24(sp)
   27edc:	dc400215 	stw	r17,8(sp)
   27ee0:	dc000115 	stw	r16,4(sp)
   27ee4:	35003fcc 	andi	r20,r6,255
   27ee8:	1924703a 	and	r18,r3,r4
   27eec:	9d803fcc 	andi	r22,r19,255
   27ef0:	a0005226 	beq	r20,zero,2803c <__divsf3+0x194>
   27ef4:	00803fc4 	movi	r2,255
   27ef8:	a0802e26 	beq	r20,r2,27fb4 <__divsf3+0x10c>
   27efc:	91002034 	orhi	r4,r18,128
   27f00:	202490fa 	slli	r18,r4,3
   27f04:	a53fe044 	addi	r20,r20,-127
   27f08:	0021883a 	mov	r16,zero
   27f0c:	002f883a 	mov	r23,zero
   27f10:	280cd5fa 	srli	r6,r5,23
   27f14:	282ad7fa 	srli	r21,r5,31
   27f18:	00c02034 	movhi	r3,128
   27f1c:	18ffffc4 	addi	r3,r3,-1
   27f20:	31803fcc 	andi	r6,r6,255
   27f24:	1962703a 	and	r17,r3,r5
   27f28:	af003fcc 	andi	fp,r21,255
   27f2c:	30004a26 	beq	r6,zero,28058 <__divsf3+0x1b0>
   27f30:	00803fc4 	movi	r2,255
   27f34:	30804526 	beq	r6,r2,2804c <__divsf3+0x1a4>
   27f38:	89402034 	orhi	r5,r17,128
   27f3c:	282290fa 	slli	r17,r5,3
   27f40:	31bfe044 	addi	r6,r6,-127
   27f44:	000b883a 	mov	r5,zero
   27f48:	2c20b03a 	or	r16,r5,r16
   27f4c:	802090ba 	slli	r16,r16,2
   27f50:	008000b4 	movhi	r2,2
   27f54:	109fdd04 	addi	r2,r2,32628
   27f58:	80a1883a 	add	r16,r16,r2
   27f5c:	81000017 	ldw	r4,0(r16)
   27f60:	9d46f03a 	xor	r3,r19,r21
   27f64:	180f883a 	mov	r7,r3
   27f68:	18803fcc 	andi	r2,r3,255
   27f6c:	a18dc83a 	sub	r6,r20,r6
   27f70:	2000683a 	jmp	r4
   27f74:	00028158 	cmpnei	zero,zero,2565
   27f78:	00027fdc 	xori	zero,zero,2559
   27f7c:	0002814c 	andi	zero,zero,2565
   27f80:	00027fc8 	cmpgei	zero,zero,2559
   27f84:	0002814c 	andi	zero,zero,2565
   27f88:	00028124 	muli	zero,zero,2564
   27f8c:	0002814c 	andi	zero,zero,2565
   27f90:	00027fc8 	cmpgei	zero,zero,2559
   27f94:	00027fdc 	xori	zero,zero,2559
   27f98:	00027fdc 	xori	zero,zero,2559
   27f9c:	00028124 	muli	zero,zero,2564
   27fa0:	00027fc8 	cmpgei	zero,zero,2559
   27fa4:	00028238 	rdprs	zero,zero,2568
   27fa8:	00028238 	rdprs	zero,zero,2568
   27fac:	00028238 	rdprs	zero,zero,2568
   27fb0:	000281ec 	andhi	zero,zero,2567
   27fb4:	9000581e 	bne	r18,zero,28118 <__divsf3+0x270>
   27fb8:	04000204 	movi	r16,8
   27fbc:	05c00084 	movi	r23,2
   27fc0:	003fd306 	br	27f10 <__reset+0xfff87f10>
   27fc4:	0023883a 	mov	r17,zero
   27fc8:	e02d883a 	mov	r22,fp
   27fcc:	282f883a 	mov	r23,r5
   27fd0:	00800084 	movi	r2,2
   27fd4:	b8808f1e 	bne	r23,r2,28214 <__divsf3+0x36c>
   27fd8:	b005883a 	mov	r2,r22
   27fdc:	11c0004c 	andi	r7,r2,1
   27fe0:	013fffc4 	movi	r4,-1
   27fe4:	000d883a 	mov	r6,zero
   27fe8:	21003fcc 	andi	r4,r4,255
   27fec:	200895fa 	slli	r4,r4,23
   27ff0:	38803fcc 	andi	r2,r7,255
   27ff4:	00c02034 	movhi	r3,128
   27ff8:	100497fa 	slli	r2,r2,31
   27ffc:	18ffffc4 	addi	r3,r3,-1
   28000:	30c6703a 	and	r3,r6,r3
   28004:	1906b03a 	or	r3,r3,r4
   28008:	1884b03a 	or	r2,r3,r2
   2800c:	dfc00a17 	ldw	ra,40(sp)
   28010:	df000917 	ldw	fp,36(sp)
   28014:	ddc00817 	ldw	r23,32(sp)
   28018:	dd800717 	ldw	r22,28(sp)
   2801c:	dd400617 	ldw	r21,24(sp)
   28020:	dd000517 	ldw	r20,20(sp)
   28024:	dcc00417 	ldw	r19,16(sp)
   28028:	dc800317 	ldw	r18,12(sp)
   2802c:	dc400217 	ldw	r17,8(sp)
   28030:	dc000117 	ldw	r16,4(sp)
   28034:	dec00b04 	addi	sp,sp,44
   28038:	f800283a 	ret
   2803c:	90002b1e 	bne	r18,zero,280ec <__divsf3+0x244>
   28040:	04000104 	movi	r16,4
   28044:	05c00044 	movi	r23,1
   28048:	003fb106 	br	27f10 <__reset+0xfff87f10>
   2804c:	8800251e 	bne	r17,zero,280e4 <__divsf3+0x23c>
   28050:	01400084 	movi	r5,2
   28054:	00000206 	br	28060 <__divsf3+0x1b8>
   28058:	88001a1e 	bne	r17,zero,280c4 <__divsf3+0x21c>
   2805c:	01400044 	movi	r5,1
   28060:	8160b03a 	or	r16,r16,r5
   28064:	802090ba 	slli	r16,r16,2
   28068:	00c000f4 	movhi	r3,3
   2806c:	18e02104 	addi	r3,r3,-32636
   28070:	80e1883a 	add	r16,r16,r3
   28074:	80c00017 	ldw	r3,0(r16)
   28078:	9d44f03a 	xor	r2,r19,r21
   2807c:	a18dc83a 	sub	r6,r20,r6
   28080:	1800683a 	jmp	r3
   28084:	00027fdc 	xori	zero,zero,2559
   28088:	00027fdc 	xori	zero,zero,2559
   2808c:	00028228 	cmpgeui	zero,zero,2568
   28090:	00027fc4 	movi	zero,2559
   28094:	00028228 	cmpgeui	zero,zero,2568
   28098:	00028124 	muli	zero,zero,2564
   2809c:	00028228 	cmpgeui	zero,zero,2568
   280a0:	00027fc4 	movi	zero,2559
   280a4:	00027fdc 	xori	zero,zero,2559
   280a8:	00027fdc 	xori	zero,zero,2559
   280ac:	00028124 	muli	zero,zero,2564
   280b0:	00027fc4 	movi	zero,2559
   280b4:	00028238 	rdprs	zero,zero,2568
   280b8:	00028238 	rdprs	zero,zero,2568
   280bc:	00028238 	rdprs	zero,zero,2568
   280c0:	00028250 	cmplti	zero,zero,2569
   280c4:	8809883a 	mov	r4,r17
   280c8:	002b6480 	call	2b648 <__clzsi2>
   280cc:	10fffec4 	addi	r3,r2,-5
   280d0:	10801d84 	addi	r2,r2,118
   280d4:	88e2983a 	sll	r17,r17,r3
   280d8:	008dc83a 	sub	r6,zero,r2
   280dc:	000b883a 	mov	r5,zero
   280e0:	003f9906 	br	27f48 <__reset+0xfff87f48>
   280e4:	014000c4 	movi	r5,3
   280e8:	003f9706 	br	27f48 <__reset+0xfff87f48>
   280ec:	9009883a 	mov	r4,r18
   280f0:	d9400015 	stw	r5,0(sp)
   280f4:	002b6480 	call	2b648 <__clzsi2>
   280f8:	10fffec4 	addi	r3,r2,-5
   280fc:	11801d84 	addi	r6,r2,118
   28100:	90e4983a 	sll	r18,r18,r3
   28104:	01a9c83a 	sub	r20,zero,r6
   28108:	0021883a 	mov	r16,zero
   2810c:	002f883a 	mov	r23,zero
   28110:	d9400017 	ldw	r5,0(sp)
   28114:	003f7e06 	br	27f10 <__reset+0xfff87f10>
   28118:	04000304 	movi	r16,12
   2811c:	05c000c4 	movi	r23,3
   28120:	003f7b06 	br	27f10 <__reset+0xfff87f10>
   28124:	01802034 	movhi	r6,128
   28128:	000f883a 	mov	r7,zero
   2812c:	31bfffc4 	addi	r6,r6,-1
   28130:	013fffc4 	movi	r4,-1
   28134:	003fac06 	br	27fe8 <__reset+0xfff87fe8>
   28138:	01400044 	movi	r5,1
   2813c:	2909c83a 	sub	r4,r5,r4
   28140:	00c006c4 	movi	r3,27
   28144:	19004b0e 	bge	r3,r4,28274 <__divsf3+0x3cc>
   28148:	114e703a 	and	r7,r2,r5
   2814c:	0009883a 	mov	r4,zero
   28150:	000d883a 	mov	r6,zero
   28154:	003fa406 	br	27fe8 <__reset+0xfff87fe8>
   28158:	9006917a 	slli	r3,r18,5
   2815c:	8822917a 	slli	r17,r17,5
   28160:	1c40372e 	bgeu	r3,r17,28240 <__divsf3+0x398>
   28164:	31bfffc4 	addi	r6,r6,-1
   28168:	010006c4 	movi	r4,27
   2816c:	000b883a 	mov	r5,zero
   28170:	180f883a 	mov	r7,r3
   28174:	294b883a 	add	r5,r5,r5
   28178:	18c7883a 	add	r3,r3,r3
   2817c:	38000116 	blt	r7,zero,28184 <__divsf3+0x2dc>
   28180:	1c400236 	bltu	r3,r17,2818c <__divsf3+0x2e4>
   28184:	1c47c83a 	sub	r3,r3,r17
   28188:	29400054 	ori	r5,r5,1
   2818c:	213fffc4 	addi	r4,r4,-1
   28190:	203ff71e 	bne	r4,zero,28170 <__reset+0xfff88170>
   28194:	1806c03a 	cmpne	r3,r3,zero
   28198:	1962b03a 	or	r17,r3,r5
   2819c:	31001fc4 	addi	r4,r6,127
   281a0:	013fe50e 	bge	zero,r4,28138 <__reset+0xfff88138>
   281a4:	88c001cc 	andi	r3,r17,7
   281a8:	18000426 	beq	r3,zero,281bc <__divsf3+0x314>
   281ac:	88c003cc 	andi	r3,r17,15
   281b0:	01400104 	movi	r5,4
   281b4:	19400126 	beq	r3,r5,281bc <__divsf3+0x314>
   281b8:	8963883a 	add	r17,r17,r5
   281bc:	88c2002c 	andhi	r3,r17,2048
   281c0:	18000426 	beq	r3,zero,281d4 <__divsf3+0x32c>
   281c4:	00fe0034 	movhi	r3,63488
   281c8:	18ffffc4 	addi	r3,r3,-1
   281cc:	31002004 	addi	r4,r6,128
   281d0:	88e2703a 	and	r17,r17,r3
   281d4:	00c03f84 	movi	r3,254
   281d8:	193f8016 	blt	r3,r4,27fdc <__reset+0xfff87fdc>
   281dc:	880c91ba 	slli	r6,r17,6
   281e0:	11c0004c 	andi	r7,r2,1
   281e4:	300cd27a 	srli	r6,r6,9
   281e8:	003f7f06 	br	27fe8 <__reset+0xfff87fe8>
   281ec:	9080102c 	andhi	r2,r18,64
   281f0:	10000226 	beq	r2,zero,281fc <__divsf3+0x354>
   281f4:	8880102c 	andhi	r2,r17,64
   281f8:	10001826 	beq	r2,zero,2825c <__divsf3+0x3b4>
   281fc:	00802034 	movhi	r2,128
   28200:	91801034 	orhi	r6,r18,64
   28204:	10bfffc4 	addi	r2,r2,-1
   28208:	980f883a 	mov	r7,r19
   2820c:	308c703a 	and	r6,r6,r2
   28210:	003fc706 	br	28130 <__reset+0xfff88130>
   28214:	008000c4 	movi	r2,3
   28218:	b8802d26 	beq	r23,r2,282d0 <__divsf3+0x428>
   2821c:	00c00044 	movi	r3,1
   28220:	b005883a 	mov	r2,r22
   28224:	b8ffdd1e 	bne	r23,r3,2819c <__reset+0xfff8819c>
   28228:	11c0004c 	andi	r7,r2,1
   2822c:	0009883a 	mov	r4,zero
   28230:	000d883a 	mov	r6,zero
   28234:	003f6c06 	br	27fe8 <__reset+0xfff87fe8>
   28238:	9023883a 	mov	r17,r18
   2823c:	003f6406 	br	27fd0 <__reset+0xfff87fd0>
   28240:	1c47c83a 	sub	r3,r3,r17
   28244:	01000684 	movi	r4,26
   28248:	01400044 	movi	r5,1
   2824c:	003fc806 	br	28170 <__reset+0xfff88170>
   28250:	9080102c 	andhi	r2,r18,64
   28254:	103fe926 	beq	r2,zero,281fc <__reset+0xfff881fc>
   28258:	0023883a 	mov	r17,zero
   2825c:	00802034 	movhi	r2,128
   28260:	89801034 	orhi	r6,r17,64
   28264:	10bfffc4 	addi	r2,r2,-1
   28268:	a80f883a 	mov	r7,r21
   2826c:	308c703a 	and	r6,r6,r2
   28270:	003faf06 	br	28130 <__reset+0xfff88130>
   28274:	01c00804 	movi	r7,32
   28278:	390fc83a 	sub	r7,r7,r4
   2827c:	89ce983a 	sll	r7,r17,r7
   28280:	890ad83a 	srl	r5,r17,r4
   28284:	380ec03a 	cmpne	r7,r7,zero
   28288:	29cab03a 	or	r5,r5,r7
   2828c:	28c001cc 	andi	r3,r5,7
   28290:	18000426 	beq	r3,zero,282a4 <__divsf3+0x3fc>
   28294:	28c003cc 	andi	r3,r5,15
   28298:	01000104 	movi	r4,4
   2829c:	19000126 	beq	r3,r4,282a4 <__divsf3+0x3fc>
   282a0:	290b883a 	add	r5,r5,r4
   282a4:	28c1002c 	andhi	r3,r5,1024
   282a8:	18000426 	beq	r3,zero,282bc <__divsf3+0x414>
   282ac:	11c0004c 	andi	r7,r2,1
   282b0:	01000044 	movi	r4,1
   282b4:	000d883a 	mov	r6,zero
   282b8:	003f4b06 	br	27fe8 <__reset+0xfff87fe8>
   282bc:	280a91ba 	slli	r5,r5,6
   282c0:	11c0004c 	andi	r7,r2,1
   282c4:	0009883a 	mov	r4,zero
   282c8:	280cd27a 	srli	r6,r5,9
   282cc:	003f4606 	br	27fe8 <__reset+0xfff87fe8>
   282d0:	00802034 	movhi	r2,128
   282d4:	89801034 	orhi	r6,r17,64
   282d8:	10bfffc4 	addi	r2,r2,-1
   282dc:	b00f883a 	mov	r7,r22
   282e0:	308c703a 	and	r6,r6,r2
   282e4:	003f9206 	br	28130 <__reset+0xfff88130>

000282e8 <__gesf2>:
   282e8:	2004d5fa 	srli	r2,r4,23
   282ec:	2806d5fa 	srli	r3,r5,23
   282f0:	01802034 	movhi	r6,128
   282f4:	31bfffc4 	addi	r6,r6,-1
   282f8:	10803fcc 	andi	r2,r2,255
   282fc:	01c03fc4 	movi	r7,255
   28300:	3110703a 	and	r8,r6,r4
   28304:	18c03fcc 	andi	r3,r3,255
   28308:	314c703a 	and	r6,r6,r5
   2830c:	2008d7fa 	srli	r4,r4,31
   28310:	280ad7fa 	srli	r5,r5,31
   28314:	11c01926 	beq	r2,r7,2837c <__gesf2+0x94>
   28318:	01c03fc4 	movi	r7,255
   2831c:	19c00f26 	beq	r3,r7,2835c <__gesf2+0x74>
   28320:	1000061e 	bne	r2,zero,2833c <__gesf2+0x54>
   28324:	400f003a 	cmpeq	r7,r8,zero
   28328:	1800071e 	bne	r3,zero,28348 <__gesf2+0x60>
   2832c:	3000061e 	bne	r6,zero,28348 <__gesf2+0x60>
   28330:	0005883a 	mov	r2,zero
   28334:	40000e1e 	bne	r8,zero,28370 <__gesf2+0x88>
   28338:	f800283a 	ret
   2833c:	18000a1e 	bne	r3,zero,28368 <__gesf2+0x80>
   28340:	30000b26 	beq	r6,zero,28370 <__gesf2+0x88>
   28344:	000f883a 	mov	r7,zero
   28348:	29403fcc 	andi	r5,r5,255
   2834c:	38000726 	beq	r7,zero,2836c <__gesf2+0x84>
   28350:	28000826 	beq	r5,zero,28374 <__gesf2+0x8c>
   28354:	00800044 	movi	r2,1
   28358:	f800283a 	ret
   2835c:	303ff026 	beq	r6,zero,28320 <__reset+0xfff88320>
   28360:	00bfff84 	movi	r2,-2
   28364:	f800283a 	ret
   28368:	29403fcc 	andi	r5,r5,255
   2836c:	21400526 	beq	r4,r5,28384 <__gesf2+0x9c>
   28370:	203ff826 	beq	r4,zero,28354 <__reset+0xfff88354>
   28374:	00bfffc4 	movi	r2,-1
   28378:	f800283a 	ret
   2837c:	403fe626 	beq	r8,zero,28318 <__reset+0xfff88318>
   28380:	003ff706 	br	28360 <__reset+0xfff88360>
   28384:	18bffa16 	blt	r3,r2,28370 <__reset+0xfff88370>
   28388:	10c00216 	blt	r2,r3,28394 <__gesf2+0xac>
   2838c:	323ff836 	bltu	r6,r8,28370 <__reset+0xfff88370>
   28390:	4180022e 	bgeu	r8,r6,2839c <__gesf2+0xb4>
   28394:	203fef1e 	bne	r4,zero,28354 <__reset+0xfff88354>
   28398:	003ff606 	br	28374 <__reset+0xfff88374>
   2839c:	0005883a 	mov	r2,zero
   283a0:	f800283a 	ret

000283a4 <__mulsf3>:
   283a4:	defff504 	addi	sp,sp,-44
   283a8:	dc000115 	stw	r16,4(sp)
   283ac:	2020d5fa 	srli	r16,r4,23
   283b0:	dd400615 	stw	r21,24(sp)
   283b4:	202ad7fa 	srli	r21,r4,31
   283b8:	dc800315 	stw	r18,12(sp)
   283bc:	04802034 	movhi	r18,128
   283c0:	df000915 	stw	fp,36(sp)
   283c4:	dd000515 	stw	r20,20(sp)
   283c8:	94bfffc4 	addi	r18,r18,-1
   283cc:	dfc00a15 	stw	ra,40(sp)
   283d0:	ddc00815 	stw	r23,32(sp)
   283d4:	dd800715 	stw	r22,28(sp)
   283d8:	dcc00415 	stw	r19,16(sp)
   283dc:	dc400215 	stw	r17,8(sp)
   283e0:	84003fcc 	andi	r16,r16,255
   283e4:	9124703a 	and	r18,r18,r4
   283e8:	a829883a 	mov	r20,r21
   283ec:	af003fcc 	andi	fp,r21,255
   283f0:	80005426 	beq	r16,zero,28544 <__mulsf3+0x1a0>
   283f4:	00803fc4 	movi	r2,255
   283f8:	80802f26 	beq	r16,r2,284b8 <__mulsf3+0x114>
   283fc:	91002034 	orhi	r4,r18,128
   28400:	202490fa 	slli	r18,r4,3
   28404:	843fe044 	addi	r16,r16,-127
   28408:	0023883a 	mov	r17,zero
   2840c:	002f883a 	mov	r23,zero
   28410:	2804d5fa 	srli	r2,r5,23
   28414:	282cd7fa 	srli	r22,r5,31
   28418:	01002034 	movhi	r4,128
   2841c:	213fffc4 	addi	r4,r4,-1
   28420:	10803fcc 	andi	r2,r2,255
   28424:	2166703a 	and	r19,r4,r5
   28428:	b1803fcc 	andi	r6,r22,255
   2842c:	10004c26 	beq	r2,zero,28560 <__mulsf3+0x1bc>
   28430:	00c03fc4 	movi	r3,255
   28434:	10c04726 	beq	r2,r3,28554 <__mulsf3+0x1b0>
   28438:	99002034 	orhi	r4,r19,128
   2843c:	202690fa 	slli	r19,r4,3
   28440:	10bfe044 	addi	r2,r2,-127
   28444:	0007883a 	mov	r3,zero
   28448:	80a1883a 	add	r16,r16,r2
   2844c:	010003c4 	movi	r4,15
   28450:	1c44b03a 	or	r2,r3,r17
   28454:	b56af03a 	xor	r21,r22,r21
   28458:	81c00044 	addi	r7,r16,1
   2845c:	20806b36 	bltu	r4,r2,2860c <__mulsf3+0x268>
   28460:	100490ba 	slli	r2,r2,2
   28464:	010000f4 	movhi	r4,3
   28468:	21211e04 	addi	r4,r4,-31624
   2846c:	1105883a 	add	r2,r2,r4
   28470:	10800017 	ldw	r2,0(r2)
   28474:	1000683a 	jmp	r2
   28478:	0002860c 	andi	zero,zero,2584
   2847c:	000284cc 	andi	zero,zero,2579
   28480:	000284cc 	andi	zero,zero,2579
   28484:	000284c8 	cmpgei	zero,zero,2579
   28488:	000285f0 	cmpltui	zero,zero,2583
   2848c:	000285f0 	cmpltui	zero,zero,2583
   28490:	000285dc 	xori	zero,zero,2583
   28494:	000284c8 	cmpgei	zero,zero,2579
   28498:	000285f0 	cmpltui	zero,zero,2583
   2849c:	000285dc 	xori	zero,zero,2583
   284a0:	000285f0 	cmpltui	zero,zero,2583
   284a4:	000284c8 	cmpgei	zero,zero,2579
   284a8:	000285fc 	xorhi	zero,zero,2583
   284ac:	000285fc 	xorhi	zero,zero,2583
   284b0:	000285fc 	xorhi	zero,zero,2583
   284b4:	000286d8 	cmpnei	zero,zero,2587
   284b8:	90003b1e 	bne	r18,zero,285a8 <__mulsf3+0x204>
   284bc:	04400204 	movi	r17,8
   284c0:	05c00084 	movi	r23,2
   284c4:	003fd206 	br	28410 <__reset+0xfff88410>
   284c8:	302b883a 	mov	r21,r6
   284cc:	00800084 	movi	r2,2
   284d0:	18802626 	beq	r3,r2,2856c <__mulsf3+0x1c8>
   284d4:	008000c4 	movi	r2,3
   284d8:	1880ab26 	beq	r3,r2,28788 <__mulsf3+0x3e4>
   284dc:	00800044 	movi	r2,1
   284e0:	1880a21e 	bne	r3,r2,2876c <__mulsf3+0x3c8>
   284e4:	a829883a 	mov	r20,r21
   284e8:	0007883a 	mov	r3,zero
   284ec:	0009883a 	mov	r4,zero
   284f0:	18803fcc 	andi	r2,r3,255
   284f4:	100695fa 	slli	r3,r2,23
   284f8:	a0803fcc 	andi	r2,r20,255
   284fc:	100a97fa 	slli	r5,r2,31
   28500:	00802034 	movhi	r2,128
   28504:	10bfffc4 	addi	r2,r2,-1
   28508:	2084703a 	and	r2,r4,r2
   2850c:	10c4b03a 	or	r2,r2,r3
   28510:	1144b03a 	or	r2,r2,r5
   28514:	dfc00a17 	ldw	ra,40(sp)
   28518:	df000917 	ldw	fp,36(sp)
   2851c:	ddc00817 	ldw	r23,32(sp)
   28520:	dd800717 	ldw	r22,28(sp)
   28524:	dd400617 	ldw	r21,24(sp)
   28528:	dd000517 	ldw	r20,20(sp)
   2852c:	dcc00417 	ldw	r19,16(sp)
   28530:	dc800317 	ldw	r18,12(sp)
   28534:	dc400217 	ldw	r17,8(sp)
   28538:	dc000117 	ldw	r16,4(sp)
   2853c:	dec00b04 	addi	sp,sp,44
   28540:	f800283a 	ret
   28544:	90000d1e 	bne	r18,zero,2857c <__mulsf3+0x1d8>
   28548:	04400104 	movi	r17,4
   2854c:	05c00044 	movi	r23,1
   28550:	003faf06 	br	28410 <__reset+0xfff88410>
   28554:	9806c03a 	cmpne	r3,r19,zero
   28558:	18c00084 	addi	r3,r3,2
   2855c:	003fba06 	br	28448 <__reset+0xfff88448>
   28560:	9800141e 	bne	r19,zero,285b4 <__mulsf3+0x210>
   28564:	00c00044 	movi	r3,1
   28568:	003fb706 	br	28448 <__reset+0xfff88448>
   2856c:	a829883a 	mov	r20,r21
   28570:	00ffffc4 	movi	r3,-1
   28574:	0009883a 	mov	r4,zero
   28578:	003fdd06 	br	284f0 <__reset+0xfff884f0>
   2857c:	9009883a 	mov	r4,r18
   28580:	d9400015 	stw	r5,0(sp)
   28584:	002b6480 	call	2b648 <__clzsi2>
   28588:	10fffec4 	addi	r3,r2,-5
   2858c:	10801d84 	addi	r2,r2,118
   28590:	90e4983a 	sll	r18,r18,r3
   28594:	00a1c83a 	sub	r16,zero,r2
   28598:	0023883a 	mov	r17,zero
   2859c:	002f883a 	mov	r23,zero
   285a0:	d9400017 	ldw	r5,0(sp)
   285a4:	003f9a06 	br	28410 <__reset+0xfff88410>
   285a8:	04400304 	movi	r17,12
   285ac:	05c000c4 	movi	r23,3
   285b0:	003f9706 	br	28410 <__reset+0xfff88410>
   285b4:	9809883a 	mov	r4,r19
   285b8:	d9800015 	stw	r6,0(sp)
   285bc:	002b6480 	call	2b648 <__clzsi2>
   285c0:	10fffec4 	addi	r3,r2,-5
   285c4:	10801d84 	addi	r2,r2,118
   285c8:	98e6983a 	sll	r19,r19,r3
   285cc:	0085c83a 	sub	r2,zero,r2
   285d0:	0007883a 	mov	r3,zero
   285d4:	d9800017 	ldw	r6,0(sp)
   285d8:	003f9b06 	br	28448 <__reset+0xfff88448>
   285dc:	01002034 	movhi	r4,128
   285e0:	0029883a 	mov	r20,zero
   285e4:	213fffc4 	addi	r4,r4,-1
   285e8:	00ffffc4 	movi	r3,-1
   285ec:	003fc006 	br	284f0 <__reset+0xfff884f0>
   285f0:	9027883a 	mov	r19,r18
   285f4:	b807883a 	mov	r3,r23
   285f8:	003fb406 	br	284cc <__reset+0xfff884cc>
   285fc:	9027883a 	mov	r19,r18
   28600:	e02b883a 	mov	r21,fp
   28604:	b807883a 	mov	r3,r23
   28608:	003fb006 	br	284cc <__reset+0xfff884cc>
   2860c:	9004d43a 	srli	r2,r18,16
   28610:	9810d43a 	srli	r8,r19,16
   28614:	94bfffcc 	andi	r18,r18,65535
   28618:	993fffcc 	andi	r4,r19,65535
   2861c:	910d383a 	mul	r6,r18,r4
   28620:	20a7383a 	mul	r19,r4,r2
   28624:	9225383a 	mul	r18,r18,r8
   28628:	3006d43a 	srli	r3,r6,16
   2862c:	1211383a 	mul	r8,r2,r8
   28630:	94e5883a 	add	r18,r18,r19
   28634:	1c87883a 	add	r3,r3,r18
   28638:	1cc0022e 	bgeu	r3,r19,28644 <__mulsf3+0x2a0>
   2863c:	00800074 	movhi	r2,1
   28640:	4091883a 	add	r8,r8,r2
   28644:	1804943a 	slli	r2,r3,16
   28648:	31bfffcc 	andi	r6,r6,65535
   2864c:	1806d43a 	srli	r3,r3,16
   28650:	1185883a 	add	r2,r2,r6
   28654:	102691ba 	slli	r19,r2,6
   28658:	1a07883a 	add	r3,r3,r8
   2865c:	1004d6ba 	srli	r2,r2,26
   28660:	180891ba 	slli	r4,r3,6
   28664:	9826c03a 	cmpne	r19,r19,zero
   28668:	9884b03a 	or	r2,r19,r2
   2866c:	1126b03a 	or	r19,r2,r4
   28670:	9882002c 	andhi	r2,r19,2048
   28674:	10000426 	beq	r2,zero,28688 <__mulsf3+0x2e4>
   28678:	9804d07a 	srli	r2,r19,1
   2867c:	9900004c 	andi	r4,r19,1
   28680:	3821883a 	mov	r16,r7
   28684:	1126b03a 	or	r19,r2,r4
   28688:	80c01fc4 	addi	r3,r16,127
   2868c:	00c0210e 	bge	zero,r3,28714 <__mulsf3+0x370>
   28690:	988001cc 	andi	r2,r19,7
   28694:	10000426 	beq	r2,zero,286a8 <__mulsf3+0x304>
   28698:	988003cc 	andi	r2,r19,15
   2869c:	01000104 	movi	r4,4
   286a0:	11000126 	beq	r2,r4,286a8 <__mulsf3+0x304>
   286a4:	9927883a 	add	r19,r19,r4
   286a8:	9882002c 	andhi	r2,r19,2048
   286ac:	10000426 	beq	r2,zero,286c0 <__mulsf3+0x31c>
   286b0:	00be0034 	movhi	r2,63488
   286b4:	10bfffc4 	addi	r2,r2,-1
   286b8:	80c02004 	addi	r3,r16,128
   286bc:	98a6703a 	and	r19,r19,r2
   286c0:	00803f84 	movi	r2,254
   286c4:	10ffa916 	blt	r2,r3,2856c <__reset+0xfff8856c>
   286c8:	980891ba 	slli	r4,r19,6
   286cc:	a829883a 	mov	r20,r21
   286d0:	2008d27a 	srli	r4,r4,9
   286d4:	003f8606 	br	284f0 <__reset+0xfff884f0>
   286d8:	9080102c 	andhi	r2,r18,64
   286dc:	10000826 	beq	r2,zero,28700 <__mulsf3+0x35c>
   286e0:	9880102c 	andhi	r2,r19,64
   286e4:	1000061e 	bne	r2,zero,28700 <__mulsf3+0x35c>
   286e8:	00802034 	movhi	r2,128
   286ec:	99001034 	orhi	r4,r19,64
   286f0:	10bfffc4 	addi	r2,r2,-1
   286f4:	b029883a 	mov	r20,r22
   286f8:	2088703a 	and	r4,r4,r2
   286fc:	003fba06 	br	285e8 <__reset+0xfff885e8>
   28700:	00802034 	movhi	r2,128
   28704:	91001034 	orhi	r4,r18,64
   28708:	10bfffc4 	addi	r2,r2,-1
   2870c:	2088703a 	and	r4,r4,r2
   28710:	003fb506 	br	285e8 <__reset+0xfff885e8>
   28714:	00800044 	movi	r2,1
   28718:	10c7c83a 	sub	r3,r2,r3
   2871c:	008006c4 	movi	r2,27
   28720:	10ff7016 	blt	r2,r3,284e4 <__reset+0xfff884e4>
   28724:	00800804 	movi	r2,32
   28728:	10c5c83a 	sub	r2,r2,r3
   2872c:	9884983a 	sll	r2,r19,r2
   28730:	98c6d83a 	srl	r3,r19,r3
   28734:	1004c03a 	cmpne	r2,r2,zero
   28738:	1884b03a 	or	r2,r3,r2
   2873c:	10c001cc 	andi	r3,r2,7
   28740:	18000426 	beq	r3,zero,28754 <__mulsf3+0x3b0>
   28744:	10c003cc 	andi	r3,r2,15
   28748:	01000104 	movi	r4,4
   2874c:	19000126 	beq	r3,r4,28754 <__mulsf3+0x3b0>
   28750:	1105883a 	add	r2,r2,r4
   28754:	10c1002c 	andhi	r3,r2,1024
   28758:	18000626 	beq	r3,zero,28774 <__mulsf3+0x3d0>
   2875c:	a829883a 	mov	r20,r21
   28760:	00c00044 	movi	r3,1
   28764:	0009883a 	mov	r4,zero
   28768:	003f6106 	br	284f0 <__reset+0xfff884f0>
   2876c:	3821883a 	mov	r16,r7
   28770:	003fc506 	br	28688 <__reset+0xfff88688>
   28774:	100491ba 	slli	r2,r2,6
   28778:	a829883a 	mov	r20,r21
   2877c:	0007883a 	mov	r3,zero
   28780:	1008d27a 	srli	r4,r2,9
   28784:	003f5a06 	br	284f0 <__reset+0xfff884f0>
   28788:	00802034 	movhi	r2,128
   2878c:	99001034 	orhi	r4,r19,64
   28790:	10bfffc4 	addi	r2,r2,-1
   28794:	a829883a 	mov	r20,r21
   28798:	2088703a 	and	r4,r4,r2
   2879c:	003f9206 	br	285e8 <__reset+0xfff885e8>

000287a0 <__subsf3>:
   287a0:	defffc04 	addi	sp,sp,-16
   287a4:	280cd5fa 	srli	r6,r5,23
   287a8:	dc000015 	stw	r16,0(sp)
   287ac:	01c02034 	movhi	r7,128
   287b0:	2020d5fa 	srli	r16,r4,23
   287b4:	39ffffc4 	addi	r7,r7,-1
   287b8:	3906703a 	and	r3,r7,r4
   287bc:	dc400115 	stw	r17,4(sp)
   287c0:	394e703a 	and	r7,r7,r5
   287c4:	2022d7fa 	srli	r17,r4,31
   287c8:	dfc00315 	stw	ra,12(sp)
   287cc:	dc800215 	stw	r18,8(sp)
   287d0:	31803fcc 	andi	r6,r6,255
   287d4:	01003fc4 	movi	r4,255
   287d8:	84003fcc 	andi	r16,r16,255
   287dc:	180690fa 	slli	r3,r3,3
   287e0:	2804d7fa 	srli	r2,r5,31
   287e4:	380e90fa 	slli	r7,r7,3
   287e8:	31006d26 	beq	r6,r4,289a0 <__subsf3+0x200>
   287ec:	1080005c 	xori	r2,r2,1
   287f0:	8189c83a 	sub	r4,r16,r6
   287f4:	14404f26 	beq	r2,r17,28934 <__subsf3+0x194>
   287f8:	0100770e 	bge	zero,r4,289d8 <__subsf3+0x238>
   287fc:	30001e1e 	bne	r6,zero,28878 <__subsf3+0xd8>
   28800:	38006a1e 	bne	r7,zero,289ac <__subsf3+0x20c>
   28804:	188001cc 	andi	r2,r3,7
   28808:	10000426 	beq	r2,zero,2881c <__subsf3+0x7c>
   2880c:	188003cc 	andi	r2,r3,15
   28810:	01000104 	movi	r4,4
   28814:	11000126 	beq	r2,r4,2881c <__subsf3+0x7c>
   28818:	1907883a 	add	r3,r3,r4
   2881c:	1881002c 	andhi	r2,r3,1024
   28820:	10003926 	beq	r2,zero,28908 <__subsf3+0x168>
   28824:	84000044 	addi	r16,r16,1
   28828:	00803fc4 	movi	r2,255
   2882c:	80807526 	beq	r16,r2,28a04 <__subsf3+0x264>
   28830:	180691ba 	slli	r3,r3,6
   28834:	8880004c 	andi	r2,r17,1
   28838:	180ad27a 	srli	r5,r3,9
   2883c:	84003fcc 	andi	r16,r16,255
   28840:	800695fa 	slli	r3,r16,23
   28844:	10803fcc 	andi	r2,r2,255
   28848:	01002034 	movhi	r4,128
   2884c:	213fffc4 	addi	r4,r4,-1
   28850:	100497fa 	slli	r2,r2,31
   28854:	2920703a 	and	r16,r5,r4
   28858:	80e0b03a 	or	r16,r16,r3
   2885c:	8084b03a 	or	r2,r16,r2
   28860:	dfc00317 	ldw	ra,12(sp)
   28864:	dc800217 	ldw	r18,8(sp)
   28868:	dc400117 	ldw	r17,4(sp)
   2886c:	dc000017 	ldw	r16,0(sp)
   28870:	dec00404 	addi	sp,sp,16
   28874:	f800283a 	ret
   28878:	00803fc4 	movi	r2,255
   2887c:	80bfe126 	beq	r16,r2,28804 <__reset+0xfff88804>
   28880:	39c10034 	orhi	r7,r7,1024
   28884:	008006c4 	movi	r2,27
   28888:	11007416 	blt	r2,r4,28a5c <__subsf3+0x2bc>
   2888c:	00800804 	movi	r2,32
   28890:	1105c83a 	sub	r2,r2,r4
   28894:	3884983a 	sll	r2,r7,r2
   28898:	390ed83a 	srl	r7,r7,r4
   2889c:	1008c03a 	cmpne	r4,r2,zero
   288a0:	390eb03a 	or	r7,r7,r4
   288a4:	19c7c83a 	sub	r3,r3,r7
   288a8:	1881002c 	andhi	r2,r3,1024
   288ac:	10001426 	beq	r2,zero,28900 <__subsf3+0x160>
   288b0:	04810034 	movhi	r18,1024
   288b4:	94bfffc4 	addi	r18,r18,-1
   288b8:	1ca4703a 	and	r18,r3,r18
   288bc:	9009883a 	mov	r4,r18
   288c0:	002b6480 	call	2b648 <__clzsi2>
   288c4:	10bffec4 	addi	r2,r2,-5
   288c8:	90a4983a 	sll	r18,r18,r2
   288cc:	14005116 	blt	r2,r16,28a14 <__subsf3+0x274>
   288d0:	1405c83a 	sub	r2,r2,r16
   288d4:	10c00044 	addi	r3,r2,1
   288d8:	00800804 	movi	r2,32
   288dc:	10c5c83a 	sub	r2,r2,r3
   288e0:	9084983a 	sll	r2,r18,r2
   288e4:	90e4d83a 	srl	r18,r18,r3
   288e8:	0021883a 	mov	r16,zero
   288ec:	1006c03a 	cmpne	r3,r2,zero
   288f0:	90c6b03a 	or	r3,r18,r3
   288f4:	003fc306 	br	28804 <__reset+0xfff88804>
   288f8:	2000e026 	beq	r4,zero,28c7c <__subsf3+0x4dc>
   288fc:	2007883a 	mov	r3,r4
   28900:	188001cc 	andi	r2,r3,7
   28904:	103fc11e 	bne	r2,zero,2880c <__reset+0xfff8880c>
   28908:	180ad0fa 	srli	r5,r3,3
   2890c:	00c03fc4 	movi	r3,255
   28910:	8880004c 	andi	r2,r17,1
   28914:	80c0031e 	bne	r16,r3,28924 <__subsf3+0x184>
   28918:	28006d26 	beq	r5,zero,28ad0 <__subsf3+0x330>
   2891c:	29401034 	orhi	r5,r5,64
   28920:	043fffc4 	movi	r16,-1
   28924:	00c02034 	movhi	r3,128
   28928:	18ffffc4 	addi	r3,r3,-1
   2892c:	28ca703a 	and	r5,r5,r3
   28930:	003fc206 	br	2883c <__reset+0xfff8883c>
   28934:	01003c0e 	bge	zero,r4,28a28 <__subsf3+0x288>
   28938:	30002126 	beq	r6,zero,289c0 <__subsf3+0x220>
   2893c:	01403fc4 	movi	r5,255
   28940:	817fb026 	beq	r16,r5,28804 <__reset+0xfff88804>
   28944:	39c10034 	orhi	r7,r7,1024
   28948:	014006c4 	movi	r5,27
   2894c:	29007416 	blt	r5,r4,28b20 <__subsf3+0x380>
   28950:	01400804 	movi	r5,32
   28954:	290bc83a 	sub	r5,r5,r4
   28958:	394a983a 	sll	r5,r7,r5
   2895c:	390ed83a 	srl	r7,r7,r4
   28960:	2808c03a 	cmpne	r4,r5,zero
   28964:	390eb03a 	or	r7,r7,r4
   28968:	19c7883a 	add	r3,r3,r7
   2896c:	1901002c 	andhi	r4,r3,1024
   28970:	20003826 	beq	r4,zero,28a54 <__subsf3+0x2b4>
   28974:	84000044 	addi	r16,r16,1
   28978:	01003fc4 	movi	r4,255
   2897c:	81005426 	beq	r16,r4,28ad0 <__subsf3+0x330>
   28980:	1023883a 	mov	r17,r2
   28984:	00bf0034 	movhi	r2,64512
   28988:	10bfffc4 	addi	r2,r2,-1
   2898c:	1900004c 	andi	r4,r3,1
   28990:	1886703a 	and	r3,r3,r2
   28994:	1806d07a 	srli	r3,r3,1
   28998:	1906b03a 	or	r3,r3,r4
   2899c:	003f9906 	br	28804 <__reset+0xfff88804>
   289a0:	383f9226 	beq	r7,zero,287ec <__reset+0xfff887ec>
   289a4:	10803fcc 	andi	r2,r2,255
   289a8:	003f9106 	br	287f0 <__reset+0xfff887f0>
   289ac:	213fffc4 	addi	r4,r4,-1
   289b0:	203fbc26 	beq	r4,zero,288a4 <__reset+0xfff888a4>
   289b4:	00803fc4 	movi	r2,255
   289b8:	80bfb21e 	bne	r16,r2,28884 <__reset+0xfff88884>
   289bc:	003f9106 	br	28804 <__reset+0xfff88804>
   289c0:	383f9026 	beq	r7,zero,28804 <__reset+0xfff88804>
   289c4:	213fffc4 	addi	r4,r4,-1
   289c8:	203fe726 	beq	r4,zero,28968 <__reset+0xfff88968>
   289cc:	01403fc4 	movi	r5,255
   289d0:	817fdd1e 	bne	r16,r5,28948 <__reset+0xfff88948>
   289d4:	003f8b06 	br	28804 <__reset+0xfff88804>
   289d8:	2000221e 	bne	r4,zero,28a64 <__subsf3+0x2c4>
   289dc:	81000044 	addi	r4,r16,1
   289e0:	21003fcc 	andi	r4,r4,255
   289e4:	01400044 	movi	r5,1
   289e8:	2900470e 	bge	r5,r4,28b08 <__subsf3+0x368>
   289ec:	19e5c83a 	sub	r18,r3,r7
   289f0:	9141002c 	andhi	r5,r18,1024
   289f4:	28002d26 	beq	r5,zero,28aac <__subsf3+0x30c>
   289f8:	38e5c83a 	sub	r18,r7,r3
   289fc:	1023883a 	mov	r17,r2
   28a00:	003fae06 	br	288bc <__reset+0xfff888bc>
   28a04:	8880004c 	andi	r2,r17,1
   28a08:	043fffc4 	movi	r16,-1
   28a0c:	000b883a 	mov	r5,zero
   28a10:	003f8a06 	br	2883c <__reset+0xfff8883c>
   28a14:	00ff0034 	movhi	r3,64512
   28a18:	18ffffc4 	addi	r3,r3,-1
   28a1c:	80a1c83a 	sub	r16,r16,r2
   28a20:	90c6703a 	and	r3,r18,r3
   28a24:	003f7706 	br	28804 <__reset+0xfff88804>
   28a28:	2000431e 	bne	r4,zero,28b38 <__subsf3+0x398>
   28a2c:	81000044 	addi	r4,r16,1
   28a30:	21803fcc 	andi	r6,r4,255
   28a34:	01400044 	movi	r5,1
   28a38:	2980280e 	bge	r5,r6,28adc <__subsf3+0x33c>
   28a3c:	01403fc4 	movi	r5,255
   28a40:	21402326 	beq	r4,r5,28ad0 <__subsf3+0x330>
   28a44:	19c7883a 	add	r3,r3,r7
   28a48:	1806d07a 	srli	r3,r3,1
   28a4c:	2021883a 	mov	r16,r4
   28a50:	003f6c06 	br	28804 <__reset+0xfff88804>
   28a54:	1023883a 	mov	r17,r2
   28a58:	003fa906 	br	28900 <__reset+0xfff88900>
   28a5c:	01c00044 	movi	r7,1
   28a60:	003f9006 	br	288a4 <__reset+0xfff888a4>
   28a64:	8000151e 	bne	r16,zero,28abc <__subsf3+0x31c>
   28a68:	18002f26 	beq	r3,zero,28b28 <__subsf3+0x388>
   28a6c:	0108303a 	nor	r4,zero,r4
   28a70:	20000a26 	beq	r4,zero,28a9c <__subsf3+0x2fc>
   28a74:	01403fc4 	movi	r5,255
   28a78:	31402b26 	beq	r6,r5,28b28 <__subsf3+0x388>
   28a7c:	014006c4 	movi	r5,27
   28a80:	29006e16 	blt	r5,r4,28c3c <__subsf3+0x49c>
   28a84:	01400804 	movi	r5,32
   28a88:	290bc83a 	sub	r5,r5,r4
   28a8c:	194a983a 	sll	r5,r3,r5
   28a90:	1908d83a 	srl	r4,r3,r4
   28a94:	2806c03a 	cmpne	r3,r5,zero
   28a98:	20c6b03a 	or	r3,r4,r3
   28a9c:	38c7c83a 	sub	r3,r7,r3
   28aa0:	3021883a 	mov	r16,r6
   28aa4:	1023883a 	mov	r17,r2
   28aa8:	003f7f06 	br	288a8 <__reset+0xfff888a8>
   28aac:	903f831e 	bne	r18,zero,288bc <__reset+0xfff888bc>
   28ab0:	0005883a 	mov	r2,zero
   28ab4:	0021883a 	mov	r16,zero
   28ab8:	003f9a06 	br	28924 <__reset+0xfff88924>
   28abc:	01403fc4 	movi	r5,255
   28ac0:	31401926 	beq	r6,r5,28b28 <__subsf3+0x388>
   28ac4:	0109c83a 	sub	r4,zero,r4
   28ac8:	18c10034 	orhi	r3,r3,1024
   28acc:	003feb06 	br	28a7c <__reset+0xfff88a7c>
   28ad0:	043fffc4 	movi	r16,-1
   28ad4:	000b883a 	mov	r5,zero
   28ad8:	003f5806 	br	2883c <__reset+0xfff8883c>
   28adc:	8000481e 	bne	r16,zero,28c00 <__subsf3+0x460>
   28ae0:	18006226 	beq	r3,zero,28c6c <__subsf3+0x4cc>
   28ae4:	383f4726 	beq	r7,zero,28804 <__reset+0xfff88804>
   28ae8:	19c7883a 	add	r3,r3,r7
   28aec:	1881002c 	andhi	r2,r3,1024
   28af0:	103f8326 	beq	r2,zero,28900 <__reset+0xfff88900>
   28af4:	00bf0034 	movhi	r2,64512
   28af8:	10bfffc4 	addi	r2,r2,-1
   28afc:	2821883a 	mov	r16,r5
   28b00:	1886703a 	and	r3,r3,r2
   28b04:	003f3f06 	br	28804 <__reset+0xfff88804>
   28b08:	80001c1e 	bne	r16,zero,28b7c <__subsf3+0x3dc>
   28b0c:	1800261e 	bne	r3,zero,28ba8 <__subsf3+0x408>
   28b10:	38004c26 	beq	r7,zero,28c44 <__subsf3+0x4a4>
   28b14:	3807883a 	mov	r3,r7
   28b18:	1023883a 	mov	r17,r2
   28b1c:	003f3906 	br	28804 <__reset+0xfff88804>
   28b20:	01c00044 	movi	r7,1
   28b24:	003f9006 	br	28968 <__reset+0xfff88968>
   28b28:	3807883a 	mov	r3,r7
   28b2c:	3021883a 	mov	r16,r6
   28b30:	1023883a 	mov	r17,r2
   28b34:	003f3306 	br	28804 <__reset+0xfff88804>
   28b38:	8000161e 	bne	r16,zero,28b94 <__subsf3+0x3f4>
   28b3c:	18002d26 	beq	r3,zero,28bf4 <__subsf3+0x454>
   28b40:	0108303a 	nor	r4,zero,r4
   28b44:	20000a26 	beq	r4,zero,28b70 <__subsf3+0x3d0>
   28b48:	01403fc4 	movi	r5,255
   28b4c:	31402926 	beq	r6,r5,28bf4 <__subsf3+0x454>
   28b50:	014006c4 	movi	r5,27
   28b54:	29004716 	blt	r5,r4,28c74 <__subsf3+0x4d4>
   28b58:	01400804 	movi	r5,32
   28b5c:	290bc83a 	sub	r5,r5,r4
   28b60:	194a983a 	sll	r5,r3,r5
   28b64:	1908d83a 	srl	r4,r3,r4
   28b68:	2806c03a 	cmpne	r3,r5,zero
   28b6c:	20c6b03a 	or	r3,r4,r3
   28b70:	19c7883a 	add	r3,r3,r7
   28b74:	3021883a 	mov	r16,r6
   28b78:	003f7c06 	br	2896c <__reset+0xfff8896c>
   28b7c:	1800111e 	bne	r3,zero,28bc4 <__subsf3+0x424>
   28b80:	38003326 	beq	r7,zero,28c50 <__subsf3+0x4b0>
   28b84:	3807883a 	mov	r3,r7
   28b88:	1023883a 	mov	r17,r2
   28b8c:	04003fc4 	movi	r16,255
   28b90:	003f1c06 	br	28804 <__reset+0xfff88804>
   28b94:	01403fc4 	movi	r5,255
   28b98:	31401626 	beq	r6,r5,28bf4 <__subsf3+0x454>
   28b9c:	0109c83a 	sub	r4,zero,r4
   28ba0:	18c10034 	orhi	r3,r3,1024
   28ba4:	003fea06 	br	28b50 <__reset+0xfff88b50>
   28ba8:	383f1626 	beq	r7,zero,28804 <__reset+0xfff88804>
   28bac:	19c9c83a 	sub	r4,r3,r7
   28bb0:	2141002c 	andhi	r5,r4,1024
   28bb4:	283f5026 	beq	r5,zero,288f8 <__reset+0xfff888f8>
   28bb8:	38c7c83a 	sub	r3,r7,r3
   28bbc:	1023883a 	mov	r17,r2
   28bc0:	003f1006 	br	28804 <__reset+0xfff88804>
   28bc4:	38001b26 	beq	r7,zero,28c34 <__subsf3+0x494>
   28bc8:	1806d0fa 	srli	r3,r3,3
   28bcc:	1900102c 	andhi	r4,r3,64
   28bd0:	20000526 	beq	r4,zero,28be8 <__subsf3+0x448>
   28bd4:	380ed0fa 	srli	r7,r7,3
   28bd8:	3900102c 	andhi	r4,r7,64
   28bdc:	2000021e 	bne	r4,zero,28be8 <__subsf3+0x448>
   28be0:	3807883a 	mov	r3,r7
   28be4:	1023883a 	mov	r17,r2
   28be8:	180690fa 	slli	r3,r3,3
   28bec:	04003fc4 	movi	r16,255
   28bf0:	003f0406 	br	28804 <__reset+0xfff88804>
   28bf4:	3807883a 	mov	r3,r7
   28bf8:	3021883a 	mov	r16,r6
   28bfc:	003f0106 	br	28804 <__reset+0xfff88804>
   28c00:	18001726 	beq	r3,zero,28c60 <__subsf3+0x4c0>
   28c04:	38000b26 	beq	r7,zero,28c34 <__subsf3+0x494>
   28c08:	1806d0fa 	srli	r3,r3,3
   28c0c:	1900102c 	andhi	r4,r3,64
   28c10:	20000426 	beq	r4,zero,28c24 <__subsf3+0x484>
   28c14:	380ed0fa 	srli	r7,r7,3
   28c18:	3900102c 	andhi	r4,r7,64
   28c1c:	2000011e 	bne	r4,zero,28c24 <__subsf3+0x484>
   28c20:	3807883a 	mov	r3,r7
   28c24:	180690fa 	slli	r3,r3,3
   28c28:	1023883a 	mov	r17,r2
   28c2c:	04003fc4 	movi	r16,255
   28c30:	003ef406 	br	28804 <__reset+0xfff88804>
   28c34:	04003fc4 	movi	r16,255
   28c38:	003ef206 	br	28804 <__reset+0xfff88804>
   28c3c:	00c00044 	movi	r3,1
   28c40:	003f9606 	br	28a9c <__reset+0xfff88a9c>
   28c44:	000b883a 	mov	r5,zero
   28c48:	0005883a 	mov	r2,zero
   28c4c:	003f3506 	br	28924 <__reset+0xfff88924>
   28c50:	01402034 	movhi	r5,128
   28c54:	297fffc4 	addi	r5,r5,-1
   28c58:	0005883a 	mov	r2,zero
   28c5c:	003f2f06 	br	2891c <__reset+0xfff8891c>
   28c60:	3807883a 	mov	r3,r7
   28c64:	04003fc4 	movi	r16,255
   28c68:	003ee606 	br	28804 <__reset+0xfff88804>
   28c6c:	3807883a 	mov	r3,r7
   28c70:	003ee406 	br	28804 <__reset+0xfff88804>
   28c74:	00c00044 	movi	r3,1
   28c78:	003fbd06 	br	28b70 <__reset+0xfff88b70>
   28c7c:	0005883a 	mov	r2,zero
   28c80:	003f2806 	br	28924 <__reset+0xfff88924>

00028c84 <__fixsfsi>:
   28c84:	200ad5fa 	srli	r5,r4,23
   28c88:	00c02034 	movhi	r3,128
   28c8c:	18ffffc4 	addi	r3,r3,-1
   28c90:	29403fcc 	andi	r5,r5,255
   28c94:	00801f84 	movi	r2,126
   28c98:	1906703a 	and	r3,r3,r4
   28c9c:	2008d7fa 	srli	r4,r4,31
   28ca0:	11400e0e 	bge	r2,r5,28cdc <__fixsfsi+0x58>
   28ca4:	00802744 	movi	r2,157
   28ca8:	11400816 	blt	r2,r5,28ccc <__fixsfsi+0x48>
   28cac:	00802544 	movi	r2,149
   28cb0:	18c02034 	orhi	r3,r3,128
   28cb4:	11400b0e 	bge	r2,r5,28ce4 <__fixsfsi+0x60>
   28cb8:	28bfda84 	addi	r2,r5,-150
   28cbc:	1884983a 	sll	r2,r3,r2
   28cc0:	20000726 	beq	r4,zero,28ce0 <__fixsfsi+0x5c>
   28cc4:	0085c83a 	sub	r2,zero,r2
   28cc8:	f800283a 	ret
   28ccc:	00a00034 	movhi	r2,32768
   28cd0:	10bfffc4 	addi	r2,r2,-1
   28cd4:	2085883a 	add	r2,r4,r2
   28cd8:	f800283a 	ret
   28cdc:	0005883a 	mov	r2,zero
   28ce0:	f800283a 	ret
   28ce4:	00802584 	movi	r2,150
   28ce8:	1145c83a 	sub	r2,r2,r5
   28cec:	1884d83a 	srl	r2,r3,r2
   28cf0:	003ff306 	br	28cc0 <__reset+0xfff88cc0>

00028cf4 <__floatsisf>:
   28cf4:	defffd04 	addi	sp,sp,-12
   28cf8:	dfc00215 	stw	ra,8(sp)
   28cfc:	dc400115 	stw	r17,4(sp)
   28d00:	dc000015 	stw	r16,0(sp)
   28d04:	20003526 	beq	r4,zero,28ddc <__floatsisf+0xe8>
   28d08:	2021883a 	mov	r16,r4
   28d0c:	2022d7fa 	srli	r17,r4,31
   28d10:	20003616 	blt	r4,zero,28dec <__floatsisf+0xf8>
   28d14:	8009883a 	mov	r4,r16
   28d18:	002b6480 	call	2b648 <__clzsi2>
   28d1c:	00c02784 	movi	r3,158
   28d20:	1887c83a 	sub	r3,r3,r2
   28d24:	01002584 	movi	r4,150
   28d28:	20c01416 	blt	r4,r3,28d7c <__floatsisf+0x88>
   28d2c:	20c9c83a 	sub	r4,r4,r3
   28d30:	8120983a 	sll	r16,r16,r4
   28d34:	00802034 	movhi	r2,128
   28d38:	10bfffc4 	addi	r2,r2,-1
   28d3c:	8809883a 	mov	r4,r17
   28d40:	80a0703a 	and	r16,r16,r2
   28d44:	18803fcc 	andi	r2,r3,255
   28d48:	100695fa 	slli	r3,r2,23
   28d4c:	20803fcc 	andi	r2,r4,255
   28d50:	100897fa 	slli	r4,r2,31
   28d54:	00802034 	movhi	r2,128
   28d58:	10bfffc4 	addi	r2,r2,-1
   28d5c:	8084703a 	and	r2,r16,r2
   28d60:	10c4b03a 	or	r2,r2,r3
   28d64:	1104b03a 	or	r2,r2,r4
   28d68:	dfc00217 	ldw	ra,8(sp)
   28d6c:	dc400117 	ldw	r17,4(sp)
   28d70:	dc000017 	ldw	r16,0(sp)
   28d74:	dec00304 	addi	sp,sp,12
   28d78:	f800283a 	ret
   28d7c:	01002644 	movi	r4,153
   28d80:	20c01c16 	blt	r4,r3,28df4 <__floatsisf+0x100>
   28d84:	20c9c83a 	sub	r4,r4,r3
   28d88:	8120983a 	sll	r16,r16,r4
   28d8c:	013f0034 	movhi	r4,64512
   28d90:	213fffc4 	addi	r4,r4,-1
   28d94:	814001cc 	andi	r5,r16,7
   28d98:	8108703a 	and	r4,r16,r4
   28d9c:	28000426 	beq	r5,zero,28db0 <__floatsisf+0xbc>
   28da0:	840003cc 	andi	r16,r16,15
   28da4:	01400104 	movi	r5,4
   28da8:	81400126 	beq	r16,r5,28db0 <__floatsisf+0xbc>
   28dac:	2149883a 	add	r4,r4,r5
   28db0:	2141002c 	andhi	r5,r4,1024
   28db4:	28000526 	beq	r5,zero,28dcc <__floatsisf+0xd8>
   28db8:	00c027c4 	movi	r3,159
   28dbc:	1887c83a 	sub	r3,r3,r2
   28dc0:	00bf0034 	movhi	r2,64512
   28dc4:	10bfffc4 	addi	r2,r2,-1
   28dc8:	2088703a 	and	r4,r4,r2
   28dcc:	202091ba 	slli	r16,r4,6
   28dd0:	8809883a 	mov	r4,r17
   28dd4:	8020d27a 	srli	r16,r16,9
   28dd8:	003fda06 	br	28d44 <__reset+0xfff88d44>
   28ddc:	0009883a 	mov	r4,zero
   28de0:	0007883a 	mov	r3,zero
   28de4:	0021883a 	mov	r16,zero
   28de8:	003fd606 	br	28d44 <__reset+0xfff88d44>
   28dec:	0121c83a 	sub	r16,zero,r4
   28df0:	003fc806 	br	28d14 <__reset+0xfff88d14>
   28df4:	01002e44 	movi	r4,185
   28df8:	20c9c83a 	sub	r4,r4,r3
   28dfc:	01400144 	movi	r5,5
   28e00:	8108983a 	sll	r4,r16,r4
   28e04:	288bc83a 	sub	r5,r5,r2
   28e08:	8160d83a 	srl	r16,r16,r5
   28e0c:	2008c03a 	cmpne	r4,r4,zero
   28e10:	8120b03a 	or	r16,r16,r4
   28e14:	003fdd06 	br	28d8c <__reset+0xfff88d8c>

00028e18 <__floatunsisf>:
   28e18:	defffe04 	addi	sp,sp,-8
   28e1c:	dfc00115 	stw	ra,4(sp)
   28e20:	dc000015 	stw	r16,0(sp)
   28e24:	20002c26 	beq	r4,zero,28ed8 <__floatunsisf+0xc0>
   28e28:	2021883a 	mov	r16,r4
   28e2c:	002b6480 	call	2b648 <__clzsi2>
   28e30:	00c02784 	movi	r3,158
   28e34:	1887c83a 	sub	r3,r3,r2
   28e38:	01002584 	movi	r4,150
   28e3c:	20c00f16 	blt	r4,r3,28e7c <__floatunsisf+0x64>
   28e40:	20c9c83a 	sub	r4,r4,r3
   28e44:	8108983a 	sll	r4,r16,r4
   28e48:	00802034 	movhi	r2,128
   28e4c:	10bfffc4 	addi	r2,r2,-1
   28e50:	2088703a 	and	r4,r4,r2
   28e54:	18803fcc 	andi	r2,r3,255
   28e58:	100695fa 	slli	r3,r2,23
   28e5c:	00802034 	movhi	r2,128
   28e60:	10bfffc4 	addi	r2,r2,-1
   28e64:	2084703a 	and	r2,r4,r2
   28e68:	10c4b03a 	or	r2,r2,r3
   28e6c:	dfc00117 	ldw	ra,4(sp)
   28e70:	dc000017 	ldw	r16,0(sp)
   28e74:	dec00204 	addi	sp,sp,8
   28e78:	f800283a 	ret
   28e7c:	01002644 	movi	r4,153
   28e80:	20c01816 	blt	r4,r3,28ee4 <__floatunsisf+0xcc>
   28e84:	20c9c83a 	sub	r4,r4,r3
   28e88:	8108983a 	sll	r4,r16,r4
   28e8c:	017f0034 	movhi	r5,64512
   28e90:	297fffc4 	addi	r5,r5,-1
   28e94:	218001cc 	andi	r6,r4,7
   28e98:	214a703a 	and	r5,r4,r5
   28e9c:	30000426 	beq	r6,zero,28eb0 <__floatunsisf+0x98>
   28ea0:	210003cc 	andi	r4,r4,15
   28ea4:	01800104 	movi	r6,4
   28ea8:	21800126 	beq	r4,r6,28eb0 <__floatunsisf+0x98>
   28eac:	298b883a 	add	r5,r5,r6
   28eb0:	2901002c 	andhi	r4,r5,1024
   28eb4:	20000526 	beq	r4,zero,28ecc <__floatunsisf+0xb4>
   28eb8:	00c027c4 	movi	r3,159
   28ebc:	1887c83a 	sub	r3,r3,r2
   28ec0:	00bf0034 	movhi	r2,64512
   28ec4:	10bfffc4 	addi	r2,r2,-1
   28ec8:	288a703a 	and	r5,r5,r2
   28ecc:	280891ba 	slli	r4,r5,6
   28ed0:	2008d27a 	srli	r4,r4,9
   28ed4:	003fdf06 	br	28e54 <__reset+0xfff88e54>
   28ed8:	0007883a 	mov	r3,zero
   28edc:	0009883a 	mov	r4,zero
   28ee0:	003fdc06 	br	28e54 <__reset+0xfff88e54>
   28ee4:	01402e44 	movi	r5,185
   28ee8:	28cbc83a 	sub	r5,r5,r3
   28eec:	01000144 	movi	r4,5
   28ef0:	2089c83a 	sub	r4,r4,r2
   28ef4:	814a983a 	sll	r5,r16,r5
   28ef8:	8108d83a 	srl	r4,r16,r4
   28efc:	2820c03a 	cmpne	r16,r5,zero
   28f00:	2408b03a 	or	r4,r4,r16
   28f04:	003fe106 	br	28e8c <__reset+0xfff88e8c>

00028f08 <__adddf3>:
   28f08:	02c00434 	movhi	r11,16
   28f0c:	5affffc4 	addi	r11,r11,-1
   28f10:	2806d7fa 	srli	r3,r5,31
   28f14:	2ad4703a 	and	r10,r5,r11
   28f18:	3ad2703a 	and	r9,r7,r11
   28f1c:	3804d53a 	srli	r2,r7,20
   28f20:	3018d77a 	srli	r12,r6,29
   28f24:	280ad53a 	srli	r5,r5,20
   28f28:	501490fa 	slli	r10,r10,3
   28f2c:	2010d77a 	srli	r8,r4,29
   28f30:	481290fa 	slli	r9,r9,3
   28f34:	380ed7fa 	srli	r7,r7,31
   28f38:	defffb04 	addi	sp,sp,-20
   28f3c:	dc800215 	stw	r18,8(sp)
   28f40:	dc400115 	stw	r17,4(sp)
   28f44:	dc000015 	stw	r16,0(sp)
   28f48:	dfc00415 	stw	ra,16(sp)
   28f4c:	dcc00315 	stw	r19,12(sp)
   28f50:	1c803fcc 	andi	r18,r3,255
   28f54:	2c01ffcc 	andi	r16,r5,2047
   28f58:	5210b03a 	or	r8,r10,r8
   28f5c:	202290fa 	slli	r17,r4,3
   28f60:	1081ffcc 	andi	r2,r2,2047
   28f64:	4b12b03a 	or	r9,r9,r12
   28f68:	300c90fa 	slli	r6,r6,3
   28f6c:	91c07526 	beq	r18,r7,29144 <__adddf3+0x23c>
   28f70:	8087c83a 	sub	r3,r16,r2
   28f74:	00c0ab0e 	bge	zero,r3,29224 <__adddf3+0x31c>
   28f78:	10002a1e 	bne	r2,zero,29024 <__adddf3+0x11c>
   28f7c:	4984b03a 	or	r2,r9,r6
   28f80:	1000961e 	bne	r2,zero,291dc <__adddf3+0x2d4>
   28f84:	888001cc 	andi	r2,r17,7
   28f88:	10000726 	beq	r2,zero,28fa8 <__adddf3+0xa0>
   28f8c:	888003cc 	andi	r2,r17,15
   28f90:	00c00104 	movi	r3,4
   28f94:	10c00426 	beq	r2,r3,28fa8 <__adddf3+0xa0>
   28f98:	88c7883a 	add	r3,r17,r3
   28f9c:	1c63803a 	cmpltu	r17,r3,r17
   28fa0:	4451883a 	add	r8,r8,r17
   28fa4:	1823883a 	mov	r17,r3
   28fa8:	4080202c 	andhi	r2,r8,128
   28fac:	10005926 	beq	r2,zero,29114 <__adddf3+0x20c>
   28fb0:	84000044 	addi	r16,r16,1
   28fb4:	0081ffc4 	movi	r2,2047
   28fb8:	8080ba26 	beq	r16,r2,292a4 <__adddf3+0x39c>
   28fbc:	00bfe034 	movhi	r2,65408
   28fc0:	10bfffc4 	addi	r2,r2,-1
   28fc4:	4090703a 	and	r8,r8,r2
   28fc8:	4004977a 	slli	r2,r8,29
   28fcc:	4010927a 	slli	r8,r8,9
   28fd0:	8822d0fa 	srli	r17,r17,3
   28fd4:	8401ffcc 	andi	r16,r16,2047
   28fd8:	4010d33a 	srli	r8,r8,12
   28fdc:	9007883a 	mov	r3,r18
   28fe0:	1444b03a 	or	r2,r2,r17
   28fe4:	8401ffcc 	andi	r16,r16,2047
   28fe8:	8020953a 	slli	r16,r16,20
   28fec:	18c03fcc 	andi	r3,r3,255
   28ff0:	01000434 	movhi	r4,16
   28ff4:	213fffc4 	addi	r4,r4,-1
   28ff8:	180697fa 	slli	r3,r3,31
   28ffc:	4110703a 	and	r8,r8,r4
   29000:	4410b03a 	or	r8,r8,r16
   29004:	40c6b03a 	or	r3,r8,r3
   29008:	dfc00417 	ldw	ra,16(sp)
   2900c:	dcc00317 	ldw	r19,12(sp)
   29010:	dc800217 	ldw	r18,8(sp)
   29014:	dc400117 	ldw	r17,4(sp)
   29018:	dc000017 	ldw	r16,0(sp)
   2901c:	dec00504 	addi	sp,sp,20
   29020:	f800283a 	ret
   29024:	0081ffc4 	movi	r2,2047
   29028:	80bfd626 	beq	r16,r2,28f84 <__reset+0xfff88f84>
   2902c:	4a402034 	orhi	r9,r9,128
   29030:	00800e04 	movi	r2,56
   29034:	10c09f16 	blt	r2,r3,292b4 <__adddf3+0x3ac>
   29038:	008007c4 	movi	r2,31
   2903c:	10c0c216 	blt	r2,r3,29348 <__adddf3+0x440>
   29040:	00800804 	movi	r2,32
   29044:	10c5c83a 	sub	r2,r2,r3
   29048:	488a983a 	sll	r5,r9,r2
   2904c:	30c8d83a 	srl	r4,r6,r3
   29050:	3084983a 	sll	r2,r6,r2
   29054:	48c6d83a 	srl	r3,r9,r3
   29058:	290cb03a 	or	r6,r5,r4
   2905c:	1004c03a 	cmpne	r2,r2,zero
   29060:	308cb03a 	or	r6,r6,r2
   29064:	898dc83a 	sub	r6,r17,r6
   29068:	89a3803a 	cmpltu	r17,r17,r6
   2906c:	40d1c83a 	sub	r8,r8,r3
   29070:	4451c83a 	sub	r8,r8,r17
   29074:	3023883a 	mov	r17,r6
   29078:	4080202c 	andhi	r2,r8,128
   2907c:	10002326 	beq	r2,zero,2910c <__adddf3+0x204>
   29080:	04c02034 	movhi	r19,128
   29084:	9cffffc4 	addi	r19,r19,-1
   29088:	44e6703a 	and	r19,r8,r19
   2908c:	98007626 	beq	r19,zero,29268 <__adddf3+0x360>
   29090:	9809883a 	mov	r4,r19
   29094:	002b6480 	call	2b648 <__clzsi2>
   29098:	10fffe04 	addi	r3,r2,-8
   2909c:	010007c4 	movi	r4,31
   290a0:	20c07716 	blt	r4,r3,29280 <__adddf3+0x378>
   290a4:	00800804 	movi	r2,32
   290a8:	10c5c83a 	sub	r2,r2,r3
   290ac:	8884d83a 	srl	r2,r17,r2
   290b0:	98d0983a 	sll	r8,r19,r3
   290b4:	88e2983a 	sll	r17,r17,r3
   290b8:	1204b03a 	or	r2,r2,r8
   290bc:	1c007416 	blt	r3,r16,29290 <__adddf3+0x388>
   290c0:	1c21c83a 	sub	r16,r3,r16
   290c4:	82000044 	addi	r8,r16,1
   290c8:	00c007c4 	movi	r3,31
   290cc:	1a009116 	blt	r3,r8,29314 <__adddf3+0x40c>
   290d0:	00c00804 	movi	r3,32
   290d4:	1a07c83a 	sub	r3,r3,r8
   290d8:	8a08d83a 	srl	r4,r17,r8
   290dc:	88e2983a 	sll	r17,r17,r3
   290e0:	10c6983a 	sll	r3,r2,r3
   290e4:	1210d83a 	srl	r8,r2,r8
   290e8:	8804c03a 	cmpne	r2,r17,zero
   290ec:	1906b03a 	or	r3,r3,r4
   290f0:	18a2b03a 	or	r17,r3,r2
   290f4:	0021883a 	mov	r16,zero
   290f8:	003fa206 	br	28f84 <__reset+0xfff88f84>
   290fc:	1890b03a 	or	r8,r3,r2
   29100:	40017d26 	beq	r8,zero,296f8 <__adddf3+0x7f0>
   29104:	1011883a 	mov	r8,r2
   29108:	1823883a 	mov	r17,r3
   2910c:	888001cc 	andi	r2,r17,7
   29110:	103f9e1e 	bne	r2,zero,28f8c <__reset+0xfff88f8c>
   29114:	4004977a 	slli	r2,r8,29
   29118:	8822d0fa 	srli	r17,r17,3
   2911c:	4010d0fa 	srli	r8,r8,3
   29120:	9007883a 	mov	r3,r18
   29124:	1444b03a 	or	r2,r2,r17
   29128:	0101ffc4 	movi	r4,2047
   2912c:	81002426 	beq	r16,r4,291c0 <__adddf3+0x2b8>
   29130:	8120703a 	and	r16,r16,r4
   29134:	01000434 	movhi	r4,16
   29138:	213fffc4 	addi	r4,r4,-1
   2913c:	4110703a 	and	r8,r8,r4
   29140:	003fa806 	br	28fe4 <__reset+0xfff88fe4>
   29144:	8089c83a 	sub	r4,r16,r2
   29148:	01005e0e 	bge	zero,r4,292c4 <__adddf3+0x3bc>
   2914c:	10002b26 	beq	r2,zero,291fc <__adddf3+0x2f4>
   29150:	0081ffc4 	movi	r2,2047
   29154:	80bf8b26 	beq	r16,r2,28f84 <__reset+0xfff88f84>
   29158:	4a402034 	orhi	r9,r9,128
   2915c:	00800e04 	movi	r2,56
   29160:	1100a40e 	bge	r2,r4,293f4 <__adddf3+0x4ec>
   29164:	498cb03a 	or	r6,r9,r6
   29168:	300ac03a 	cmpne	r5,r6,zero
   2916c:	0013883a 	mov	r9,zero
   29170:	2c4b883a 	add	r5,r5,r17
   29174:	2c63803a 	cmpltu	r17,r5,r17
   29178:	4a11883a 	add	r8,r9,r8
   2917c:	8a11883a 	add	r8,r17,r8
   29180:	2823883a 	mov	r17,r5
   29184:	4080202c 	andhi	r2,r8,128
   29188:	103fe026 	beq	r2,zero,2910c <__reset+0xfff8910c>
   2918c:	84000044 	addi	r16,r16,1
   29190:	0081ffc4 	movi	r2,2047
   29194:	8080d226 	beq	r16,r2,294e0 <__adddf3+0x5d8>
   29198:	00bfe034 	movhi	r2,65408
   2919c:	10bfffc4 	addi	r2,r2,-1
   291a0:	4090703a 	and	r8,r8,r2
   291a4:	880ad07a 	srli	r5,r17,1
   291a8:	400897fa 	slli	r4,r8,31
   291ac:	88c0004c 	andi	r3,r17,1
   291b0:	28e2b03a 	or	r17,r5,r3
   291b4:	4010d07a 	srli	r8,r8,1
   291b8:	2462b03a 	or	r17,r4,r17
   291bc:	003f7106 	br	28f84 <__reset+0xfff88f84>
   291c0:	4088b03a 	or	r4,r8,r2
   291c4:	20014526 	beq	r4,zero,296dc <__adddf3+0x7d4>
   291c8:	01000434 	movhi	r4,16
   291cc:	42000234 	orhi	r8,r8,8
   291d0:	213fffc4 	addi	r4,r4,-1
   291d4:	4110703a 	and	r8,r8,r4
   291d8:	003f8206 	br	28fe4 <__reset+0xfff88fe4>
   291dc:	18ffffc4 	addi	r3,r3,-1
   291e0:	1800491e 	bne	r3,zero,29308 <__adddf3+0x400>
   291e4:	898bc83a 	sub	r5,r17,r6
   291e8:	8963803a 	cmpltu	r17,r17,r5
   291ec:	4251c83a 	sub	r8,r8,r9
   291f0:	4451c83a 	sub	r8,r8,r17
   291f4:	2823883a 	mov	r17,r5
   291f8:	003f9f06 	br	29078 <__reset+0xfff89078>
   291fc:	4984b03a 	or	r2,r9,r6
   29200:	103f6026 	beq	r2,zero,28f84 <__reset+0xfff88f84>
   29204:	213fffc4 	addi	r4,r4,-1
   29208:	2000931e 	bne	r4,zero,29458 <__adddf3+0x550>
   2920c:	898d883a 	add	r6,r17,r6
   29210:	3463803a 	cmpltu	r17,r6,r17
   29214:	4251883a 	add	r8,r8,r9
   29218:	8a11883a 	add	r8,r17,r8
   2921c:	3023883a 	mov	r17,r6
   29220:	003fd806 	br	29184 <__reset+0xfff89184>
   29224:	1800541e 	bne	r3,zero,29378 <__adddf3+0x470>
   29228:	80800044 	addi	r2,r16,1
   2922c:	1081ffcc 	andi	r2,r2,2047
   29230:	00c00044 	movi	r3,1
   29234:	1880a00e 	bge	r3,r2,294b8 <__adddf3+0x5b0>
   29238:	8989c83a 	sub	r4,r17,r6
   2923c:	8905803a 	cmpltu	r2,r17,r4
   29240:	4267c83a 	sub	r19,r8,r9
   29244:	98a7c83a 	sub	r19,r19,r2
   29248:	9880202c 	andhi	r2,r19,128
   2924c:	10006326 	beq	r2,zero,293dc <__adddf3+0x4d4>
   29250:	3463c83a 	sub	r17,r6,r17
   29254:	4a07c83a 	sub	r3,r9,r8
   29258:	344d803a 	cmpltu	r6,r6,r17
   2925c:	19a7c83a 	sub	r19,r3,r6
   29260:	3825883a 	mov	r18,r7
   29264:	983f8a1e 	bne	r19,zero,29090 <__reset+0xfff89090>
   29268:	8809883a 	mov	r4,r17
   2926c:	002b6480 	call	2b648 <__clzsi2>
   29270:	10800804 	addi	r2,r2,32
   29274:	10fffe04 	addi	r3,r2,-8
   29278:	010007c4 	movi	r4,31
   2927c:	20ff890e 	bge	r4,r3,290a4 <__reset+0xfff890a4>
   29280:	10bff604 	addi	r2,r2,-40
   29284:	8884983a 	sll	r2,r17,r2
   29288:	0023883a 	mov	r17,zero
   2928c:	1c3f8c0e 	bge	r3,r16,290c0 <__reset+0xfff890c0>
   29290:	023fe034 	movhi	r8,65408
   29294:	423fffc4 	addi	r8,r8,-1
   29298:	80e1c83a 	sub	r16,r16,r3
   2929c:	1210703a 	and	r8,r2,r8
   292a0:	003f3806 	br	28f84 <__reset+0xfff88f84>
   292a4:	9007883a 	mov	r3,r18
   292a8:	0011883a 	mov	r8,zero
   292ac:	0005883a 	mov	r2,zero
   292b0:	003f4c06 	br	28fe4 <__reset+0xfff88fe4>
   292b4:	498cb03a 	or	r6,r9,r6
   292b8:	300cc03a 	cmpne	r6,r6,zero
   292bc:	0007883a 	mov	r3,zero
   292c0:	003f6806 	br	29064 <__reset+0xfff89064>
   292c4:	20009c1e 	bne	r4,zero,29538 <__adddf3+0x630>
   292c8:	80800044 	addi	r2,r16,1
   292cc:	1141ffcc 	andi	r5,r2,2047
   292d0:	01000044 	movi	r4,1
   292d4:	2140670e 	bge	r4,r5,29474 <__adddf3+0x56c>
   292d8:	0101ffc4 	movi	r4,2047
   292dc:	11007f26 	beq	r2,r4,294dc <__adddf3+0x5d4>
   292e0:	898d883a 	add	r6,r17,r6
   292e4:	4247883a 	add	r3,r8,r9
   292e8:	3451803a 	cmpltu	r8,r6,r17
   292ec:	40d1883a 	add	r8,r8,r3
   292f0:	402297fa 	slli	r17,r8,31
   292f4:	300cd07a 	srli	r6,r6,1
   292f8:	4010d07a 	srli	r8,r8,1
   292fc:	1021883a 	mov	r16,r2
   29300:	89a2b03a 	or	r17,r17,r6
   29304:	003f1f06 	br	28f84 <__reset+0xfff88f84>
   29308:	0081ffc4 	movi	r2,2047
   2930c:	80bf481e 	bne	r16,r2,29030 <__reset+0xfff89030>
   29310:	003f1c06 	br	28f84 <__reset+0xfff88f84>
   29314:	843ff844 	addi	r16,r16,-31
   29318:	01000804 	movi	r4,32
   2931c:	1406d83a 	srl	r3,r2,r16
   29320:	41005026 	beq	r8,r4,29464 <__adddf3+0x55c>
   29324:	01001004 	movi	r4,64
   29328:	2211c83a 	sub	r8,r4,r8
   2932c:	1204983a 	sll	r2,r2,r8
   29330:	88a2b03a 	or	r17,r17,r2
   29334:	8822c03a 	cmpne	r17,r17,zero
   29338:	1c62b03a 	or	r17,r3,r17
   2933c:	0011883a 	mov	r8,zero
   29340:	0021883a 	mov	r16,zero
   29344:	003f7106 	br	2910c <__reset+0xfff8910c>
   29348:	193ff804 	addi	r4,r3,-32
   2934c:	00800804 	movi	r2,32
   29350:	4908d83a 	srl	r4,r9,r4
   29354:	18804526 	beq	r3,r2,2946c <__adddf3+0x564>
   29358:	00801004 	movi	r2,64
   2935c:	10c5c83a 	sub	r2,r2,r3
   29360:	4886983a 	sll	r3,r9,r2
   29364:	198cb03a 	or	r6,r3,r6
   29368:	300cc03a 	cmpne	r6,r6,zero
   2936c:	218cb03a 	or	r6,r4,r6
   29370:	0007883a 	mov	r3,zero
   29374:	003f3b06 	br	29064 <__reset+0xfff89064>
   29378:	80002a26 	beq	r16,zero,29424 <__adddf3+0x51c>
   2937c:	0101ffc4 	movi	r4,2047
   29380:	11006826 	beq	r2,r4,29524 <__adddf3+0x61c>
   29384:	00c7c83a 	sub	r3,zero,r3
   29388:	42002034 	orhi	r8,r8,128
   2938c:	01000e04 	movi	r4,56
   29390:	20c07c16 	blt	r4,r3,29584 <__adddf3+0x67c>
   29394:	010007c4 	movi	r4,31
   29398:	20c0da16 	blt	r4,r3,29704 <__adddf3+0x7fc>
   2939c:	01000804 	movi	r4,32
   293a0:	20c9c83a 	sub	r4,r4,r3
   293a4:	4114983a 	sll	r10,r8,r4
   293a8:	88cad83a 	srl	r5,r17,r3
   293ac:	8908983a 	sll	r4,r17,r4
   293b0:	40c6d83a 	srl	r3,r8,r3
   293b4:	5162b03a 	or	r17,r10,r5
   293b8:	2008c03a 	cmpne	r4,r4,zero
   293bc:	8922b03a 	or	r17,r17,r4
   293c0:	3463c83a 	sub	r17,r6,r17
   293c4:	48c7c83a 	sub	r3,r9,r3
   293c8:	344d803a 	cmpltu	r6,r6,r17
   293cc:	1991c83a 	sub	r8,r3,r6
   293d0:	1021883a 	mov	r16,r2
   293d4:	3825883a 	mov	r18,r7
   293d8:	003f2706 	br	29078 <__reset+0xfff89078>
   293dc:	24d0b03a 	or	r8,r4,r19
   293e0:	40001b1e 	bne	r8,zero,29450 <__adddf3+0x548>
   293e4:	0005883a 	mov	r2,zero
   293e8:	0007883a 	mov	r3,zero
   293ec:	0021883a 	mov	r16,zero
   293f0:	003f4d06 	br	29128 <__reset+0xfff89128>
   293f4:	008007c4 	movi	r2,31
   293f8:	11003c16 	blt	r2,r4,294ec <__adddf3+0x5e4>
   293fc:	00800804 	movi	r2,32
   29400:	1105c83a 	sub	r2,r2,r4
   29404:	488e983a 	sll	r7,r9,r2
   29408:	310ad83a 	srl	r5,r6,r4
   2940c:	3084983a 	sll	r2,r6,r2
   29410:	4912d83a 	srl	r9,r9,r4
   29414:	394ab03a 	or	r5,r7,r5
   29418:	1004c03a 	cmpne	r2,r2,zero
   2941c:	288ab03a 	or	r5,r5,r2
   29420:	003f5306 	br	29170 <__reset+0xfff89170>
   29424:	4448b03a 	or	r4,r8,r17
   29428:	20003e26 	beq	r4,zero,29524 <__adddf3+0x61c>
   2942c:	00c6303a 	nor	r3,zero,r3
   29430:	18003a1e 	bne	r3,zero,2951c <__adddf3+0x614>
   29434:	3463c83a 	sub	r17,r6,r17
   29438:	4a07c83a 	sub	r3,r9,r8
   2943c:	344d803a 	cmpltu	r6,r6,r17
   29440:	1991c83a 	sub	r8,r3,r6
   29444:	1021883a 	mov	r16,r2
   29448:	3825883a 	mov	r18,r7
   2944c:	003f0a06 	br	29078 <__reset+0xfff89078>
   29450:	2023883a 	mov	r17,r4
   29454:	003f0d06 	br	2908c <__reset+0xfff8908c>
   29458:	0081ffc4 	movi	r2,2047
   2945c:	80bf3f1e 	bne	r16,r2,2915c <__reset+0xfff8915c>
   29460:	003ec806 	br	28f84 <__reset+0xfff88f84>
   29464:	0005883a 	mov	r2,zero
   29468:	003fb106 	br	29330 <__reset+0xfff89330>
   2946c:	0007883a 	mov	r3,zero
   29470:	003fbc06 	br	29364 <__reset+0xfff89364>
   29474:	4444b03a 	or	r2,r8,r17
   29478:	8000871e 	bne	r16,zero,29698 <__adddf3+0x790>
   2947c:	1000ba26 	beq	r2,zero,29768 <__adddf3+0x860>
   29480:	4984b03a 	or	r2,r9,r6
   29484:	103ebf26 	beq	r2,zero,28f84 <__reset+0xfff88f84>
   29488:	8985883a 	add	r2,r17,r6
   2948c:	4247883a 	add	r3,r8,r9
   29490:	1451803a 	cmpltu	r8,r2,r17
   29494:	40d1883a 	add	r8,r8,r3
   29498:	40c0202c 	andhi	r3,r8,128
   2949c:	1023883a 	mov	r17,r2
   294a0:	183f1a26 	beq	r3,zero,2910c <__reset+0xfff8910c>
   294a4:	00bfe034 	movhi	r2,65408
   294a8:	10bfffc4 	addi	r2,r2,-1
   294ac:	2021883a 	mov	r16,r4
   294b0:	4090703a 	and	r8,r8,r2
   294b4:	003eb306 	br	28f84 <__reset+0xfff88f84>
   294b8:	4444b03a 	or	r2,r8,r17
   294bc:	8000291e 	bne	r16,zero,29564 <__adddf3+0x65c>
   294c0:	10004b1e 	bne	r2,zero,295f0 <__adddf3+0x6e8>
   294c4:	4990b03a 	or	r8,r9,r6
   294c8:	40008b26 	beq	r8,zero,296f8 <__adddf3+0x7f0>
   294cc:	4811883a 	mov	r8,r9
   294d0:	3023883a 	mov	r17,r6
   294d4:	3825883a 	mov	r18,r7
   294d8:	003eaa06 	br	28f84 <__reset+0xfff88f84>
   294dc:	1021883a 	mov	r16,r2
   294e0:	0011883a 	mov	r8,zero
   294e4:	0005883a 	mov	r2,zero
   294e8:	003f0f06 	br	29128 <__reset+0xfff89128>
   294ec:	217ff804 	addi	r5,r4,-32
   294f0:	00800804 	movi	r2,32
   294f4:	494ad83a 	srl	r5,r9,r5
   294f8:	20807d26 	beq	r4,r2,296f0 <__adddf3+0x7e8>
   294fc:	00801004 	movi	r2,64
   29500:	1109c83a 	sub	r4,r2,r4
   29504:	4912983a 	sll	r9,r9,r4
   29508:	498cb03a 	or	r6,r9,r6
   2950c:	300cc03a 	cmpne	r6,r6,zero
   29510:	298ab03a 	or	r5,r5,r6
   29514:	0013883a 	mov	r9,zero
   29518:	003f1506 	br	29170 <__reset+0xfff89170>
   2951c:	0101ffc4 	movi	r4,2047
   29520:	113f9a1e 	bne	r2,r4,2938c <__reset+0xfff8938c>
   29524:	4811883a 	mov	r8,r9
   29528:	3023883a 	mov	r17,r6
   2952c:	1021883a 	mov	r16,r2
   29530:	3825883a 	mov	r18,r7
   29534:	003e9306 	br	28f84 <__reset+0xfff88f84>
   29538:	8000161e 	bne	r16,zero,29594 <__adddf3+0x68c>
   2953c:	444ab03a 	or	r5,r8,r17
   29540:	28005126 	beq	r5,zero,29688 <__adddf3+0x780>
   29544:	0108303a 	nor	r4,zero,r4
   29548:	20004d1e 	bne	r4,zero,29680 <__adddf3+0x778>
   2954c:	89a3883a 	add	r17,r17,r6
   29550:	4253883a 	add	r9,r8,r9
   29554:	898d803a 	cmpltu	r6,r17,r6
   29558:	3251883a 	add	r8,r6,r9
   2955c:	1021883a 	mov	r16,r2
   29560:	003f0806 	br	29184 <__reset+0xfff89184>
   29564:	1000301e 	bne	r2,zero,29628 <__adddf3+0x720>
   29568:	4984b03a 	or	r2,r9,r6
   2956c:	10007126 	beq	r2,zero,29734 <__adddf3+0x82c>
   29570:	4811883a 	mov	r8,r9
   29574:	3023883a 	mov	r17,r6
   29578:	3825883a 	mov	r18,r7
   2957c:	0401ffc4 	movi	r16,2047
   29580:	003e8006 	br	28f84 <__reset+0xfff88f84>
   29584:	4462b03a 	or	r17,r8,r17
   29588:	8822c03a 	cmpne	r17,r17,zero
   2958c:	0007883a 	mov	r3,zero
   29590:	003f8b06 	br	293c0 <__reset+0xfff893c0>
   29594:	0141ffc4 	movi	r5,2047
   29598:	11403b26 	beq	r2,r5,29688 <__adddf3+0x780>
   2959c:	0109c83a 	sub	r4,zero,r4
   295a0:	42002034 	orhi	r8,r8,128
   295a4:	01400e04 	movi	r5,56
   295a8:	29006716 	blt	r5,r4,29748 <__adddf3+0x840>
   295ac:	014007c4 	movi	r5,31
   295b0:	29007016 	blt	r5,r4,29774 <__adddf3+0x86c>
   295b4:	01400804 	movi	r5,32
   295b8:	290bc83a 	sub	r5,r5,r4
   295bc:	4154983a 	sll	r10,r8,r5
   295c0:	890ed83a 	srl	r7,r17,r4
   295c4:	894a983a 	sll	r5,r17,r5
   295c8:	4108d83a 	srl	r4,r8,r4
   295cc:	51e2b03a 	or	r17,r10,r7
   295d0:	280ac03a 	cmpne	r5,r5,zero
   295d4:	8962b03a 	or	r17,r17,r5
   295d8:	89a3883a 	add	r17,r17,r6
   295dc:	2253883a 	add	r9,r4,r9
   295e0:	898d803a 	cmpltu	r6,r17,r6
   295e4:	3251883a 	add	r8,r6,r9
   295e8:	1021883a 	mov	r16,r2
   295ec:	003ee506 	br	29184 <__reset+0xfff89184>
   295f0:	4984b03a 	or	r2,r9,r6
   295f4:	103e6326 	beq	r2,zero,28f84 <__reset+0xfff88f84>
   295f8:	8987c83a 	sub	r3,r17,r6
   295fc:	88c9803a 	cmpltu	r4,r17,r3
   29600:	4245c83a 	sub	r2,r8,r9
   29604:	1105c83a 	sub	r2,r2,r4
   29608:	1100202c 	andhi	r4,r2,128
   2960c:	203ebb26 	beq	r4,zero,290fc <__reset+0xfff890fc>
   29610:	3463c83a 	sub	r17,r6,r17
   29614:	4a07c83a 	sub	r3,r9,r8
   29618:	344d803a 	cmpltu	r6,r6,r17
   2961c:	1991c83a 	sub	r8,r3,r6
   29620:	3825883a 	mov	r18,r7
   29624:	003e5706 	br	28f84 <__reset+0xfff88f84>
   29628:	4984b03a 	or	r2,r9,r6
   2962c:	10002e26 	beq	r2,zero,296e8 <__adddf3+0x7e0>
   29630:	4004d0fa 	srli	r2,r8,3
   29634:	8822d0fa 	srli	r17,r17,3
   29638:	4010977a 	slli	r8,r8,29
   2963c:	10c0022c 	andhi	r3,r2,8
   29640:	4462b03a 	or	r17,r8,r17
   29644:	18000826 	beq	r3,zero,29668 <__adddf3+0x760>
   29648:	4808d0fa 	srli	r4,r9,3
   2964c:	20c0022c 	andhi	r3,r4,8
   29650:	1800051e 	bne	r3,zero,29668 <__adddf3+0x760>
   29654:	300cd0fa 	srli	r6,r6,3
   29658:	4806977a 	slli	r3,r9,29
   2965c:	2005883a 	mov	r2,r4
   29660:	3825883a 	mov	r18,r7
   29664:	19a2b03a 	or	r17,r3,r6
   29668:	8810d77a 	srli	r8,r17,29
   2966c:	100490fa 	slli	r2,r2,3
   29670:	882290fa 	slli	r17,r17,3
   29674:	0401ffc4 	movi	r16,2047
   29678:	4090b03a 	or	r8,r8,r2
   2967c:	003e4106 	br	28f84 <__reset+0xfff88f84>
   29680:	0141ffc4 	movi	r5,2047
   29684:	117fc71e 	bne	r2,r5,295a4 <__reset+0xfff895a4>
   29688:	4811883a 	mov	r8,r9
   2968c:	3023883a 	mov	r17,r6
   29690:	1021883a 	mov	r16,r2
   29694:	003e3b06 	br	28f84 <__reset+0xfff88f84>
   29698:	10002f26 	beq	r2,zero,29758 <__adddf3+0x850>
   2969c:	4984b03a 	or	r2,r9,r6
   296a0:	10001126 	beq	r2,zero,296e8 <__adddf3+0x7e0>
   296a4:	4004d0fa 	srli	r2,r8,3
   296a8:	8822d0fa 	srli	r17,r17,3
   296ac:	4010977a 	slli	r8,r8,29
   296b0:	10c0022c 	andhi	r3,r2,8
   296b4:	4462b03a 	or	r17,r8,r17
   296b8:	183feb26 	beq	r3,zero,29668 <__reset+0xfff89668>
   296bc:	4808d0fa 	srli	r4,r9,3
   296c0:	20c0022c 	andhi	r3,r4,8
   296c4:	183fe81e 	bne	r3,zero,29668 <__reset+0xfff89668>
   296c8:	300cd0fa 	srli	r6,r6,3
   296cc:	4806977a 	slli	r3,r9,29
   296d0:	2005883a 	mov	r2,r4
   296d4:	19a2b03a 	or	r17,r3,r6
   296d8:	003fe306 	br	29668 <__reset+0xfff89668>
   296dc:	0011883a 	mov	r8,zero
   296e0:	0005883a 	mov	r2,zero
   296e4:	003e3f06 	br	28fe4 <__reset+0xfff88fe4>
   296e8:	0401ffc4 	movi	r16,2047
   296ec:	003e2506 	br	28f84 <__reset+0xfff88f84>
   296f0:	0013883a 	mov	r9,zero
   296f4:	003f8406 	br	29508 <__reset+0xfff89508>
   296f8:	0005883a 	mov	r2,zero
   296fc:	0007883a 	mov	r3,zero
   29700:	003e8906 	br	29128 <__reset+0xfff89128>
   29704:	197ff804 	addi	r5,r3,-32
   29708:	01000804 	movi	r4,32
   2970c:	414ad83a 	srl	r5,r8,r5
   29710:	19002426 	beq	r3,r4,297a4 <__adddf3+0x89c>
   29714:	01001004 	movi	r4,64
   29718:	20c7c83a 	sub	r3,r4,r3
   2971c:	40c6983a 	sll	r3,r8,r3
   29720:	1c46b03a 	or	r3,r3,r17
   29724:	1806c03a 	cmpne	r3,r3,zero
   29728:	28e2b03a 	or	r17,r5,r3
   2972c:	0007883a 	mov	r3,zero
   29730:	003f2306 	br	293c0 <__reset+0xfff893c0>
   29734:	0007883a 	mov	r3,zero
   29738:	5811883a 	mov	r8,r11
   2973c:	00bfffc4 	movi	r2,-1
   29740:	0401ffc4 	movi	r16,2047
   29744:	003e7806 	br	29128 <__reset+0xfff89128>
   29748:	4462b03a 	or	r17,r8,r17
   2974c:	8822c03a 	cmpne	r17,r17,zero
   29750:	0009883a 	mov	r4,zero
   29754:	003fa006 	br	295d8 <__reset+0xfff895d8>
   29758:	4811883a 	mov	r8,r9
   2975c:	3023883a 	mov	r17,r6
   29760:	0401ffc4 	movi	r16,2047
   29764:	003e0706 	br	28f84 <__reset+0xfff88f84>
   29768:	4811883a 	mov	r8,r9
   2976c:	3023883a 	mov	r17,r6
   29770:	003e0406 	br	28f84 <__reset+0xfff88f84>
   29774:	21fff804 	addi	r7,r4,-32
   29778:	01400804 	movi	r5,32
   2977c:	41ced83a 	srl	r7,r8,r7
   29780:	21400a26 	beq	r4,r5,297ac <__adddf3+0x8a4>
   29784:	01401004 	movi	r5,64
   29788:	2909c83a 	sub	r4,r5,r4
   2978c:	4108983a 	sll	r4,r8,r4
   29790:	2448b03a 	or	r4,r4,r17
   29794:	2008c03a 	cmpne	r4,r4,zero
   29798:	3922b03a 	or	r17,r7,r4
   2979c:	0009883a 	mov	r4,zero
   297a0:	003f8d06 	br	295d8 <__reset+0xfff895d8>
   297a4:	0007883a 	mov	r3,zero
   297a8:	003fdd06 	br	29720 <__reset+0xfff89720>
   297ac:	0009883a 	mov	r4,zero
   297b0:	003ff706 	br	29790 <__reset+0xfff89790>

000297b4 <__divdf3>:
   297b4:	defff204 	addi	sp,sp,-56
   297b8:	dd400915 	stw	r21,36(sp)
   297bc:	282ad53a 	srli	r21,r5,20
   297c0:	dd000815 	stw	r20,32(sp)
   297c4:	2828d7fa 	srli	r20,r5,31
   297c8:	dc000415 	stw	r16,16(sp)
   297cc:	04000434 	movhi	r16,16
   297d0:	df000c15 	stw	fp,48(sp)
   297d4:	843fffc4 	addi	r16,r16,-1
   297d8:	dfc00d15 	stw	ra,52(sp)
   297dc:	ddc00b15 	stw	r23,44(sp)
   297e0:	dd800a15 	stw	r22,40(sp)
   297e4:	dcc00715 	stw	r19,28(sp)
   297e8:	dc800615 	stw	r18,24(sp)
   297ec:	dc400515 	stw	r17,20(sp)
   297f0:	ad41ffcc 	andi	r21,r21,2047
   297f4:	2c20703a 	and	r16,r5,r16
   297f8:	a7003fcc 	andi	fp,r20,255
   297fc:	a8006126 	beq	r21,zero,29984 <__divdf3+0x1d0>
   29800:	0081ffc4 	movi	r2,2047
   29804:	2025883a 	mov	r18,r4
   29808:	a8803726 	beq	r21,r2,298e8 <__divdf3+0x134>
   2980c:	80800434 	orhi	r2,r16,16
   29810:	100490fa 	slli	r2,r2,3
   29814:	2020d77a 	srli	r16,r4,29
   29818:	202490fa 	slli	r18,r4,3
   2981c:	ad7f0044 	addi	r21,r21,-1023
   29820:	80a0b03a 	or	r16,r16,r2
   29824:	0027883a 	mov	r19,zero
   29828:	0013883a 	mov	r9,zero
   2982c:	3804d53a 	srli	r2,r7,20
   29830:	382cd7fa 	srli	r22,r7,31
   29834:	04400434 	movhi	r17,16
   29838:	8c7fffc4 	addi	r17,r17,-1
   2983c:	1081ffcc 	andi	r2,r2,2047
   29840:	3011883a 	mov	r8,r6
   29844:	3c62703a 	and	r17,r7,r17
   29848:	b5c03fcc 	andi	r23,r22,255
   2984c:	10006c26 	beq	r2,zero,29a00 <__divdf3+0x24c>
   29850:	00c1ffc4 	movi	r3,2047
   29854:	10c06426 	beq	r2,r3,299e8 <__divdf3+0x234>
   29858:	88c00434 	orhi	r3,r17,16
   2985c:	180690fa 	slli	r3,r3,3
   29860:	3022d77a 	srli	r17,r6,29
   29864:	301090fa 	slli	r8,r6,3
   29868:	10bf0044 	addi	r2,r2,-1023
   2986c:	88e2b03a 	or	r17,r17,r3
   29870:	000f883a 	mov	r7,zero
   29874:	a58cf03a 	xor	r6,r20,r22
   29878:	3cc8b03a 	or	r4,r7,r19
   2987c:	a8abc83a 	sub	r21,r21,r2
   29880:	008003c4 	movi	r2,15
   29884:	3007883a 	mov	r3,r6
   29888:	34c03fcc 	andi	r19,r6,255
   2988c:	11009036 	bltu	r2,r4,29ad0 <__divdf3+0x31c>
   29890:	200890ba 	slli	r4,r4,2
   29894:	008000f4 	movhi	r2,3
   29898:	10a62a04 	addi	r2,r2,-26456
   2989c:	2089883a 	add	r4,r4,r2
   298a0:	20800017 	ldw	r2,0(r4)
   298a4:	1000683a 	jmp	r2
   298a8:	00029ad0 	cmplti	zero,zero,2667
   298ac:	00029920 	cmpeqi	zero,zero,2660
   298b0:	00029ac0 	call	29ac <__alt_mem_onchip_memory2_nios2-0x1d654>
   298b4:	00029914 	movui	zero,2660
   298b8:	00029ac0 	call	29ac <__alt_mem_onchip_memory2_nios2-0x1d654>
   298bc:	00029a94 	movui	zero,2666
   298c0:	00029ac0 	call	29ac <__alt_mem_onchip_memory2_nios2-0x1d654>
   298c4:	00029914 	movui	zero,2660
   298c8:	00029920 	cmpeqi	zero,zero,2660
   298cc:	00029920 	cmpeqi	zero,zero,2660
   298d0:	00029a94 	movui	zero,2666
   298d4:	00029914 	movui	zero,2660
   298d8:	00029904 	movi	zero,2660
   298dc:	00029904 	movi	zero,2660
   298e0:	00029904 	movi	zero,2660
   298e4:	00029db4 	movhi	zero,2678
   298e8:	2404b03a 	or	r2,r4,r16
   298ec:	1000661e 	bne	r2,zero,29a88 <__divdf3+0x2d4>
   298f0:	04c00204 	movi	r19,8
   298f4:	0021883a 	mov	r16,zero
   298f8:	0025883a 	mov	r18,zero
   298fc:	02400084 	movi	r9,2
   29900:	003fca06 	br	2982c <__reset+0xfff8982c>
   29904:	8023883a 	mov	r17,r16
   29908:	9011883a 	mov	r8,r18
   2990c:	e02f883a 	mov	r23,fp
   29910:	480f883a 	mov	r7,r9
   29914:	00800084 	movi	r2,2
   29918:	3881311e 	bne	r7,r2,29de0 <__divdf3+0x62c>
   2991c:	b827883a 	mov	r19,r23
   29920:	98c0004c 	andi	r3,r19,1
   29924:	0081ffc4 	movi	r2,2047
   29928:	000b883a 	mov	r5,zero
   2992c:	0025883a 	mov	r18,zero
   29930:	1004953a 	slli	r2,r2,20
   29934:	18c03fcc 	andi	r3,r3,255
   29938:	04400434 	movhi	r17,16
   2993c:	8c7fffc4 	addi	r17,r17,-1
   29940:	180697fa 	slli	r3,r3,31
   29944:	2c4a703a 	and	r5,r5,r17
   29948:	288ab03a 	or	r5,r5,r2
   2994c:	28c6b03a 	or	r3,r5,r3
   29950:	9005883a 	mov	r2,r18
   29954:	dfc00d17 	ldw	ra,52(sp)
   29958:	df000c17 	ldw	fp,48(sp)
   2995c:	ddc00b17 	ldw	r23,44(sp)
   29960:	dd800a17 	ldw	r22,40(sp)
   29964:	dd400917 	ldw	r21,36(sp)
   29968:	dd000817 	ldw	r20,32(sp)
   2996c:	dcc00717 	ldw	r19,28(sp)
   29970:	dc800617 	ldw	r18,24(sp)
   29974:	dc400517 	ldw	r17,20(sp)
   29978:	dc000417 	ldw	r16,16(sp)
   2997c:	dec00e04 	addi	sp,sp,56
   29980:	f800283a 	ret
   29984:	2404b03a 	or	r2,r4,r16
   29988:	2027883a 	mov	r19,r4
   2998c:	10003926 	beq	r2,zero,29a74 <__divdf3+0x2c0>
   29990:	80012e26 	beq	r16,zero,29e4c <__divdf3+0x698>
   29994:	8009883a 	mov	r4,r16
   29998:	d9800315 	stw	r6,12(sp)
   2999c:	d9c00215 	stw	r7,8(sp)
   299a0:	002b6480 	call	2b648 <__clzsi2>
   299a4:	d9800317 	ldw	r6,12(sp)
   299a8:	d9c00217 	ldw	r7,8(sp)
   299ac:	113ffd44 	addi	r4,r2,-11
   299b0:	00c00704 	movi	r3,28
   299b4:	19012116 	blt	r3,r4,29e3c <__divdf3+0x688>
   299b8:	00c00744 	movi	r3,29
   299bc:	147ffe04 	addi	r17,r2,-8
   299c0:	1907c83a 	sub	r3,r3,r4
   299c4:	8460983a 	sll	r16,r16,r17
   299c8:	98c6d83a 	srl	r3,r19,r3
   299cc:	9c64983a 	sll	r18,r19,r17
   299d0:	1c20b03a 	or	r16,r3,r16
   299d4:	1080fcc4 	addi	r2,r2,1011
   299d8:	00abc83a 	sub	r21,zero,r2
   299dc:	0027883a 	mov	r19,zero
   299e0:	0013883a 	mov	r9,zero
   299e4:	003f9106 	br	2982c <__reset+0xfff8982c>
   299e8:	3446b03a 	or	r3,r6,r17
   299ec:	18001f1e 	bne	r3,zero,29a6c <__divdf3+0x2b8>
   299f0:	0023883a 	mov	r17,zero
   299f4:	0011883a 	mov	r8,zero
   299f8:	01c00084 	movi	r7,2
   299fc:	003f9d06 	br	29874 <__reset+0xfff89874>
   29a00:	3446b03a 	or	r3,r6,r17
   29a04:	18001526 	beq	r3,zero,29a5c <__divdf3+0x2a8>
   29a08:	88011b26 	beq	r17,zero,29e78 <__divdf3+0x6c4>
   29a0c:	8809883a 	mov	r4,r17
   29a10:	d9800315 	stw	r6,12(sp)
   29a14:	da400115 	stw	r9,4(sp)
   29a18:	002b6480 	call	2b648 <__clzsi2>
   29a1c:	d9800317 	ldw	r6,12(sp)
   29a20:	da400117 	ldw	r9,4(sp)
   29a24:	113ffd44 	addi	r4,r2,-11
   29a28:	00c00704 	movi	r3,28
   29a2c:	19010e16 	blt	r3,r4,29e68 <__divdf3+0x6b4>
   29a30:	00c00744 	movi	r3,29
   29a34:	123ffe04 	addi	r8,r2,-8
   29a38:	1907c83a 	sub	r3,r3,r4
   29a3c:	8a22983a 	sll	r17,r17,r8
   29a40:	30c6d83a 	srl	r3,r6,r3
   29a44:	3210983a 	sll	r8,r6,r8
   29a48:	1c62b03a 	or	r17,r3,r17
   29a4c:	1080fcc4 	addi	r2,r2,1011
   29a50:	0085c83a 	sub	r2,zero,r2
   29a54:	000f883a 	mov	r7,zero
   29a58:	003f8606 	br	29874 <__reset+0xfff89874>
   29a5c:	0023883a 	mov	r17,zero
   29a60:	0011883a 	mov	r8,zero
   29a64:	01c00044 	movi	r7,1
   29a68:	003f8206 	br	29874 <__reset+0xfff89874>
   29a6c:	01c000c4 	movi	r7,3
   29a70:	003f8006 	br	29874 <__reset+0xfff89874>
   29a74:	04c00104 	movi	r19,4
   29a78:	0021883a 	mov	r16,zero
   29a7c:	0025883a 	mov	r18,zero
   29a80:	02400044 	movi	r9,1
   29a84:	003f6906 	br	2982c <__reset+0xfff8982c>
   29a88:	04c00304 	movi	r19,12
   29a8c:	024000c4 	movi	r9,3
   29a90:	003f6606 	br	2982c <__reset+0xfff8982c>
   29a94:	01400434 	movhi	r5,16
   29a98:	0007883a 	mov	r3,zero
   29a9c:	297fffc4 	addi	r5,r5,-1
   29aa0:	04bfffc4 	movi	r18,-1
   29aa4:	0081ffc4 	movi	r2,2047
   29aa8:	003fa106 	br	29930 <__reset+0xfff89930>
   29aac:	00c00044 	movi	r3,1
   29ab0:	1887c83a 	sub	r3,r3,r2
   29ab4:	01000e04 	movi	r4,56
   29ab8:	20c1210e 	bge	r4,r3,29f40 <__divdf3+0x78c>
   29abc:	98c0004c 	andi	r3,r19,1
   29ac0:	0005883a 	mov	r2,zero
   29ac4:	000b883a 	mov	r5,zero
   29ac8:	0025883a 	mov	r18,zero
   29acc:	003f9806 	br	29930 <__reset+0xfff89930>
   29ad0:	8c00fd36 	bltu	r17,r16,29ec8 <__divdf3+0x714>
   29ad4:	8440fb26 	beq	r16,r17,29ec4 <__divdf3+0x710>
   29ad8:	8007883a 	mov	r3,r16
   29adc:	ad7fffc4 	addi	r21,r21,-1
   29ae0:	0021883a 	mov	r16,zero
   29ae4:	4004d63a 	srli	r2,r8,24
   29ae8:	8822923a 	slli	r17,r17,8
   29aec:	1809883a 	mov	r4,r3
   29af0:	402c923a 	slli	r22,r8,8
   29af4:	88b8b03a 	or	fp,r17,r2
   29af8:	e028d43a 	srli	r20,fp,16
   29afc:	d8c00015 	stw	r3,0(sp)
   29b00:	e5ffffcc 	andi	r23,fp,65535
   29b04:	a00b883a 	mov	r5,r20
   29b08:	0027dec0 	call	27dec <__udivsi3>
   29b0c:	d8c00017 	ldw	r3,0(sp)
   29b10:	a00b883a 	mov	r5,r20
   29b14:	d8800315 	stw	r2,12(sp)
   29b18:	1809883a 	mov	r4,r3
   29b1c:	0027e500 	call	27e50 <__umodsi3>
   29b20:	d9800317 	ldw	r6,12(sp)
   29b24:	1006943a 	slli	r3,r2,16
   29b28:	9004d43a 	srli	r2,r18,16
   29b2c:	b9a3383a 	mul	r17,r23,r6
   29b30:	10c4b03a 	or	r2,r2,r3
   29b34:	1440062e 	bgeu	r2,r17,29b50 <__divdf3+0x39c>
   29b38:	1705883a 	add	r2,r2,fp
   29b3c:	30ffffc4 	addi	r3,r6,-1
   29b40:	1700ee36 	bltu	r2,fp,29efc <__divdf3+0x748>
   29b44:	1440ed2e 	bgeu	r2,r17,29efc <__divdf3+0x748>
   29b48:	31bfff84 	addi	r6,r6,-2
   29b4c:	1705883a 	add	r2,r2,fp
   29b50:	1463c83a 	sub	r17,r2,r17
   29b54:	a00b883a 	mov	r5,r20
   29b58:	8809883a 	mov	r4,r17
   29b5c:	d9800315 	stw	r6,12(sp)
   29b60:	0027dec0 	call	27dec <__udivsi3>
   29b64:	a00b883a 	mov	r5,r20
   29b68:	8809883a 	mov	r4,r17
   29b6c:	d8800215 	stw	r2,8(sp)
   29b70:	0027e500 	call	27e50 <__umodsi3>
   29b74:	d9c00217 	ldw	r7,8(sp)
   29b78:	1004943a 	slli	r2,r2,16
   29b7c:	94bfffcc 	andi	r18,r18,65535
   29b80:	b9d1383a 	mul	r8,r23,r7
   29b84:	90a4b03a 	or	r18,r18,r2
   29b88:	d9800317 	ldw	r6,12(sp)
   29b8c:	9200062e 	bgeu	r18,r8,29ba8 <__divdf3+0x3f4>
   29b90:	9725883a 	add	r18,r18,fp
   29b94:	38bfffc4 	addi	r2,r7,-1
   29b98:	9700d636 	bltu	r18,fp,29ef4 <__divdf3+0x740>
   29b9c:	9200d52e 	bgeu	r18,r8,29ef4 <__divdf3+0x740>
   29ba0:	39ffff84 	addi	r7,r7,-2
   29ba4:	9725883a 	add	r18,r18,fp
   29ba8:	3004943a 	slli	r2,r6,16
   29bac:	b012d43a 	srli	r9,r22,16
   29bb0:	b1bfffcc 	andi	r6,r22,65535
   29bb4:	11e2b03a 	or	r17,r2,r7
   29bb8:	8806d43a 	srli	r3,r17,16
   29bbc:	893fffcc 	andi	r4,r17,65535
   29bc0:	218b383a 	mul	r5,r4,r6
   29bc4:	30c5383a 	mul	r2,r6,r3
   29bc8:	2249383a 	mul	r4,r4,r9
   29bcc:	280ed43a 	srli	r7,r5,16
   29bd0:	9225c83a 	sub	r18,r18,r8
   29bd4:	2089883a 	add	r4,r4,r2
   29bd8:	3909883a 	add	r4,r7,r4
   29bdc:	1a47383a 	mul	r3,r3,r9
   29be0:	2080022e 	bgeu	r4,r2,29bec <__divdf3+0x438>
   29be4:	00800074 	movhi	r2,1
   29be8:	1887883a 	add	r3,r3,r2
   29bec:	2004d43a 	srli	r2,r4,16
   29bf0:	2008943a 	slli	r4,r4,16
   29bf4:	297fffcc 	andi	r5,r5,65535
   29bf8:	10c7883a 	add	r3,r2,r3
   29bfc:	2149883a 	add	r4,r4,r5
   29c00:	90c0a536 	bltu	r18,r3,29e98 <__divdf3+0x6e4>
   29c04:	90c0bf26 	beq	r18,r3,29f04 <__divdf3+0x750>
   29c08:	90c7c83a 	sub	r3,r18,r3
   29c0c:	810fc83a 	sub	r7,r16,r4
   29c10:	81e5803a 	cmpltu	r18,r16,r7
   29c14:	1ca5c83a 	sub	r18,r3,r18
   29c18:	e480c126 	beq	fp,r18,29f20 <__divdf3+0x76c>
   29c1c:	a00b883a 	mov	r5,r20
   29c20:	9009883a 	mov	r4,r18
   29c24:	d9800315 	stw	r6,12(sp)
   29c28:	d9c00215 	stw	r7,8(sp)
   29c2c:	da400115 	stw	r9,4(sp)
   29c30:	0027dec0 	call	27dec <__udivsi3>
   29c34:	a00b883a 	mov	r5,r20
   29c38:	9009883a 	mov	r4,r18
   29c3c:	d8800015 	stw	r2,0(sp)
   29c40:	0027e500 	call	27e50 <__umodsi3>
   29c44:	d9c00217 	ldw	r7,8(sp)
   29c48:	da000017 	ldw	r8,0(sp)
   29c4c:	1006943a 	slli	r3,r2,16
   29c50:	3804d43a 	srli	r2,r7,16
   29c54:	ba21383a 	mul	r16,r23,r8
   29c58:	d9800317 	ldw	r6,12(sp)
   29c5c:	10c4b03a 	or	r2,r2,r3
   29c60:	da400117 	ldw	r9,4(sp)
   29c64:	1400062e 	bgeu	r2,r16,29c80 <__divdf3+0x4cc>
   29c68:	1705883a 	add	r2,r2,fp
   29c6c:	40ffffc4 	addi	r3,r8,-1
   29c70:	1700ad36 	bltu	r2,fp,29f28 <__divdf3+0x774>
   29c74:	1400ac2e 	bgeu	r2,r16,29f28 <__divdf3+0x774>
   29c78:	423fff84 	addi	r8,r8,-2
   29c7c:	1705883a 	add	r2,r2,fp
   29c80:	1421c83a 	sub	r16,r2,r16
   29c84:	a00b883a 	mov	r5,r20
   29c88:	8009883a 	mov	r4,r16
   29c8c:	d9800315 	stw	r6,12(sp)
   29c90:	d9c00215 	stw	r7,8(sp)
   29c94:	da000015 	stw	r8,0(sp)
   29c98:	da400115 	stw	r9,4(sp)
   29c9c:	0027dec0 	call	27dec <__udivsi3>
   29ca0:	8009883a 	mov	r4,r16
   29ca4:	a00b883a 	mov	r5,r20
   29ca8:	1025883a 	mov	r18,r2
   29cac:	0027e500 	call	27e50 <__umodsi3>
   29cb0:	d9c00217 	ldw	r7,8(sp)
   29cb4:	1004943a 	slli	r2,r2,16
   29cb8:	bcaf383a 	mul	r23,r23,r18
   29cbc:	393fffcc 	andi	r4,r7,65535
   29cc0:	2088b03a 	or	r4,r4,r2
   29cc4:	d9800317 	ldw	r6,12(sp)
   29cc8:	da000017 	ldw	r8,0(sp)
   29ccc:	da400117 	ldw	r9,4(sp)
   29cd0:	25c0062e 	bgeu	r4,r23,29cec <__divdf3+0x538>
   29cd4:	2709883a 	add	r4,r4,fp
   29cd8:	90bfffc4 	addi	r2,r18,-1
   29cdc:	27009436 	bltu	r4,fp,29f30 <__divdf3+0x77c>
   29ce0:	25c0932e 	bgeu	r4,r23,29f30 <__divdf3+0x77c>
   29ce4:	94bfff84 	addi	r18,r18,-2
   29ce8:	2709883a 	add	r4,r4,fp
   29cec:	4004943a 	slli	r2,r8,16
   29cf0:	25efc83a 	sub	r23,r4,r23
   29cf4:	1490b03a 	or	r8,r2,r18
   29cf8:	4008d43a 	srli	r4,r8,16
   29cfc:	40ffffcc 	andi	r3,r8,65535
   29d00:	30c5383a 	mul	r2,r6,r3
   29d04:	1a47383a 	mul	r3,r3,r9
   29d08:	310d383a 	mul	r6,r6,r4
   29d0c:	100ad43a 	srli	r5,r2,16
   29d10:	4913383a 	mul	r9,r9,r4
   29d14:	1987883a 	add	r3,r3,r6
   29d18:	28c7883a 	add	r3,r5,r3
   29d1c:	1980022e 	bgeu	r3,r6,29d28 <__divdf3+0x574>
   29d20:	01000074 	movhi	r4,1
   29d24:	4913883a 	add	r9,r9,r4
   29d28:	1808d43a 	srli	r4,r3,16
   29d2c:	1806943a 	slli	r3,r3,16
   29d30:	10bfffcc 	andi	r2,r2,65535
   29d34:	2253883a 	add	r9,r4,r9
   29d38:	1887883a 	add	r3,r3,r2
   29d3c:	ba403836 	bltu	r23,r9,29e20 <__divdf3+0x66c>
   29d40:	ba403626 	beq	r23,r9,29e1c <__divdf3+0x668>
   29d44:	42000054 	ori	r8,r8,1
   29d48:	a880ffc4 	addi	r2,r21,1023
   29d4c:	00bf570e 	bge	zero,r2,29aac <__reset+0xfff89aac>
   29d50:	40c001cc 	andi	r3,r8,7
   29d54:	18000726 	beq	r3,zero,29d74 <__divdf3+0x5c0>
   29d58:	40c003cc 	andi	r3,r8,15
   29d5c:	01000104 	movi	r4,4
   29d60:	19000426 	beq	r3,r4,29d74 <__divdf3+0x5c0>
   29d64:	4107883a 	add	r3,r8,r4
   29d68:	1a11803a 	cmpltu	r8,r3,r8
   29d6c:	8a23883a 	add	r17,r17,r8
   29d70:	1811883a 	mov	r8,r3
   29d74:	88c0402c 	andhi	r3,r17,256
   29d78:	18000426 	beq	r3,zero,29d8c <__divdf3+0x5d8>
   29d7c:	00ffc034 	movhi	r3,65280
   29d80:	18ffffc4 	addi	r3,r3,-1
   29d84:	a8810004 	addi	r2,r21,1024
   29d88:	88e2703a 	and	r17,r17,r3
   29d8c:	00c1ff84 	movi	r3,2046
   29d90:	18bee316 	blt	r3,r2,29920 <__reset+0xfff89920>
   29d94:	8824977a 	slli	r18,r17,29
   29d98:	4010d0fa 	srli	r8,r8,3
   29d9c:	8822927a 	slli	r17,r17,9
   29da0:	1081ffcc 	andi	r2,r2,2047
   29da4:	9224b03a 	or	r18,r18,r8
   29da8:	880ad33a 	srli	r5,r17,12
   29dac:	98c0004c 	andi	r3,r19,1
   29db0:	003edf06 	br	29930 <__reset+0xfff89930>
   29db4:	8080022c 	andhi	r2,r16,8
   29db8:	10001226 	beq	r2,zero,29e04 <__divdf3+0x650>
   29dbc:	8880022c 	andhi	r2,r17,8
   29dc0:	1000101e 	bne	r2,zero,29e04 <__divdf3+0x650>
   29dc4:	00800434 	movhi	r2,16
   29dc8:	89400234 	orhi	r5,r17,8
   29dcc:	10bfffc4 	addi	r2,r2,-1
   29dd0:	b007883a 	mov	r3,r22
   29dd4:	288a703a 	and	r5,r5,r2
   29dd8:	4025883a 	mov	r18,r8
   29ddc:	003f3106 	br	29aa4 <__reset+0xfff89aa4>
   29de0:	008000c4 	movi	r2,3
   29de4:	3880a626 	beq	r7,r2,2a080 <__divdf3+0x8cc>
   29de8:	00800044 	movi	r2,1
   29dec:	3880521e 	bne	r7,r2,29f38 <__divdf3+0x784>
   29df0:	b807883a 	mov	r3,r23
   29df4:	0005883a 	mov	r2,zero
   29df8:	000b883a 	mov	r5,zero
   29dfc:	0025883a 	mov	r18,zero
   29e00:	003ecb06 	br	29930 <__reset+0xfff89930>
   29e04:	00800434 	movhi	r2,16
   29e08:	81400234 	orhi	r5,r16,8
   29e0c:	10bfffc4 	addi	r2,r2,-1
   29e10:	a007883a 	mov	r3,r20
   29e14:	288a703a 	and	r5,r5,r2
   29e18:	003f2206 	br	29aa4 <__reset+0xfff89aa4>
   29e1c:	183fca26 	beq	r3,zero,29d48 <__reset+0xfff89d48>
   29e20:	e5ef883a 	add	r23,fp,r23
   29e24:	40bfffc4 	addi	r2,r8,-1
   29e28:	bf00392e 	bgeu	r23,fp,29f10 <__divdf3+0x75c>
   29e2c:	1011883a 	mov	r8,r2
   29e30:	ba7fc41e 	bne	r23,r9,29d44 <__reset+0xfff89d44>
   29e34:	b0ffc31e 	bne	r22,r3,29d44 <__reset+0xfff89d44>
   29e38:	003fc306 	br	29d48 <__reset+0xfff89d48>
   29e3c:	143ff604 	addi	r16,r2,-40
   29e40:	9c20983a 	sll	r16,r19,r16
   29e44:	0025883a 	mov	r18,zero
   29e48:	003ee206 	br	299d4 <__reset+0xfff899d4>
   29e4c:	d9800315 	stw	r6,12(sp)
   29e50:	d9c00215 	stw	r7,8(sp)
   29e54:	002b6480 	call	2b648 <__clzsi2>
   29e58:	10800804 	addi	r2,r2,32
   29e5c:	d9c00217 	ldw	r7,8(sp)
   29e60:	d9800317 	ldw	r6,12(sp)
   29e64:	003ed106 	br	299ac <__reset+0xfff899ac>
   29e68:	147ff604 	addi	r17,r2,-40
   29e6c:	3462983a 	sll	r17,r6,r17
   29e70:	0011883a 	mov	r8,zero
   29e74:	003ef506 	br	29a4c <__reset+0xfff89a4c>
   29e78:	3009883a 	mov	r4,r6
   29e7c:	d9800315 	stw	r6,12(sp)
   29e80:	da400115 	stw	r9,4(sp)
   29e84:	002b6480 	call	2b648 <__clzsi2>
   29e88:	10800804 	addi	r2,r2,32
   29e8c:	da400117 	ldw	r9,4(sp)
   29e90:	d9800317 	ldw	r6,12(sp)
   29e94:	003ee306 	br	29a24 <__reset+0xfff89a24>
   29e98:	85a1883a 	add	r16,r16,r22
   29e9c:	8585803a 	cmpltu	r2,r16,r22
   29ea0:	1705883a 	add	r2,r2,fp
   29ea4:	14a5883a 	add	r18,r2,r18
   29ea8:	88bfffc4 	addi	r2,r17,-1
   29eac:	e4800c2e 	bgeu	fp,r18,29ee0 <__divdf3+0x72c>
   29eb0:	90c03e36 	bltu	r18,r3,29fac <__divdf3+0x7f8>
   29eb4:	1c806926 	beq	r3,r18,2a05c <__divdf3+0x8a8>
   29eb8:	90c7c83a 	sub	r3,r18,r3
   29ebc:	1023883a 	mov	r17,r2
   29ec0:	003f5206 	br	29c0c <__reset+0xfff89c0c>
   29ec4:	923f0436 	bltu	r18,r8,29ad8 <__reset+0xfff89ad8>
   29ec8:	800897fa 	slli	r4,r16,31
   29ecc:	9004d07a 	srli	r2,r18,1
   29ed0:	8006d07a 	srli	r3,r16,1
   29ed4:	902097fa 	slli	r16,r18,31
   29ed8:	20a4b03a 	or	r18,r4,r2
   29edc:	003f0106 	br	29ae4 <__reset+0xfff89ae4>
   29ee0:	e4bff51e 	bne	fp,r18,29eb8 <__reset+0xfff89eb8>
   29ee4:	85bff22e 	bgeu	r16,r22,29eb0 <__reset+0xfff89eb0>
   29ee8:	e0c7c83a 	sub	r3,fp,r3
   29eec:	1023883a 	mov	r17,r2
   29ef0:	003f4606 	br	29c0c <__reset+0xfff89c0c>
   29ef4:	100f883a 	mov	r7,r2
   29ef8:	003f2b06 	br	29ba8 <__reset+0xfff89ba8>
   29efc:	180d883a 	mov	r6,r3
   29f00:	003f1306 	br	29b50 <__reset+0xfff89b50>
   29f04:	813fe436 	bltu	r16,r4,29e98 <__reset+0xfff89e98>
   29f08:	0007883a 	mov	r3,zero
   29f0c:	003f3f06 	br	29c0c <__reset+0xfff89c0c>
   29f10:	ba402c36 	bltu	r23,r9,29fc4 <__divdf3+0x810>
   29f14:	4dc05426 	beq	r9,r23,2a068 <__divdf3+0x8b4>
   29f18:	1011883a 	mov	r8,r2
   29f1c:	003f8906 	br	29d44 <__reset+0xfff89d44>
   29f20:	023fffc4 	movi	r8,-1
   29f24:	003f8806 	br	29d48 <__reset+0xfff89d48>
   29f28:	1811883a 	mov	r8,r3
   29f2c:	003f5406 	br	29c80 <__reset+0xfff89c80>
   29f30:	1025883a 	mov	r18,r2
   29f34:	003f6d06 	br	29cec <__reset+0xfff89cec>
   29f38:	b827883a 	mov	r19,r23
   29f3c:	003f8206 	br	29d48 <__reset+0xfff89d48>
   29f40:	010007c4 	movi	r4,31
   29f44:	20c02616 	blt	r4,r3,29fe0 <__divdf3+0x82c>
   29f48:	00800804 	movi	r2,32
   29f4c:	10c5c83a 	sub	r2,r2,r3
   29f50:	888a983a 	sll	r5,r17,r2
   29f54:	40c8d83a 	srl	r4,r8,r3
   29f58:	4084983a 	sll	r2,r8,r2
   29f5c:	88e2d83a 	srl	r17,r17,r3
   29f60:	2906b03a 	or	r3,r5,r4
   29f64:	1004c03a 	cmpne	r2,r2,zero
   29f68:	1886b03a 	or	r3,r3,r2
   29f6c:	188001cc 	andi	r2,r3,7
   29f70:	10000726 	beq	r2,zero,29f90 <__divdf3+0x7dc>
   29f74:	188003cc 	andi	r2,r3,15
   29f78:	01000104 	movi	r4,4
   29f7c:	11000426 	beq	r2,r4,29f90 <__divdf3+0x7dc>
   29f80:	1805883a 	mov	r2,r3
   29f84:	10c00104 	addi	r3,r2,4
   29f88:	1885803a 	cmpltu	r2,r3,r2
   29f8c:	88a3883a 	add	r17,r17,r2
   29f90:	8880202c 	andhi	r2,r17,128
   29f94:	10002726 	beq	r2,zero,2a034 <__divdf3+0x880>
   29f98:	98c0004c 	andi	r3,r19,1
   29f9c:	00800044 	movi	r2,1
   29fa0:	000b883a 	mov	r5,zero
   29fa4:	0025883a 	mov	r18,zero
   29fa8:	003e6106 	br	29930 <__reset+0xfff89930>
   29fac:	85a1883a 	add	r16,r16,r22
   29fb0:	8585803a 	cmpltu	r2,r16,r22
   29fb4:	1705883a 	add	r2,r2,fp
   29fb8:	14a5883a 	add	r18,r2,r18
   29fbc:	8c7fff84 	addi	r17,r17,-2
   29fc0:	003f1106 	br	29c08 <__reset+0xfff89c08>
   29fc4:	b589883a 	add	r4,r22,r22
   29fc8:	25ad803a 	cmpltu	r22,r4,r22
   29fcc:	b739883a 	add	fp,r22,fp
   29fd0:	40bfff84 	addi	r2,r8,-2
   29fd4:	bf2f883a 	add	r23,r23,fp
   29fd8:	202d883a 	mov	r22,r4
   29fdc:	003f9306 	br	29e2c <__reset+0xfff89e2c>
   29fe0:	013ff844 	movi	r4,-31
   29fe4:	2085c83a 	sub	r2,r4,r2
   29fe8:	8888d83a 	srl	r4,r17,r2
   29fec:	00800804 	movi	r2,32
   29ff0:	18802126 	beq	r3,r2,2a078 <__divdf3+0x8c4>
   29ff4:	00801004 	movi	r2,64
   29ff8:	10c5c83a 	sub	r2,r2,r3
   29ffc:	8884983a 	sll	r2,r17,r2
   2a000:	1204b03a 	or	r2,r2,r8
   2a004:	1004c03a 	cmpne	r2,r2,zero
   2a008:	2084b03a 	or	r2,r4,r2
   2a00c:	144001cc 	andi	r17,r2,7
   2a010:	88000d1e 	bne	r17,zero,2a048 <__divdf3+0x894>
   2a014:	000b883a 	mov	r5,zero
   2a018:	1024d0fa 	srli	r18,r2,3
   2a01c:	98c0004c 	andi	r3,r19,1
   2a020:	0005883a 	mov	r2,zero
   2a024:	9464b03a 	or	r18,r18,r17
   2a028:	003e4106 	br	29930 <__reset+0xfff89930>
   2a02c:	1007883a 	mov	r3,r2
   2a030:	0023883a 	mov	r17,zero
   2a034:	880a927a 	slli	r5,r17,9
   2a038:	1805883a 	mov	r2,r3
   2a03c:	8822977a 	slli	r17,r17,29
   2a040:	280ad33a 	srli	r5,r5,12
   2a044:	003ff406 	br	2a018 <__reset+0xfff8a018>
   2a048:	10c003cc 	andi	r3,r2,15
   2a04c:	01000104 	movi	r4,4
   2a050:	193ff626 	beq	r3,r4,2a02c <__reset+0xfff8a02c>
   2a054:	0023883a 	mov	r17,zero
   2a058:	003fca06 	br	29f84 <__reset+0xfff89f84>
   2a05c:	813fd336 	bltu	r16,r4,29fac <__reset+0xfff89fac>
   2a060:	1023883a 	mov	r17,r2
   2a064:	003fa806 	br	29f08 <__reset+0xfff89f08>
   2a068:	b0ffd636 	bltu	r22,r3,29fc4 <__reset+0xfff89fc4>
   2a06c:	1011883a 	mov	r8,r2
   2a070:	b0ff341e 	bne	r22,r3,29d44 <__reset+0xfff89d44>
   2a074:	003f3406 	br	29d48 <__reset+0xfff89d48>
   2a078:	0005883a 	mov	r2,zero
   2a07c:	003fe006 	br	2a000 <__reset+0xfff8a000>
   2a080:	00800434 	movhi	r2,16
   2a084:	89400234 	orhi	r5,r17,8
   2a088:	10bfffc4 	addi	r2,r2,-1
   2a08c:	b807883a 	mov	r3,r23
   2a090:	288a703a 	and	r5,r5,r2
   2a094:	4025883a 	mov	r18,r8
   2a098:	003e8206 	br	29aa4 <__reset+0xfff89aa4>

0002a09c <__gedf2>:
   2a09c:	2804d53a 	srli	r2,r5,20
   2a0a0:	3806d53a 	srli	r3,r7,20
   2a0a4:	02000434 	movhi	r8,16
   2a0a8:	423fffc4 	addi	r8,r8,-1
   2a0ac:	1081ffcc 	andi	r2,r2,2047
   2a0b0:	0241ffc4 	movi	r9,2047
   2a0b4:	2a14703a 	and	r10,r5,r8
   2a0b8:	18c1ffcc 	andi	r3,r3,2047
   2a0bc:	3a10703a 	and	r8,r7,r8
   2a0c0:	280ad7fa 	srli	r5,r5,31
   2a0c4:	380ed7fa 	srli	r7,r7,31
   2a0c8:	12401d26 	beq	r2,r9,2a140 <__gedf2+0xa4>
   2a0cc:	0241ffc4 	movi	r9,2047
   2a0d0:	1a401226 	beq	r3,r9,2a11c <__gedf2+0x80>
   2a0d4:	1000081e 	bne	r2,zero,2a0f8 <__gedf2+0x5c>
   2a0d8:	2296b03a 	or	r11,r4,r10
   2a0dc:	5813003a 	cmpeq	r9,r11,zero
   2a0e0:	1800091e 	bne	r3,zero,2a108 <__gedf2+0x6c>
   2a0e4:	3218b03a 	or	r12,r6,r8
   2a0e8:	6000071e 	bne	r12,zero,2a108 <__gedf2+0x6c>
   2a0ec:	0005883a 	mov	r2,zero
   2a0f0:	5800101e 	bne	r11,zero,2a134 <__gedf2+0x98>
   2a0f4:	f800283a 	ret
   2a0f8:	18000c1e 	bne	r3,zero,2a12c <__gedf2+0x90>
   2a0fc:	3212b03a 	or	r9,r6,r8
   2a100:	48000c26 	beq	r9,zero,2a134 <__gedf2+0x98>
   2a104:	0013883a 	mov	r9,zero
   2a108:	39c03fcc 	andi	r7,r7,255
   2a10c:	48000826 	beq	r9,zero,2a130 <__gedf2+0x94>
   2a110:	38000926 	beq	r7,zero,2a138 <__gedf2+0x9c>
   2a114:	00800044 	movi	r2,1
   2a118:	f800283a 	ret
   2a11c:	3212b03a 	or	r9,r6,r8
   2a120:	483fec26 	beq	r9,zero,2a0d4 <__reset+0xfff8a0d4>
   2a124:	00bfff84 	movi	r2,-2
   2a128:	f800283a 	ret
   2a12c:	39c03fcc 	andi	r7,r7,255
   2a130:	29c00626 	beq	r5,r7,2a14c <__gedf2+0xb0>
   2a134:	283ff726 	beq	r5,zero,2a114 <__reset+0xfff8a114>
   2a138:	00bfffc4 	movi	r2,-1
   2a13c:	f800283a 	ret
   2a140:	2292b03a 	or	r9,r4,r10
   2a144:	483fe126 	beq	r9,zero,2a0cc <__reset+0xfff8a0cc>
   2a148:	003ff606 	br	2a124 <__reset+0xfff8a124>
   2a14c:	18bff916 	blt	r3,r2,2a134 <__reset+0xfff8a134>
   2a150:	10c00316 	blt	r2,r3,2a160 <__gedf2+0xc4>
   2a154:	42bff736 	bltu	r8,r10,2a134 <__reset+0xfff8a134>
   2a158:	52000326 	beq	r10,r8,2a168 <__gedf2+0xcc>
   2a15c:	5200042e 	bgeu	r10,r8,2a170 <__gedf2+0xd4>
   2a160:	283fec1e 	bne	r5,zero,2a114 <__reset+0xfff8a114>
   2a164:	003ff406 	br	2a138 <__reset+0xfff8a138>
   2a168:	313ff236 	bltu	r6,r4,2a134 <__reset+0xfff8a134>
   2a16c:	21bffc36 	bltu	r4,r6,2a160 <__reset+0xfff8a160>
   2a170:	0005883a 	mov	r2,zero
   2a174:	f800283a 	ret

0002a178 <__muldf3>:
   2a178:	defff304 	addi	sp,sp,-52
   2a17c:	2804d53a 	srli	r2,r5,20
   2a180:	dd800915 	stw	r22,36(sp)
   2a184:	282cd7fa 	srli	r22,r5,31
   2a188:	dc000315 	stw	r16,12(sp)
   2a18c:	04000434 	movhi	r16,16
   2a190:	dd400815 	stw	r21,32(sp)
   2a194:	dc800515 	stw	r18,20(sp)
   2a198:	843fffc4 	addi	r16,r16,-1
   2a19c:	dfc00c15 	stw	ra,48(sp)
   2a1a0:	df000b15 	stw	fp,44(sp)
   2a1a4:	ddc00a15 	stw	r23,40(sp)
   2a1a8:	dd000715 	stw	r20,28(sp)
   2a1ac:	dcc00615 	stw	r19,24(sp)
   2a1b0:	dc400415 	stw	r17,16(sp)
   2a1b4:	1481ffcc 	andi	r18,r2,2047
   2a1b8:	2c20703a 	and	r16,r5,r16
   2a1bc:	b02b883a 	mov	r21,r22
   2a1c0:	b2403fcc 	andi	r9,r22,255
   2a1c4:	90006026 	beq	r18,zero,2a348 <__muldf3+0x1d0>
   2a1c8:	0081ffc4 	movi	r2,2047
   2a1cc:	2029883a 	mov	r20,r4
   2a1d0:	90803626 	beq	r18,r2,2a2ac <__muldf3+0x134>
   2a1d4:	80800434 	orhi	r2,r16,16
   2a1d8:	100490fa 	slli	r2,r2,3
   2a1dc:	2020d77a 	srli	r16,r4,29
   2a1e0:	202890fa 	slli	r20,r4,3
   2a1e4:	94bf0044 	addi	r18,r18,-1023
   2a1e8:	80a0b03a 	or	r16,r16,r2
   2a1ec:	0027883a 	mov	r19,zero
   2a1f0:	0039883a 	mov	fp,zero
   2a1f4:	3804d53a 	srli	r2,r7,20
   2a1f8:	382ed7fa 	srli	r23,r7,31
   2a1fc:	04400434 	movhi	r17,16
   2a200:	8c7fffc4 	addi	r17,r17,-1
   2a204:	1081ffcc 	andi	r2,r2,2047
   2a208:	3011883a 	mov	r8,r6
   2a20c:	3c62703a 	and	r17,r7,r17
   2a210:	ba803fcc 	andi	r10,r23,255
   2a214:	10006d26 	beq	r2,zero,2a3cc <__muldf3+0x254>
   2a218:	00c1ffc4 	movi	r3,2047
   2a21c:	10c06526 	beq	r2,r3,2a3b4 <__muldf3+0x23c>
   2a220:	88c00434 	orhi	r3,r17,16
   2a224:	180690fa 	slli	r3,r3,3
   2a228:	3022d77a 	srli	r17,r6,29
   2a22c:	301090fa 	slli	r8,r6,3
   2a230:	10bf0044 	addi	r2,r2,-1023
   2a234:	88e2b03a 	or	r17,r17,r3
   2a238:	000b883a 	mov	r5,zero
   2a23c:	9085883a 	add	r2,r18,r2
   2a240:	2cc8b03a 	or	r4,r5,r19
   2a244:	00c003c4 	movi	r3,15
   2a248:	bdacf03a 	xor	r22,r23,r22
   2a24c:	12c00044 	addi	r11,r2,1
   2a250:	19009936 	bltu	r3,r4,2a4b8 <__muldf3+0x340>
   2a254:	200890ba 	slli	r4,r4,2
   2a258:	00c000f4 	movhi	r3,3
   2a25c:	18e89b04 	addi	r3,r3,-23956
   2a260:	20c9883a 	add	r4,r4,r3
   2a264:	20c00017 	ldw	r3,0(r4)
   2a268:	1800683a 	jmp	r3
   2a26c:	0002a4b8 	rdprs	zero,zero,2706
   2a270:	0002a2cc 	andi	zero,zero,2699
   2a274:	0002a2cc 	andi	zero,zero,2699
   2a278:	0002a2c8 	cmpgei	zero,zero,2699
   2a27c:	0002a494 	movui	zero,2706
   2a280:	0002a494 	movui	zero,2706
   2a284:	0002a47c 	xorhi	zero,zero,2705
   2a288:	0002a2c8 	cmpgei	zero,zero,2699
   2a28c:	0002a494 	movui	zero,2706
   2a290:	0002a47c 	xorhi	zero,zero,2705
   2a294:	0002a494 	movui	zero,2706
   2a298:	0002a2c8 	cmpgei	zero,zero,2699
   2a29c:	0002a4a4 	muli	zero,zero,2706
   2a2a0:	0002a4a4 	muli	zero,zero,2706
   2a2a4:	0002a4a4 	muli	zero,zero,2706
   2a2a8:	0002a6c0 	call	2a6c <__alt_mem_onchip_memory2_nios2-0x1d594>
   2a2ac:	2404b03a 	or	r2,r4,r16
   2a2b0:	10006f1e 	bne	r2,zero,2a470 <__muldf3+0x2f8>
   2a2b4:	04c00204 	movi	r19,8
   2a2b8:	0021883a 	mov	r16,zero
   2a2bc:	0029883a 	mov	r20,zero
   2a2c0:	07000084 	movi	fp,2
   2a2c4:	003fcb06 	br	2a1f4 <__reset+0xfff8a1f4>
   2a2c8:	502d883a 	mov	r22,r10
   2a2cc:	00800084 	movi	r2,2
   2a2d0:	28805726 	beq	r5,r2,2a430 <__muldf3+0x2b8>
   2a2d4:	008000c4 	movi	r2,3
   2a2d8:	28816626 	beq	r5,r2,2a874 <__muldf3+0x6fc>
   2a2dc:	00800044 	movi	r2,1
   2a2e0:	2881411e 	bne	r5,r2,2a7e8 <__muldf3+0x670>
   2a2e4:	b02b883a 	mov	r21,r22
   2a2e8:	0005883a 	mov	r2,zero
   2a2ec:	000b883a 	mov	r5,zero
   2a2f0:	0029883a 	mov	r20,zero
   2a2f4:	1004953a 	slli	r2,r2,20
   2a2f8:	a8c03fcc 	andi	r3,r21,255
   2a2fc:	04400434 	movhi	r17,16
   2a300:	8c7fffc4 	addi	r17,r17,-1
   2a304:	180697fa 	slli	r3,r3,31
   2a308:	2c4a703a 	and	r5,r5,r17
   2a30c:	288ab03a 	or	r5,r5,r2
   2a310:	28c6b03a 	or	r3,r5,r3
   2a314:	a005883a 	mov	r2,r20
   2a318:	dfc00c17 	ldw	ra,48(sp)
   2a31c:	df000b17 	ldw	fp,44(sp)
   2a320:	ddc00a17 	ldw	r23,40(sp)
   2a324:	dd800917 	ldw	r22,36(sp)
   2a328:	dd400817 	ldw	r21,32(sp)
   2a32c:	dd000717 	ldw	r20,28(sp)
   2a330:	dcc00617 	ldw	r19,24(sp)
   2a334:	dc800517 	ldw	r18,20(sp)
   2a338:	dc400417 	ldw	r17,16(sp)
   2a33c:	dc000317 	ldw	r16,12(sp)
   2a340:	dec00d04 	addi	sp,sp,52
   2a344:	f800283a 	ret
   2a348:	2404b03a 	or	r2,r4,r16
   2a34c:	2027883a 	mov	r19,r4
   2a350:	10004226 	beq	r2,zero,2a45c <__muldf3+0x2e4>
   2a354:	8000fc26 	beq	r16,zero,2a748 <__muldf3+0x5d0>
   2a358:	8009883a 	mov	r4,r16
   2a35c:	d9800215 	stw	r6,8(sp)
   2a360:	d9c00015 	stw	r7,0(sp)
   2a364:	da400115 	stw	r9,4(sp)
   2a368:	002b6480 	call	2b648 <__clzsi2>
   2a36c:	d9800217 	ldw	r6,8(sp)
   2a370:	d9c00017 	ldw	r7,0(sp)
   2a374:	da400117 	ldw	r9,4(sp)
   2a378:	113ffd44 	addi	r4,r2,-11
   2a37c:	00c00704 	movi	r3,28
   2a380:	1900ed16 	blt	r3,r4,2a738 <__muldf3+0x5c0>
   2a384:	00c00744 	movi	r3,29
   2a388:	147ffe04 	addi	r17,r2,-8
   2a38c:	1907c83a 	sub	r3,r3,r4
   2a390:	8460983a 	sll	r16,r16,r17
   2a394:	98c6d83a 	srl	r3,r19,r3
   2a398:	9c68983a 	sll	r20,r19,r17
   2a39c:	1c20b03a 	or	r16,r3,r16
   2a3a0:	1080fcc4 	addi	r2,r2,1011
   2a3a4:	00a5c83a 	sub	r18,zero,r2
   2a3a8:	0027883a 	mov	r19,zero
   2a3ac:	0039883a 	mov	fp,zero
   2a3b0:	003f9006 	br	2a1f4 <__reset+0xfff8a1f4>
   2a3b4:	3446b03a 	or	r3,r6,r17
   2a3b8:	1800261e 	bne	r3,zero,2a454 <__muldf3+0x2dc>
   2a3bc:	0023883a 	mov	r17,zero
   2a3c0:	0011883a 	mov	r8,zero
   2a3c4:	01400084 	movi	r5,2
   2a3c8:	003f9c06 	br	2a23c <__reset+0xfff8a23c>
   2a3cc:	3446b03a 	or	r3,r6,r17
   2a3d0:	18001c26 	beq	r3,zero,2a444 <__muldf3+0x2cc>
   2a3d4:	8800ce26 	beq	r17,zero,2a710 <__muldf3+0x598>
   2a3d8:	8809883a 	mov	r4,r17
   2a3dc:	d9800215 	stw	r6,8(sp)
   2a3e0:	da400115 	stw	r9,4(sp)
   2a3e4:	da800015 	stw	r10,0(sp)
   2a3e8:	002b6480 	call	2b648 <__clzsi2>
   2a3ec:	d9800217 	ldw	r6,8(sp)
   2a3f0:	da400117 	ldw	r9,4(sp)
   2a3f4:	da800017 	ldw	r10,0(sp)
   2a3f8:	113ffd44 	addi	r4,r2,-11
   2a3fc:	00c00704 	movi	r3,28
   2a400:	1900bf16 	blt	r3,r4,2a700 <__muldf3+0x588>
   2a404:	00c00744 	movi	r3,29
   2a408:	123ffe04 	addi	r8,r2,-8
   2a40c:	1907c83a 	sub	r3,r3,r4
   2a410:	8a22983a 	sll	r17,r17,r8
   2a414:	30c6d83a 	srl	r3,r6,r3
   2a418:	3210983a 	sll	r8,r6,r8
   2a41c:	1c62b03a 	or	r17,r3,r17
   2a420:	1080fcc4 	addi	r2,r2,1011
   2a424:	0085c83a 	sub	r2,zero,r2
   2a428:	000b883a 	mov	r5,zero
   2a42c:	003f8306 	br	2a23c <__reset+0xfff8a23c>
   2a430:	b02b883a 	mov	r21,r22
   2a434:	0081ffc4 	movi	r2,2047
   2a438:	000b883a 	mov	r5,zero
   2a43c:	0029883a 	mov	r20,zero
   2a440:	003fac06 	br	2a2f4 <__reset+0xfff8a2f4>
   2a444:	0023883a 	mov	r17,zero
   2a448:	0011883a 	mov	r8,zero
   2a44c:	01400044 	movi	r5,1
   2a450:	003f7a06 	br	2a23c <__reset+0xfff8a23c>
   2a454:	014000c4 	movi	r5,3
   2a458:	003f7806 	br	2a23c <__reset+0xfff8a23c>
   2a45c:	04c00104 	movi	r19,4
   2a460:	0021883a 	mov	r16,zero
   2a464:	0029883a 	mov	r20,zero
   2a468:	07000044 	movi	fp,1
   2a46c:	003f6106 	br	2a1f4 <__reset+0xfff8a1f4>
   2a470:	04c00304 	movi	r19,12
   2a474:	070000c4 	movi	fp,3
   2a478:	003f5e06 	br	2a1f4 <__reset+0xfff8a1f4>
   2a47c:	01400434 	movhi	r5,16
   2a480:	002b883a 	mov	r21,zero
   2a484:	297fffc4 	addi	r5,r5,-1
   2a488:	053fffc4 	movi	r20,-1
   2a48c:	0081ffc4 	movi	r2,2047
   2a490:	003f9806 	br	2a2f4 <__reset+0xfff8a2f4>
   2a494:	8023883a 	mov	r17,r16
   2a498:	a011883a 	mov	r8,r20
   2a49c:	e00b883a 	mov	r5,fp
   2a4a0:	003f8a06 	br	2a2cc <__reset+0xfff8a2cc>
   2a4a4:	8023883a 	mov	r17,r16
   2a4a8:	a011883a 	mov	r8,r20
   2a4ac:	482d883a 	mov	r22,r9
   2a4b0:	e00b883a 	mov	r5,fp
   2a4b4:	003f8506 	br	2a2cc <__reset+0xfff8a2cc>
   2a4b8:	a00ad43a 	srli	r5,r20,16
   2a4bc:	401ad43a 	srli	r13,r8,16
   2a4c0:	a53fffcc 	andi	r20,r20,65535
   2a4c4:	423fffcc 	andi	r8,r8,65535
   2a4c8:	4519383a 	mul	r12,r8,r20
   2a4cc:	4147383a 	mul	r3,r8,r5
   2a4d0:	6d09383a 	mul	r4,r13,r20
   2a4d4:	600cd43a 	srli	r6,r12,16
   2a4d8:	2b5d383a 	mul	r14,r5,r13
   2a4dc:	20c9883a 	add	r4,r4,r3
   2a4e0:	310d883a 	add	r6,r6,r4
   2a4e4:	30c0022e 	bgeu	r6,r3,2a4f0 <__muldf3+0x378>
   2a4e8:	00c00074 	movhi	r3,1
   2a4ec:	70dd883a 	add	r14,r14,r3
   2a4f0:	8826d43a 	srli	r19,r17,16
   2a4f4:	8bffffcc 	andi	r15,r17,65535
   2a4f8:	7d23383a 	mul	r17,r15,r20
   2a4fc:	7949383a 	mul	r4,r15,r5
   2a500:	9d29383a 	mul	r20,r19,r20
   2a504:	8814d43a 	srli	r10,r17,16
   2a508:	3012943a 	slli	r9,r6,16
   2a50c:	a129883a 	add	r20,r20,r4
   2a510:	633fffcc 	andi	r12,r12,65535
   2a514:	5515883a 	add	r10,r10,r20
   2a518:	3006d43a 	srli	r3,r6,16
   2a51c:	4b13883a 	add	r9,r9,r12
   2a520:	2ccb383a 	mul	r5,r5,r19
   2a524:	5100022e 	bgeu	r10,r4,2a530 <__muldf3+0x3b8>
   2a528:	01000074 	movhi	r4,1
   2a52c:	290b883a 	add	r5,r5,r4
   2a530:	802ad43a 	srli	r21,r16,16
   2a534:	843fffcc 	andi	r16,r16,65535
   2a538:	440d383a 	mul	r6,r8,r16
   2a53c:	4565383a 	mul	r18,r8,r21
   2a540:	8349383a 	mul	r4,r16,r13
   2a544:	500e943a 	slli	r7,r10,16
   2a548:	3010d43a 	srli	r8,r6,16
   2a54c:	5028d43a 	srli	r20,r10,16
   2a550:	2489883a 	add	r4,r4,r18
   2a554:	8abfffcc 	andi	r10,r17,65535
   2a558:	3a95883a 	add	r10,r7,r10
   2a55c:	4119883a 	add	r12,r8,r4
   2a560:	a169883a 	add	r20,r20,r5
   2a564:	1a87883a 	add	r3,r3,r10
   2a568:	6d5b383a 	mul	r13,r13,r21
   2a56c:	6480022e 	bgeu	r12,r18,2a578 <__muldf3+0x400>
   2a570:	01000074 	movhi	r4,1
   2a574:	691b883a 	add	r13,r13,r4
   2a578:	7c25383a 	mul	r18,r15,r16
   2a57c:	7d4b383a 	mul	r5,r15,r21
   2a580:	84cf383a 	mul	r7,r16,r19
   2a584:	901ed43a 	srli	r15,r18,16
   2a588:	6008d43a 	srli	r4,r12,16
   2a58c:	6010943a 	slli	r8,r12,16
   2a590:	394f883a 	add	r7,r7,r5
   2a594:	333fffcc 	andi	r12,r6,65535
   2a598:	79df883a 	add	r15,r15,r7
   2a59c:	235b883a 	add	r13,r4,r13
   2a5a0:	9d63383a 	mul	r17,r19,r21
   2a5a4:	4309883a 	add	r4,r8,r12
   2a5a8:	7940022e 	bgeu	r15,r5,2a5b4 <__muldf3+0x43c>
   2a5ac:	01400074 	movhi	r5,1
   2a5b0:	8963883a 	add	r17,r17,r5
   2a5b4:	780a943a 	slli	r5,r15,16
   2a5b8:	91bfffcc 	andi	r6,r18,65535
   2a5bc:	70c7883a 	add	r3,r14,r3
   2a5c0:	298d883a 	add	r6,r5,r6
   2a5c4:	1a8f803a 	cmpltu	r7,r3,r10
   2a5c8:	350b883a 	add	r5,r6,r20
   2a5cc:	20c7883a 	add	r3,r4,r3
   2a5d0:	3955883a 	add	r10,r7,r5
   2a5d4:	1909803a 	cmpltu	r4,r3,r4
   2a5d8:	6a91883a 	add	r8,r13,r10
   2a5dc:	780cd43a 	srli	r6,r15,16
   2a5e0:	2219883a 	add	r12,r4,r8
   2a5e4:	2d0b803a 	cmpltu	r5,r5,r20
   2a5e8:	51cf803a 	cmpltu	r7,r10,r7
   2a5ec:	29ceb03a 	or	r7,r5,r7
   2a5f0:	4351803a 	cmpltu	r8,r8,r13
   2a5f4:	610b803a 	cmpltu	r5,r12,r4
   2a5f8:	4148b03a 	or	r4,r8,r5
   2a5fc:	398f883a 	add	r7,r7,r6
   2a600:	3909883a 	add	r4,r7,r4
   2a604:	1810927a 	slli	r8,r3,9
   2a608:	2449883a 	add	r4,r4,r17
   2a60c:	2008927a 	slli	r4,r4,9
   2a610:	6022d5fa 	srli	r17,r12,23
   2a614:	1806d5fa 	srli	r3,r3,23
   2a618:	4252b03a 	or	r9,r8,r9
   2a61c:	600a927a 	slli	r5,r12,9
   2a620:	4810c03a 	cmpne	r8,r9,zero
   2a624:	2462b03a 	or	r17,r4,r17
   2a628:	40c6b03a 	or	r3,r8,r3
   2a62c:	8900402c 	andhi	r4,r17,256
   2a630:	1950b03a 	or	r8,r3,r5
   2a634:	20000726 	beq	r4,zero,2a654 <__muldf3+0x4dc>
   2a638:	4006d07a 	srli	r3,r8,1
   2a63c:	880497fa 	slli	r2,r17,31
   2a640:	4200004c 	andi	r8,r8,1
   2a644:	8822d07a 	srli	r17,r17,1
   2a648:	1a10b03a 	or	r8,r3,r8
   2a64c:	1210b03a 	or	r8,r2,r8
   2a650:	5805883a 	mov	r2,r11
   2a654:	1140ffc4 	addi	r5,r2,1023
   2a658:	0140440e 	bge	zero,r5,2a76c <__muldf3+0x5f4>
   2a65c:	40c001cc 	andi	r3,r8,7
   2a660:	18000726 	beq	r3,zero,2a680 <__muldf3+0x508>
   2a664:	40c003cc 	andi	r3,r8,15
   2a668:	01000104 	movi	r4,4
   2a66c:	19000426 	beq	r3,r4,2a680 <__muldf3+0x508>
   2a670:	4107883a 	add	r3,r8,r4
   2a674:	1a11803a 	cmpltu	r8,r3,r8
   2a678:	8a23883a 	add	r17,r17,r8
   2a67c:	1811883a 	mov	r8,r3
   2a680:	88c0402c 	andhi	r3,r17,256
   2a684:	18000426 	beq	r3,zero,2a698 <__muldf3+0x520>
   2a688:	11410004 	addi	r5,r2,1024
   2a68c:	00bfc034 	movhi	r2,65280
   2a690:	10bfffc4 	addi	r2,r2,-1
   2a694:	88a2703a 	and	r17,r17,r2
   2a698:	0081ff84 	movi	r2,2046
   2a69c:	117f6416 	blt	r2,r5,2a430 <__reset+0xfff8a430>
   2a6a0:	8828977a 	slli	r20,r17,29
   2a6a4:	4010d0fa 	srli	r8,r8,3
   2a6a8:	8822927a 	slli	r17,r17,9
   2a6ac:	2881ffcc 	andi	r2,r5,2047
   2a6b0:	a228b03a 	or	r20,r20,r8
   2a6b4:	880ad33a 	srli	r5,r17,12
   2a6b8:	b02b883a 	mov	r21,r22
   2a6bc:	003f0d06 	br	2a2f4 <__reset+0xfff8a2f4>
   2a6c0:	8080022c 	andhi	r2,r16,8
   2a6c4:	10000926 	beq	r2,zero,2a6ec <__muldf3+0x574>
   2a6c8:	8880022c 	andhi	r2,r17,8
   2a6cc:	1000071e 	bne	r2,zero,2a6ec <__muldf3+0x574>
   2a6d0:	00800434 	movhi	r2,16
   2a6d4:	89400234 	orhi	r5,r17,8
   2a6d8:	10bfffc4 	addi	r2,r2,-1
   2a6dc:	b82b883a 	mov	r21,r23
   2a6e0:	288a703a 	and	r5,r5,r2
   2a6e4:	4029883a 	mov	r20,r8
   2a6e8:	003f6806 	br	2a48c <__reset+0xfff8a48c>
   2a6ec:	00800434 	movhi	r2,16
   2a6f0:	81400234 	orhi	r5,r16,8
   2a6f4:	10bfffc4 	addi	r2,r2,-1
   2a6f8:	288a703a 	and	r5,r5,r2
   2a6fc:	003f6306 	br	2a48c <__reset+0xfff8a48c>
   2a700:	147ff604 	addi	r17,r2,-40
   2a704:	3462983a 	sll	r17,r6,r17
   2a708:	0011883a 	mov	r8,zero
   2a70c:	003f4406 	br	2a420 <__reset+0xfff8a420>
   2a710:	3009883a 	mov	r4,r6
   2a714:	d9800215 	stw	r6,8(sp)
   2a718:	da400115 	stw	r9,4(sp)
   2a71c:	da800015 	stw	r10,0(sp)
   2a720:	002b6480 	call	2b648 <__clzsi2>
   2a724:	10800804 	addi	r2,r2,32
   2a728:	da800017 	ldw	r10,0(sp)
   2a72c:	da400117 	ldw	r9,4(sp)
   2a730:	d9800217 	ldw	r6,8(sp)
   2a734:	003f3006 	br	2a3f8 <__reset+0xfff8a3f8>
   2a738:	143ff604 	addi	r16,r2,-40
   2a73c:	9c20983a 	sll	r16,r19,r16
   2a740:	0029883a 	mov	r20,zero
   2a744:	003f1606 	br	2a3a0 <__reset+0xfff8a3a0>
   2a748:	d9800215 	stw	r6,8(sp)
   2a74c:	d9c00015 	stw	r7,0(sp)
   2a750:	da400115 	stw	r9,4(sp)
   2a754:	002b6480 	call	2b648 <__clzsi2>
   2a758:	10800804 	addi	r2,r2,32
   2a75c:	da400117 	ldw	r9,4(sp)
   2a760:	d9c00017 	ldw	r7,0(sp)
   2a764:	d9800217 	ldw	r6,8(sp)
   2a768:	003f0306 	br	2a378 <__reset+0xfff8a378>
   2a76c:	00c00044 	movi	r3,1
   2a770:	1947c83a 	sub	r3,r3,r5
   2a774:	00800e04 	movi	r2,56
   2a778:	10feda16 	blt	r2,r3,2a2e4 <__reset+0xfff8a2e4>
   2a77c:	008007c4 	movi	r2,31
   2a780:	10c01b16 	blt	r2,r3,2a7f0 <__muldf3+0x678>
   2a784:	00800804 	movi	r2,32
   2a788:	10c5c83a 	sub	r2,r2,r3
   2a78c:	888a983a 	sll	r5,r17,r2
   2a790:	40c8d83a 	srl	r4,r8,r3
   2a794:	4084983a 	sll	r2,r8,r2
   2a798:	88e2d83a 	srl	r17,r17,r3
   2a79c:	2906b03a 	or	r3,r5,r4
   2a7a0:	1004c03a 	cmpne	r2,r2,zero
   2a7a4:	1886b03a 	or	r3,r3,r2
   2a7a8:	188001cc 	andi	r2,r3,7
   2a7ac:	10000726 	beq	r2,zero,2a7cc <__muldf3+0x654>
   2a7b0:	188003cc 	andi	r2,r3,15
   2a7b4:	01000104 	movi	r4,4
   2a7b8:	11000426 	beq	r2,r4,2a7cc <__muldf3+0x654>
   2a7bc:	1805883a 	mov	r2,r3
   2a7c0:	10c00104 	addi	r3,r2,4
   2a7c4:	1885803a 	cmpltu	r2,r3,r2
   2a7c8:	88a3883a 	add	r17,r17,r2
   2a7cc:	8880202c 	andhi	r2,r17,128
   2a7d0:	10001c26 	beq	r2,zero,2a844 <__muldf3+0x6cc>
   2a7d4:	b02b883a 	mov	r21,r22
   2a7d8:	00800044 	movi	r2,1
   2a7dc:	000b883a 	mov	r5,zero
   2a7e0:	0029883a 	mov	r20,zero
   2a7e4:	003ec306 	br	2a2f4 <__reset+0xfff8a2f4>
   2a7e8:	5805883a 	mov	r2,r11
   2a7ec:	003f9906 	br	2a654 <__reset+0xfff8a654>
   2a7f0:	00bff844 	movi	r2,-31
   2a7f4:	1145c83a 	sub	r2,r2,r5
   2a7f8:	8888d83a 	srl	r4,r17,r2
   2a7fc:	00800804 	movi	r2,32
   2a800:	18801a26 	beq	r3,r2,2a86c <__muldf3+0x6f4>
   2a804:	00801004 	movi	r2,64
   2a808:	10c5c83a 	sub	r2,r2,r3
   2a80c:	8884983a 	sll	r2,r17,r2
   2a810:	1204b03a 	or	r2,r2,r8
   2a814:	1004c03a 	cmpne	r2,r2,zero
   2a818:	2084b03a 	or	r2,r4,r2
   2a81c:	144001cc 	andi	r17,r2,7
   2a820:	88000d1e 	bne	r17,zero,2a858 <__muldf3+0x6e0>
   2a824:	000b883a 	mov	r5,zero
   2a828:	1028d0fa 	srli	r20,r2,3
   2a82c:	b02b883a 	mov	r21,r22
   2a830:	0005883a 	mov	r2,zero
   2a834:	a468b03a 	or	r20,r20,r17
   2a838:	003eae06 	br	2a2f4 <__reset+0xfff8a2f4>
   2a83c:	1007883a 	mov	r3,r2
   2a840:	0023883a 	mov	r17,zero
   2a844:	880a927a 	slli	r5,r17,9
   2a848:	1805883a 	mov	r2,r3
   2a84c:	8822977a 	slli	r17,r17,29
   2a850:	280ad33a 	srli	r5,r5,12
   2a854:	003ff406 	br	2a828 <__reset+0xfff8a828>
   2a858:	10c003cc 	andi	r3,r2,15
   2a85c:	01000104 	movi	r4,4
   2a860:	193ff626 	beq	r3,r4,2a83c <__reset+0xfff8a83c>
   2a864:	0023883a 	mov	r17,zero
   2a868:	003fd506 	br	2a7c0 <__reset+0xfff8a7c0>
   2a86c:	0005883a 	mov	r2,zero
   2a870:	003fe706 	br	2a810 <__reset+0xfff8a810>
   2a874:	00800434 	movhi	r2,16
   2a878:	89400234 	orhi	r5,r17,8
   2a87c:	10bfffc4 	addi	r2,r2,-1
   2a880:	b02b883a 	mov	r21,r22
   2a884:	288a703a 	and	r5,r5,r2
   2a888:	4029883a 	mov	r20,r8
   2a88c:	003eff06 	br	2a48c <__reset+0xfff8a48c>

0002a890 <__subdf3>:
   2a890:	02000434 	movhi	r8,16
   2a894:	423fffc4 	addi	r8,r8,-1
   2a898:	defffb04 	addi	sp,sp,-20
   2a89c:	2a14703a 	and	r10,r5,r8
   2a8a0:	3812d53a 	srli	r9,r7,20
   2a8a4:	3a10703a 	and	r8,r7,r8
   2a8a8:	2006d77a 	srli	r3,r4,29
   2a8ac:	3004d77a 	srli	r2,r6,29
   2a8b0:	dc000015 	stw	r16,0(sp)
   2a8b4:	501490fa 	slli	r10,r10,3
   2a8b8:	2820d53a 	srli	r16,r5,20
   2a8bc:	401090fa 	slli	r8,r8,3
   2a8c0:	dc800215 	stw	r18,8(sp)
   2a8c4:	dc400115 	stw	r17,4(sp)
   2a8c8:	dfc00415 	stw	ra,16(sp)
   2a8cc:	202290fa 	slli	r17,r4,3
   2a8d0:	dcc00315 	stw	r19,12(sp)
   2a8d4:	4a41ffcc 	andi	r9,r9,2047
   2a8d8:	0101ffc4 	movi	r4,2047
   2a8dc:	2824d7fa 	srli	r18,r5,31
   2a8e0:	8401ffcc 	andi	r16,r16,2047
   2a8e4:	50c6b03a 	or	r3,r10,r3
   2a8e8:	380ed7fa 	srli	r7,r7,31
   2a8ec:	408ab03a 	or	r5,r8,r2
   2a8f0:	300c90fa 	slli	r6,r6,3
   2a8f4:	49009626 	beq	r9,r4,2ab50 <__subdf3+0x2c0>
   2a8f8:	39c0005c 	xori	r7,r7,1
   2a8fc:	8245c83a 	sub	r2,r16,r9
   2a900:	3c807426 	beq	r7,r18,2aad4 <__subdf3+0x244>
   2a904:	0080af0e 	bge	zero,r2,2abc4 <__subdf3+0x334>
   2a908:	48002a1e 	bne	r9,zero,2a9b4 <__subdf3+0x124>
   2a90c:	2988b03a 	or	r4,r5,r6
   2a910:	20009a1e 	bne	r4,zero,2ab7c <__subdf3+0x2ec>
   2a914:	888001cc 	andi	r2,r17,7
   2a918:	10000726 	beq	r2,zero,2a938 <__subdf3+0xa8>
   2a91c:	888003cc 	andi	r2,r17,15
   2a920:	01000104 	movi	r4,4
   2a924:	11000426 	beq	r2,r4,2a938 <__subdf3+0xa8>
   2a928:	890b883a 	add	r5,r17,r4
   2a92c:	2c63803a 	cmpltu	r17,r5,r17
   2a930:	1c47883a 	add	r3,r3,r17
   2a934:	2823883a 	mov	r17,r5
   2a938:	1880202c 	andhi	r2,r3,128
   2a93c:	10005926 	beq	r2,zero,2aaa4 <__subdf3+0x214>
   2a940:	84000044 	addi	r16,r16,1
   2a944:	0081ffc4 	movi	r2,2047
   2a948:	8080be26 	beq	r16,r2,2ac44 <__subdf3+0x3b4>
   2a94c:	017fe034 	movhi	r5,65408
   2a950:	297fffc4 	addi	r5,r5,-1
   2a954:	1946703a 	and	r3,r3,r5
   2a958:	1804977a 	slli	r2,r3,29
   2a95c:	1806927a 	slli	r3,r3,9
   2a960:	8822d0fa 	srli	r17,r17,3
   2a964:	8401ffcc 	andi	r16,r16,2047
   2a968:	180ad33a 	srli	r5,r3,12
   2a96c:	9100004c 	andi	r4,r18,1
   2a970:	1444b03a 	or	r2,r2,r17
   2a974:	80c1ffcc 	andi	r3,r16,2047
   2a978:	1820953a 	slli	r16,r3,20
   2a97c:	20c03fcc 	andi	r3,r4,255
   2a980:	180897fa 	slli	r4,r3,31
   2a984:	00c00434 	movhi	r3,16
   2a988:	18ffffc4 	addi	r3,r3,-1
   2a98c:	28c6703a 	and	r3,r5,r3
   2a990:	1c06b03a 	or	r3,r3,r16
   2a994:	1906b03a 	or	r3,r3,r4
   2a998:	dfc00417 	ldw	ra,16(sp)
   2a99c:	dcc00317 	ldw	r19,12(sp)
   2a9a0:	dc800217 	ldw	r18,8(sp)
   2a9a4:	dc400117 	ldw	r17,4(sp)
   2a9a8:	dc000017 	ldw	r16,0(sp)
   2a9ac:	dec00504 	addi	sp,sp,20
   2a9b0:	f800283a 	ret
   2a9b4:	0101ffc4 	movi	r4,2047
   2a9b8:	813fd626 	beq	r16,r4,2a914 <__reset+0xfff8a914>
   2a9bc:	29402034 	orhi	r5,r5,128
   2a9c0:	01000e04 	movi	r4,56
   2a9c4:	2080a316 	blt	r4,r2,2ac54 <__subdf3+0x3c4>
   2a9c8:	010007c4 	movi	r4,31
   2a9cc:	2080c616 	blt	r4,r2,2ace8 <__subdf3+0x458>
   2a9d0:	01000804 	movi	r4,32
   2a9d4:	2089c83a 	sub	r4,r4,r2
   2a9d8:	2910983a 	sll	r8,r5,r4
   2a9dc:	308ed83a 	srl	r7,r6,r2
   2a9e0:	3108983a 	sll	r4,r6,r4
   2a9e4:	2884d83a 	srl	r2,r5,r2
   2a9e8:	41ccb03a 	or	r6,r8,r7
   2a9ec:	2008c03a 	cmpne	r4,r4,zero
   2a9f0:	310cb03a 	or	r6,r6,r4
   2a9f4:	898dc83a 	sub	r6,r17,r6
   2a9f8:	89a3803a 	cmpltu	r17,r17,r6
   2a9fc:	1887c83a 	sub	r3,r3,r2
   2aa00:	1c47c83a 	sub	r3,r3,r17
   2aa04:	3023883a 	mov	r17,r6
   2aa08:	1880202c 	andhi	r2,r3,128
   2aa0c:	10002326 	beq	r2,zero,2aa9c <__subdf3+0x20c>
   2aa10:	04c02034 	movhi	r19,128
   2aa14:	9cffffc4 	addi	r19,r19,-1
   2aa18:	1ce6703a 	and	r19,r3,r19
   2aa1c:	98007a26 	beq	r19,zero,2ac08 <__subdf3+0x378>
   2aa20:	9809883a 	mov	r4,r19
   2aa24:	002b6480 	call	2b648 <__clzsi2>
   2aa28:	113ffe04 	addi	r4,r2,-8
   2aa2c:	00c007c4 	movi	r3,31
   2aa30:	19007b16 	blt	r3,r4,2ac20 <__subdf3+0x390>
   2aa34:	00800804 	movi	r2,32
   2aa38:	1105c83a 	sub	r2,r2,r4
   2aa3c:	8884d83a 	srl	r2,r17,r2
   2aa40:	9906983a 	sll	r3,r19,r4
   2aa44:	8922983a 	sll	r17,r17,r4
   2aa48:	10c4b03a 	or	r2,r2,r3
   2aa4c:	24007816 	blt	r4,r16,2ac30 <__subdf3+0x3a0>
   2aa50:	2421c83a 	sub	r16,r4,r16
   2aa54:	80c00044 	addi	r3,r16,1
   2aa58:	010007c4 	movi	r4,31
   2aa5c:	20c09516 	blt	r4,r3,2acb4 <__subdf3+0x424>
   2aa60:	01400804 	movi	r5,32
   2aa64:	28cbc83a 	sub	r5,r5,r3
   2aa68:	88c8d83a 	srl	r4,r17,r3
   2aa6c:	8962983a 	sll	r17,r17,r5
   2aa70:	114a983a 	sll	r5,r2,r5
   2aa74:	10c6d83a 	srl	r3,r2,r3
   2aa78:	8804c03a 	cmpne	r2,r17,zero
   2aa7c:	290ab03a 	or	r5,r5,r4
   2aa80:	28a2b03a 	or	r17,r5,r2
   2aa84:	0021883a 	mov	r16,zero
   2aa88:	003fa206 	br	2a914 <__reset+0xfff8a914>
   2aa8c:	2090b03a 	or	r8,r4,r2
   2aa90:	40018e26 	beq	r8,zero,2b0cc <__subdf3+0x83c>
   2aa94:	1007883a 	mov	r3,r2
   2aa98:	2023883a 	mov	r17,r4
   2aa9c:	888001cc 	andi	r2,r17,7
   2aaa0:	103f9e1e 	bne	r2,zero,2a91c <__reset+0xfff8a91c>
   2aaa4:	1804977a 	slli	r2,r3,29
   2aaa8:	8822d0fa 	srli	r17,r17,3
   2aaac:	1810d0fa 	srli	r8,r3,3
   2aab0:	9100004c 	andi	r4,r18,1
   2aab4:	1444b03a 	or	r2,r2,r17
   2aab8:	00c1ffc4 	movi	r3,2047
   2aabc:	80c02826 	beq	r16,r3,2ab60 <__subdf3+0x2d0>
   2aac0:	01400434 	movhi	r5,16
   2aac4:	297fffc4 	addi	r5,r5,-1
   2aac8:	80e0703a 	and	r16,r16,r3
   2aacc:	414a703a 	and	r5,r8,r5
   2aad0:	003fa806 	br	2a974 <__reset+0xfff8a974>
   2aad4:	0080630e 	bge	zero,r2,2ac64 <__subdf3+0x3d4>
   2aad8:	48003026 	beq	r9,zero,2ab9c <__subdf3+0x30c>
   2aadc:	0101ffc4 	movi	r4,2047
   2aae0:	813f8c26 	beq	r16,r4,2a914 <__reset+0xfff8a914>
   2aae4:	29402034 	orhi	r5,r5,128
   2aae8:	01000e04 	movi	r4,56
   2aaec:	2080a90e 	bge	r4,r2,2ad94 <__subdf3+0x504>
   2aaf0:	298cb03a 	or	r6,r5,r6
   2aaf4:	3012c03a 	cmpne	r9,r6,zero
   2aaf8:	0005883a 	mov	r2,zero
   2aafc:	4c53883a 	add	r9,r9,r17
   2ab00:	4c63803a 	cmpltu	r17,r9,r17
   2ab04:	10c7883a 	add	r3,r2,r3
   2ab08:	88c7883a 	add	r3,r17,r3
   2ab0c:	4823883a 	mov	r17,r9
   2ab10:	1880202c 	andhi	r2,r3,128
   2ab14:	1000d026 	beq	r2,zero,2ae58 <__subdf3+0x5c8>
   2ab18:	84000044 	addi	r16,r16,1
   2ab1c:	0081ffc4 	movi	r2,2047
   2ab20:	8080fe26 	beq	r16,r2,2af1c <__subdf3+0x68c>
   2ab24:	00bfe034 	movhi	r2,65408
   2ab28:	10bfffc4 	addi	r2,r2,-1
   2ab2c:	1886703a 	and	r3,r3,r2
   2ab30:	880ad07a 	srli	r5,r17,1
   2ab34:	180497fa 	slli	r2,r3,31
   2ab38:	8900004c 	andi	r4,r17,1
   2ab3c:	2922b03a 	or	r17,r5,r4
   2ab40:	1806d07a 	srli	r3,r3,1
   2ab44:	1462b03a 	or	r17,r2,r17
   2ab48:	3825883a 	mov	r18,r7
   2ab4c:	003f7106 	br	2a914 <__reset+0xfff8a914>
   2ab50:	2984b03a 	or	r2,r5,r6
   2ab54:	103f6826 	beq	r2,zero,2a8f8 <__reset+0xfff8a8f8>
   2ab58:	39c03fcc 	andi	r7,r7,255
   2ab5c:	003f6706 	br	2a8fc <__reset+0xfff8a8fc>
   2ab60:	4086b03a 	or	r3,r8,r2
   2ab64:	18015226 	beq	r3,zero,2b0b0 <__subdf3+0x820>
   2ab68:	00c00434 	movhi	r3,16
   2ab6c:	41400234 	orhi	r5,r8,8
   2ab70:	18ffffc4 	addi	r3,r3,-1
   2ab74:	28ca703a 	and	r5,r5,r3
   2ab78:	003f7e06 	br	2a974 <__reset+0xfff8a974>
   2ab7c:	10bfffc4 	addi	r2,r2,-1
   2ab80:	1000491e 	bne	r2,zero,2aca8 <__subdf3+0x418>
   2ab84:	898fc83a 	sub	r7,r17,r6
   2ab88:	89e3803a 	cmpltu	r17,r17,r7
   2ab8c:	1947c83a 	sub	r3,r3,r5
   2ab90:	1c47c83a 	sub	r3,r3,r17
   2ab94:	3823883a 	mov	r17,r7
   2ab98:	003f9b06 	br	2aa08 <__reset+0xfff8aa08>
   2ab9c:	2988b03a 	or	r4,r5,r6
   2aba0:	203f5c26 	beq	r4,zero,2a914 <__reset+0xfff8a914>
   2aba4:	10bfffc4 	addi	r2,r2,-1
   2aba8:	1000931e 	bne	r2,zero,2adf8 <__subdf3+0x568>
   2abac:	898d883a 	add	r6,r17,r6
   2abb0:	3463803a 	cmpltu	r17,r6,r17
   2abb4:	1947883a 	add	r3,r3,r5
   2abb8:	88c7883a 	add	r3,r17,r3
   2abbc:	3023883a 	mov	r17,r6
   2abc0:	003fd306 	br	2ab10 <__reset+0xfff8ab10>
   2abc4:	1000541e 	bne	r2,zero,2ad18 <__subdf3+0x488>
   2abc8:	80800044 	addi	r2,r16,1
   2abcc:	1081ffcc 	andi	r2,r2,2047
   2abd0:	01000044 	movi	r4,1
   2abd4:	2080a20e 	bge	r4,r2,2ae60 <__subdf3+0x5d0>
   2abd8:	8989c83a 	sub	r4,r17,r6
   2abdc:	8905803a 	cmpltu	r2,r17,r4
   2abe0:	1967c83a 	sub	r19,r3,r5
   2abe4:	98a7c83a 	sub	r19,r19,r2
   2abe8:	9880202c 	andhi	r2,r19,128
   2abec:	10006326 	beq	r2,zero,2ad7c <__subdf3+0x4ec>
   2abf0:	3463c83a 	sub	r17,r6,r17
   2abf4:	28c7c83a 	sub	r3,r5,r3
   2abf8:	344d803a 	cmpltu	r6,r6,r17
   2abfc:	19a7c83a 	sub	r19,r3,r6
   2ac00:	3825883a 	mov	r18,r7
   2ac04:	983f861e 	bne	r19,zero,2aa20 <__reset+0xfff8aa20>
   2ac08:	8809883a 	mov	r4,r17
   2ac0c:	002b6480 	call	2b648 <__clzsi2>
   2ac10:	10800804 	addi	r2,r2,32
   2ac14:	113ffe04 	addi	r4,r2,-8
   2ac18:	00c007c4 	movi	r3,31
   2ac1c:	193f850e 	bge	r3,r4,2aa34 <__reset+0xfff8aa34>
   2ac20:	10bff604 	addi	r2,r2,-40
   2ac24:	8884983a 	sll	r2,r17,r2
   2ac28:	0023883a 	mov	r17,zero
   2ac2c:	243f880e 	bge	r4,r16,2aa50 <__reset+0xfff8aa50>
   2ac30:	00ffe034 	movhi	r3,65408
   2ac34:	18ffffc4 	addi	r3,r3,-1
   2ac38:	8121c83a 	sub	r16,r16,r4
   2ac3c:	10c6703a 	and	r3,r2,r3
   2ac40:	003f3406 	br	2a914 <__reset+0xfff8a914>
   2ac44:	9100004c 	andi	r4,r18,1
   2ac48:	000b883a 	mov	r5,zero
   2ac4c:	0005883a 	mov	r2,zero
   2ac50:	003f4806 	br	2a974 <__reset+0xfff8a974>
   2ac54:	298cb03a 	or	r6,r5,r6
   2ac58:	300cc03a 	cmpne	r6,r6,zero
   2ac5c:	0005883a 	mov	r2,zero
   2ac60:	003f6406 	br	2a9f4 <__reset+0xfff8a9f4>
   2ac64:	10009a1e 	bne	r2,zero,2aed0 <__subdf3+0x640>
   2ac68:	82400044 	addi	r9,r16,1
   2ac6c:	4881ffcc 	andi	r2,r9,2047
   2ac70:	02800044 	movi	r10,1
   2ac74:	5080670e 	bge	r10,r2,2ae14 <__subdf3+0x584>
   2ac78:	0081ffc4 	movi	r2,2047
   2ac7c:	4880af26 	beq	r9,r2,2af3c <__subdf3+0x6ac>
   2ac80:	898d883a 	add	r6,r17,r6
   2ac84:	1945883a 	add	r2,r3,r5
   2ac88:	3447803a 	cmpltu	r3,r6,r17
   2ac8c:	1887883a 	add	r3,r3,r2
   2ac90:	182297fa 	slli	r17,r3,31
   2ac94:	300cd07a 	srli	r6,r6,1
   2ac98:	1806d07a 	srli	r3,r3,1
   2ac9c:	4821883a 	mov	r16,r9
   2aca0:	89a2b03a 	or	r17,r17,r6
   2aca4:	003f1b06 	br	2a914 <__reset+0xfff8a914>
   2aca8:	0101ffc4 	movi	r4,2047
   2acac:	813f441e 	bne	r16,r4,2a9c0 <__reset+0xfff8a9c0>
   2acb0:	003f1806 	br	2a914 <__reset+0xfff8a914>
   2acb4:	843ff844 	addi	r16,r16,-31
   2acb8:	01400804 	movi	r5,32
   2acbc:	1408d83a 	srl	r4,r2,r16
   2acc0:	19405026 	beq	r3,r5,2ae04 <__subdf3+0x574>
   2acc4:	01401004 	movi	r5,64
   2acc8:	28c7c83a 	sub	r3,r5,r3
   2accc:	10c4983a 	sll	r2,r2,r3
   2acd0:	88a2b03a 	or	r17,r17,r2
   2acd4:	8822c03a 	cmpne	r17,r17,zero
   2acd8:	2462b03a 	or	r17,r4,r17
   2acdc:	0007883a 	mov	r3,zero
   2ace0:	0021883a 	mov	r16,zero
   2ace4:	003f6d06 	br	2aa9c <__reset+0xfff8aa9c>
   2ace8:	11fff804 	addi	r7,r2,-32
   2acec:	01000804 	movi	r4,32
   2acf0:	29ced83a 	srl	r7,r5,r7
   2acf4:	11004526 	beq	r2,r4,2ae0c <__subdf3+0x57c>
   2acf8:	01001004 	movi	r4,64
   2acfc:	2089c83a 	sub	r4,r4,r2
   2ad00:	2904983a 	sll	r2,r5,r4
   2ad04:	118cb03a 	or	r6,r2,r6
   2ad08:	300cc03a 	cmpne	r6,r6,zero
   2ad0c:	398cb03a 	or	r6,r7,r6
   2ad10:	0005883a 	mov	r2,zero
   2ad14:	003f3706 	br	2a9f4 <__reset+0xfff8a9f4>
   2ad18:	80002a26 	beq	r16,zero,2adc4 <__subdf3+0x534>
   2ad1c:	0101ffc4 	movi	r4,2047
   2ad20:	49006626 	beq	r9,r4,2aebc <__subdf3+0x62c>
   2ad24:	0085c83a 	sub	r2,zero,r2
   2ad28:	18c02034 	orhi	r3,r3,128
   2ad2c:	01000e04 	movi	r4,56
   2ad30:	20807e16 	blt	r4,r2,2af2c <__subdf3+0x69c>
   2ad34:	010007c4 	movi	r4,31
   2ad38:	2080e716 	blt	r4,r2,2b0d8 <__subdf3+0x848>
   2ad3c:	01000804 	movi	r4,32
   2ad40:	2089c83a 	sub	r4,r4,r2
   2ad44:	1914983a 	sll	r10,r3,r4
   2ad48:	8890d83a 	srl	r8,r17,r2
   2ad4c:	8908983a 	sll	r4,r17,r4
   2ad50:	1884d83a 	srl	r2,r3,r2
   2ad54:	5222b03a 	or	r17,r10,r8
   2ad58:	2006c03a 	cmpne	r3,r4,zero
   2ad5c:	88e2b03a 	or	r17,r17,r3
   2ad60:	3463c83a 	sub	r17,r6,r17
   2ad64:	2885c83a 	sub	r2,r5,r2
   2ad68:	344d803a 	cmpltu	r6,r6,r17
   2ad6c:	1187c83a 	sub	r3,r2,r6
   2ad70:	4821883a 	mov	r16,r9
   2ad74:	3825883a 	mov	r18,r7
   2ad78:	003f2306 	br	2aa08 <__reset+0xfff8aa08>
   2ad7c:	24d0b03a 	or	r8,r4,r19
   2ad80:	40001b1e 	bne	r8,zero,2adf0 <__subdf3+0x560>
   2ad84:	0005883a 	mov	r2,zero
   2ad88:	0009883a 	mov	r4,zero
   2ad8c:	0021883a 	mov	r16,zero
   2ad90:	003f4906 	br	2aab8 <__reset+0xfff8aab8>
   2ad94:	010007c4 	movi	r4,31
   2ad98:	20803a16 	blt	r4,r2,2ae84 <__subdf3+0x5f4>
   2ad9c:	01000804 	movi	r4,32
   2ada0:	2089c83a 	sub	r4,r4,r2
   2ada4:	2912983a 	sll	r9,r5,r4
   2ada8:	3090d83a 	srl	r8,r6,r2
   2adac:	3108983a 	sll	r4,r6,r4
   2adb0:	2884d83a 	srl	r2,r5,r2
   2adb4:	4a12b03a 	or	r9,r9,r8
   2adb8:	2008c03a 	cmpne	r4,r4,zero
   2adbc:	4912b03a 	or	r9,r9,r4
   2adc0:	003f4e06 	br	2aafc <__reset+0xfff8aafc>
   2adc4:	1c48b03a 	or	r4,r3,r17
   2adc8:	20003c26 	beq	r4,zero,2aebc <__subdf3+0x62c>
   2adcc:	0084303a 	nor	r2,zero,r2
   2add0:	1000381e 	bne	r2,zero,2aeb4 <__subdf3+0x624>
   2add4:	3463c83a 	sub	r17,r6,r17
   2add8:	28c5c83a 	sub	r2,r5,r3
   2addc:	344d803a 	cmpltu	r6,r6,r17
   2ade0:	1187c83a 	sub	r3,r2,r6
   2ade4:	4821883a 	mov	r16,r9
   2ade8:	3825883a 	mov	r18,r7
   2adec:	003f0606 	br	2aa08 <__reset+0xfff8aa08>
   2adf0:	2023883a 	mov	r17,r4
   2adf4:	003f0906 	br	2aa1c <__reset+0xfff8aa1c>
   2adf8:	0101ffc4 	movi	r4,2047
   2adfc:	813f3a1e 	bne	r16,r4,2aae8 <__reset+0xfff8aae8>
   2ae00:	003ec406 	br	2a914 <__reset+0xfff8a914>
   2ae04:	0005883a 	mov	r2,zero
   2ae08:	003fb106 	br	2acd0 <__reset+0xfff8acd0>
   2ae0c:	0005883a 	mov	r2,zero
   2ae10:	003fbc06 	br	2ad04 <__reset+0xfff8ad04>
   2ae14:	1c44b03a 	or	r2,r3,r17
   2ae18:	80008e1e 	bne	r16,zero,2b054 <__subdf3+0x7c4>
   2ae1c:	1000c826 	beq	r2,zero,2b140 <__subdf3+0x8b0>
   2ae20:	2984b03a 	or	r2,r5,r6
   2ae24:	103ebb26 	beq	r2,zero,2a914 <__reset+0xfff8a914>
   2ae28:	8989883a 	add	r4,r17,r6
   2ae2c:	1945883a 	add	r2,r3,r5
   2ae30:	2447803a 	cmpltu	r3,r4,r17
   2ae34:	1887883a 	add	r3,r3,r2
   2ae38:	1880202c 	andhi	r2,r3,128
   2ae3c:	2023883a 	mov	r17,r4
   2ae40:	103f1626 	beq	r2,zero,2aa9c <__reset+0xfff8aa9c>
   2ae44:	00bfe034 	movhi	r2,65408
   2ae48:	10bfffc4 	addi	r2,r2,-1
   2ae4c:	5021883a 	mov	r16,r10
   2ae50:	1886703a 	and	r3,r3,r2
   2ae54:	003eaf06 	br	2a914 <__reset+0xfff8a914>
   2ae58:	3825883a 	mov	r18,r7
   2ae5c:	003f0f06 	br	2aa9c <__reset+0xfff8aa9c>
   2ae60:	1c44b03a 	or	r2,r3,r17
   2ae64:	8000251e 	bne	r16,zero,2aefc <__subdf3+0x66c>
   2ae68:	1000661e 	bne	r2,zero,2b004 <__subdf3+0x774>
   2ae6c:	2990b03a 	or	r8,r5,r6
   2ae70:	40009626 	beq	r8,zero,2b0cc <__subdf3+0x83c>
   2ae74:	2807883a 	mov	r3,r5
   2ae78:	3023883a 	mov	r17,r6
   2ae7c:	3825883a 	mov	r18,r7
   2ae80:	003ea406 	br	2a914 <__reset+0xfff8a914>
   2ae84:	127ff804 	addi	r9,r2,-32
   2ae88:	01000804 	movi	r4,32
   2ae8c:	2a52d83a 	srl	r9,r5,r9
   2ae90:	11008c26 	beq	r2,r4,2b0c4 <__subdf3+0x834>
   2ae94:	01001004 	movi	r4,64
   2ae98:	2085c83a 	sub	r2,r4,r2
   2ae9c:	2884983a 	sll	r2,r5,r2
   2aea0:	118cb03a 	or	r6,r2,r6
   2aea4:	300cc03a 	cmpne	r6,r6,zero
   2aea8:	4992b03a 	or	r9,r9,r6
   2aeac:	0005883a 	mov	r2,zero
   2aeb0:	003f1206 	br	2aafc <__reset+0xfff8aafc>
   2aeb4:	0101ffc4 	movi	r4,2047
   2aeb8:	493f9c1e 	bne	r9,r4,2ad2c <__reset+0xfff8ad2c>
   2aebc:	2807883a 	mov	r3,r5
   2aec0:	3023883a 	mov	r17,r6
   2aec4:	4821883a 	mov	r16,r9
   2aec8:	3825883a 	mov	r18,r7
   2aecc:	003e9106 	br	2a914 <__reset+0xfff8a914>
   2aed0:	80001f1e 	bne	r16,zero,2af50 <__subdf3+0x6c0>
   2aed4:	1c48b03a 	or	r4,r3,r17
   2aed8:	20005a26 	beq	r4,zero,2b044 <__subdf3+0x7b4>
   2aedc:	0084303a 	nor	r2,zero,r2
   2aee0:	1000561e 	bne	r2,zero,2b03c <__subdf3+0x7ac>
   2aee4:	89a3883a 	add	r17,r17,r6
   2aee8:	1945883a 	add	r2,r3,r5
   2aeec:	898d803a 	cmpltu	r6,r17,r6
   2aef0:	3087883a 	add	r3,r6,r2
   2aef4:	4821883a 	mov	r16,r9
   2aef8:	003f0506 	br	2ab10 <__reset+0xfff8ab10>
   2aefc:	10002b1e 	bne	r2,zero,2afac <__subdf3+0x71c>
   2af00:	2984b03a 	or	r2,r5,r6
   2af04:	10008026 	beq	r2,zero,2b108 <__subdf3+0x878>
   2af08:	2807883a 	mov	r3,r5
   2af0c:	3023883a 	mov	r17,r6
   2af10:	3825883a 	mov	r18,r7
   2af14:	0401ffc4 	movi	r16,2047
   2af18:	003e7e06 	br	2a914 <__reset+0xfff8a914>
   2af1c:	3809883a 	mov	r4,r7
   2af20:	0011883a 	mov	r8,zero
   2af24:	0005883a 	mov	r2,zero
   2af28:	003ee306 	br	2aab8 <__reset+0xfff8aab8>
   2af2c:	1c62b03a 	or	r17,r3,r17
   2af30:	8822c03a 	cmpne	r17,r17,zero
   2af34:	0005883a 	mov	r2,zero
   2af38:	003f8906 	br	2ad60 <__reset+0xfff8ad60>
   2af3c:	3809883a 	mov	r4,r7
   2af40:	4821883a 	mov	r16,r9
   2af44:	0011883a 	mov	r8,zero
   2af48:	0005883a 	mov	r2,zero
   2af4c:	003eda06 	br	2aab8 <__reset+0xfff8aab8>
   2af50:	0101ffc4 	movi	r4,2047
   2af54:	49003b26 	beq	r9,r4,2b044 <__subdf3+0x7b4>
   2af58:	0085c83a 	sub	r2,zero,r2
   2af5c:	18c02034 	orhi	r3,r3,128
   2af60:	01000e04 	movi	r4,56
   2af64:	20806e16 	blt	r4,r2,2b120 <__subdf3+0x890>
   2af68:	010007c4 	movi	r4,31
   2af6c:	20807716 	blt	r4,r2,2b14c <__subdf3+0x8bc>
   2af70:	01000804 	movi	r4,32
   2af74:	2089c83a 	sub	r4,r4,r2
   2af78:	1914983a 	sll	r10,r3,r4
   2af7c:	8890d83a 	srl	r8,r17,r2
   2af80:	8908983a 	sll	r4,r17,r4
   2af84:	1884d83a 	srl	r2,r3,r2
   2af88:	5222b03a 	or	r17,r10,r8
   2af8c:	2006c03a 	cmpne	r3,r4,zero
   2af90:	88e2b03a 	or	r17,r17,r3
   2af94:	89a3883a 	add	r17,r17,r6
   2af98:	1145883a 	add	r2,r2,r5
   2af9c:	898d803a 	cmpltu	r6,r17,r6
   2afa0:	3087883a 	add	r3,r6,r2
   2afa4:	4821883a 	mov	r16,r9
   2afa8:	003ed906 	br	2ab10 <__reset+0xfff8ab10>
   2afac:	2984b03a 	or	r2,r5,r6
   2afb0:	10004226 	beq	r2,zero,2b0bc <__subdf3+0x82c>
   2afb4:	1808d0fa 	srli	r4,r3,3
   2afb8:	8822d0fa 	srli	r17,r17,3
   2afbc:	1806977a 	slli	r3,r3,29
   2afc0:	2080022c 	andhi	r2,r4,8
   2afc4:	1c62b03a 	or	r17,r3,r17
   2afc8:	10000826 	beq	r2,zero,2afec <__subdf3+0x75c>
   2afcc:	2812d0fa 	srli	r9,r5,3
   2afd0:	4880022c 	andhi	r2,r9,8
   2afd4:	1000051e 	bne	r2,zero,2afec <__subdf3+0x75c>
   2afd8:	300cd0fa 	srli	r6,r6,3
   2afdc:	2804977a 	slli	r2,r5,29
   2afe0:	4809883a 	mov	r4,r9
   2afe4:	3825883a 	mov	r18,r7
   2afe8:	11a2b03a 	or	r17,r2,r6
   2afec:	8806d77a 	srli	r3,r17,29
   2aff0:	200890fa 	slli	r4,r4,3
   2aff4:	882290fa 	slli	r17,r17,3
   2aff8:	0401ffc4 	movi	r16,2047
   2affc:	1906b03a 	or	r3,r3,r4
   2b000:	003e4406 	br	2a914 <__reset+0xfff8a914>
   2b004:	2984b03a 	or	r2,r5,r6
   2b008:	103e4226 	beq	r2,zero,2a914 <__reset+0xfff8a914>
   2b00c:	8989c83a 	sub	r4,r17,r6
   2b010:	8911803a 	cmpltu	r8,r17,r4
   2b014:	1945c83a 	sub	r2,r3,r5
   2b018:	1205c83a 	sub	r2,r2,r8
   2b01c:	1200202c 	andhi	r8,r2,128
   2b020:	403e9a26 	beq	r8,zero,2aa8c <__reset+0xfff8aa8c>
   2b024:	3463c83a 	sub	r17,r6,r17
   2b028:	28c5c83a 	sub	r2,r5,r3
   2b02c:	344d803a 	cmpltu	r6,r6,r17
   2b030:	1187c83a 	sub	r3,r2,r6
   2b034:	3825883a 	mov	r18,r7
   2b038:	003e3606 	br	2a914 <__reset+0xfff8a914>
   2b03c:	0101ffc4 	movi	r4,2047
   2b040:	493fc71e 	bne	r9,r4,2af60 <__reset+0xfff8af60>
   2b044:	2807883a 	mov	r3,r5
   2b048:	3023883a 	mov	r17,r6
   2b04c:	4821883a 	mov	r16,r9
   2b050:	003e3006 	br	2a914 <__reset+0xfff8a914>
   2b054:	10003626 	beq	r2,zero,2b130 <__subdf3+0x8a0>
   2b058:	2984b03a 	or	r2,r5,r6
   2b05c:	10001726 	beq	r2,zero,2b0bc <__subdf3+0x82c>
   2b060:	1808d0fa 	srli	r4,r3,3
   2b064:	8822d0fa 	srli	r17,r17,3
   2b068:	1806977a 	slli	r3,r3,29
   2b06c:	2080022c 	andhi	r2,r4,8
   2b070:	1c62b03a 	or	r17,r3,r17
   2b074:	10000726 	beq	r2,zero,2b094 <__subdf3+0x804>
   2b078:	2812d0fa 	srli	r9,r5,3
   2b07c:	4880022c 	andhi	r2,r9,8
   2b080:	1000041e 	bne	r2,zero,2b094 <__subdf3+0x804>
   2b084:	300cd0fa 	srli	r6,r6,3
   2b088:	2804977a 	slli	r2,r5,29
   2b08c:	4809883a 	mov	r4,r9
   2b090:	11a2b03a 	or	r17,r2,r6
   2b094:	8806d77a 	srli	r3,r17,29
   2b098:	200890fa 	slli	r4,r4,3
   2b09c:	882290fa 	slli	r17,r17,3
   2b0a0:	3825883a 	mov	r18,r7
   2b0a4:	1906b03a 	or	r3,r3,r4
   2b0a8:	0401ffc4 	movi	r16,2047
   2b0ac:	003e1906 	br	2a914 <__reset+0xfff8a914>
   2b0b0:	000b883a 	mov	r5,zero
   2b0b4:	0005883a 	mov	r2,zero
   2b0b8:	003e2e06 	br	2a974 <__reset+0xfff8a974>
   2b0bc:	0401ffc4 	movi	r16,2047
   2b0c0:	003e1406 	br	2a914 <__reset+0xfff8a914>
   2b0c4:	0005883a 	mov	r2,zero
   2b0c8:	003f7506 	br	2aea0 <__reset+0xfff8aea0>
   2b0cc:	0005883a 	mov	r2,zero
   2b0d0:	0009883a 	mov	r4,zero
   2b0d4:	003e7806 	br	2aab8 <__reset+0xfff8aab8>
   2b0d8:	123ff804 	addi	r8,r2,-32
   2b0dc:	01000804 	movi	r4,32
   2b0e0:	1a10d83a 	srl	r8,r3,r8
   2b0e4:	11002526 	beq	r2,r4,2b17c <__subdf3+0x8ec>
   2b0e8:	01001004 	movi	r4,64
   2b0ec:	2085c83a 	sub	r2,r4,r2
   2b0f0:	1884983a 	sll	r2,r3,r2
   2b0f4:	1444b03a 	or	r2,r2,r17
   2b0f8:	1004c03a 	cmpne	r2,r2,zero
   2b0fc:	40a2b03a 	or	r17,r8,r2
   2b100:	0005883a 	mov	r2,zero
   2b104:	003f1606 	br	2ad60 <__reset+0xfff8ad60>
   2b108:	02000434 	movhi	r8,16
   2b10c:	0009883a 	mov	r4,zero
   2b110:	423fffc4 	addi	r8,r8,-1
   2b114:	00bfffc4 	movi	r2,-1
   2b118:	0401ffc4 	movi	r16,2047
   2b11c:	003e6606 	br	2aab8 <__reset+0xfff8aab8>
   2b120:	1c62b03a 	or	r17,r3,r17
   2b124:	8822c03a 	cmpne	r17,r17,zero
   2b128:	0005883a 	mov	r2,zero
   2b12c:	003f9906 	br	2af94 <__reset+0xfff8af94>
   2b130:	2807883a 	mov	r3,r5
   2b134:	3023883a 	mov	r17,r6
   2b138:	0401ffc4 	movi	r16,2047
   2b13c:	003df506 	br	2a914 <__reset+0xfff8a914>
   2b140:	2807883a 	mov	r3,r5
   2b144:	3023883a 	mov	r17,r6
   2b148:	003df206 	br	2a914 <__reset+0xfff8a914>
   2b14c:	123ff804 	addi	r8,r2,-32
   2b150:	01000804 	movi	r4,32
   2b154:	1a10d83a 	srl	r8,r3,r8
   2b158:	11000a26 	beq	r2,r4,2b184 <__subdf3+0x8f4>
   2b15c:	01001004 	movi	r4,64
   2b160:	2085c83a 	sub	r2,r4,r2
   2b164:	1884983a 	sll	r2,r3,r2
   2b168:	1444b03a 	or	r2,r2,r17
   2b16c:	1004c03a 	cmpne	r2,r2,zero
   2b170:	40a2b03a 	or	r17,r8,r2
   2b174:	0005883a 	mov	r2,zero
   2b178:	003f8606 	br	2af94 <__reset+0xfff8af94>
   2b17c:	0005883a 	mov	r2,zero
   2b180:	003fdc06 	br	2b0f4 <__reset+0xfff8b0f4>
   2b184:	0005883a 	mov	r2,zero
   2b188:	003ff706 	br	2b168 <__reset+0xfff8b168>

0002b18c <__fixdfsi>:
   2b18c:	280cd53a 	srli	r6,r5,20
   2b190:	00c00434 	movhi	r3,16
   2b194:	18ffffc4 	addi	r3,r3,-1
   2b198:	3181ffcc 	andi	r6,r6,2047
   2b19c:	01c0ff84 	movi	r7,1022
   2b1a0:	28c6703a 	and	r3,r5,r3
   2b1a4:	280ad7fa 	srli	r5,r5,31
   2b1a8:	3980120e 	bge	r7,r6,2b1f4 <__fixdfsi+0x68>
   2b1ac:	00810744 	movi	r2,1053
   2b1b0:	11800c16 	blt	r2,r6,2b1e4 <__fixdfsi+0x58>
   2b1b4:	00810cc4 	movi	r2,1075
   2b1b8:	1185c83a 	sub	r2,r2,r6
   2b1bc:	01c007c4 	movi	r7,31
   2b1c0:	18c00434 	orhi	r3,r3,16
   2b1c4:	38800d16 	blt	r7,r2,2b1fc <__fixdfsi+0x70>
   2b1c8:	31befb44 	addi	r6,r6,-1043
   2b1cc:	2084d83a 	srl	r2,r4,r2
   2b1d0:	1986983a 	sll	r3,r3,r6
   2b1d4:	1884b03a 	or	r2,r3,r2
   2b1d8:	28000726 	beq	r5,zero,2b1f8 <__fixdfsi+0x6c>
   2b1dc:	0085c83a 	sub	r2,zero,r2
   2b1e0:	f800283a 	ret
   2b1e4:	00a00034 	movhi	r2,32768
   2b1e8:	10bfffc4 	addi	r2,r2,-1
   2b1ec:	2885883a 	add	r2,r5,r2
   2b1f0:	f800283a 	ret
   2b1f4:	0005883a 	mov	r2,zero
   2b1f8:	f800283a 	ret
   2b1fc:	008104c4 	movi	r2,1043
   2b200:	1185c83a 	sub	r2,r2,r6
   2b204:	1884d83a 	srl	r2,r3,r2
   2b208:	003ff306 	br	2b1d8 <__reset+0xfff8b1d8>

0002b20c <__floatsidf>:
   2b20c:	defffd04 	addi	sp,sp,-12
   2b210:	dfc00215 	stw	ra,8(sp)
   2b214:	dc400115 	stw	r17,4(sp)
   2b218:	dc000015 	stw	r16,0(sp)
   2b21c:	20002b26 	beq	r4,zero,2b2cc <__floatsidf+0xc0>
   2b220:	2023883a 	mov	r17,r4
   2b224:	2020d7fa 	srli	r16,r4,31
   2b228:	20002d16 	blt	r4,zero,2b2e0 <__floatsidf+0xd4>
   2b22c:	8809883a 	mov	r4,r17
   2b230:	002b6480 	call	2b648 <__clzsi2>
   2b234:	01410784 	movi	r5,1054
   2b238:	288bc83a 	sub	r5,r5,r2
   2b23c:	01010cc4 	movi	r4,1075
   2b240:	2149c83a 	sub	r4,r4,r5
   2b244:	00c007c4 	movi	r3,31
   2b248:	1900160e 	bge	r3,r4,2b2a4 <__floatsidf+0x98>
   2b24c:	00c104c4 	movi	r3,1043
   2b250:	1947c83a 	sub	r3,r3,r5
   2b254:	88c6983a 	sll	r3,r17,r3
   2b258:	00800434 	movhi	r2,16
   2b25c:	10bfffc4 	addi	r2,r2,-1
   2b260:	1886703a 	and	r3,r3,r2
   2b264:	2941ffcc 	andi	r5,r5,2047
   2b268:	800d883a 	mov	r6,r16
   2b26c:	0005883a 	mov	r2,zero
   2b270:	280a953a 	slli	r5,r5,20
   2b274:	31803fcc 	andi	r6,r6,255
   2b278:	01000434 	movhi	r4,16
   2b27c:	300c97fa 	slli	r6,r6,31
   2b280:	213fffc4 	addi	r4,r4,-1
   2b284:	1906703a 	and	r3,r3,r4
   2b288:	1946b03a 	or	r3,r3,r5
   2b28c:	1986b03a 	or	r3,r3,r6
   2b290:	dfc00217 	ldw	ra,8(sp)
   2b294:	dc400117 	ldw	r17,4(sp)
   2b298:	dc000017 	ldw	r16,0(sp)
   2b29c:	dec00304 	addi	sp,sp,12
   2b2a0:	f800283a 	ret
   2b2a4:	00c002c4 	movi	r3,11
   2b2a8:	1887c83a 	sub	r3,r3,r2
   2b2ac:	88c6d83a 	srl	r3,r17,r3
   2b2b0:	8904983a 	sll	r2,r17,r4
   2b2b4:	01000434 	movhi	r4,16
   2b2b8:	213fffc4 	addi	r4,r4,-1
   2b2bc:	2941ffcc 	andi	r5,r5,2047
   2b2c0:	1906703a 	and	r3,r3,r4
   2b2c4:	800d883a 	mov	r6,r16
   2b2c8:	003fe906 	br	2b270 <__reset+0xfff8b270>
   2b2cc:	000d883a 	mov	r6,zero
   2b2d0:	000b883a 	mov	r5,zero
   2b2d4:	0007883a 	mov	r3,zero
   2b2d8:	0005883a 	mov	r2,zero
   2b2dc:	003fe406 	br	2b270 <__reset+0xfff8b270>
   2b2e0:	0123c83a 	sub	r17,zero,r4
   2b2e4:	003fd106 	br	2b22c <__reset+0xfff8b22c>

0002b2e8 <__floatunsidf>:
   2b2e8:	defffe04 	addi	sp,sp,-8
   2b2ec:	dc000015 	stw	r16,0(sp)
   2b2f0:	dfc00115 	stw	ra,4(sp)
   2b2f4:	2021883a 	mov	r16,r4
   2b2f8:	20002226 	beq	r4,zero,2b384 <__floatunsidf+0x9c>
   2b2fc:	002b6480 	call	2b648 <__clzsi2>
   2b300:	01010784 	movi	r4,1054
   2b304:	2089c83a 	sub	r4,r4,r2
   2b308:	01810cc4 	movi	r6,1075
   2b30c:	310dc83a 	sub	r6,r6,r4
   2b310:	00c007c4 	movi	r3,31
   2b314:	1980120e 	bge	r3,r6,2b360 <__floatunsidf+0x78>
   2b318:	00c104c4 	movi	r3,1043
   2b31c:	1907c83a 	sub	r3,r3,r4
   2b320:	80ca983a 	sll	r5,r16,r3
   2b324:	00800434 	movhi	r2,16
   2b328:	10bfffc4 	addi	r2,r2,-1
   2b32c:	2101ffcc 	andi	r4,r4,2047
   2b330:	0021883a 	mov	r16,zero
   2b334:	288a703a 	and	r5,r5,r2
   2b338:	2008953a 	slli	r4,r4,20
   2b33c:	00c00434 	movhi	r3,16
   2b340:	18ffffc4 	addi	r3,r3,-1
   2b344:	28c6703a 	and	r3,r5,r3
   2b348:	8005883a 	mov	r2,r16
   2b34c:	1906b03a 	or	r3,r3,r4
   2b350:	dfc00117 	ldw	ra,4(sp)
   2b354:	dc000017 	ldw	r16,0(sp)
   2b358:	dec00204 	addi	sp,sp,8
   2b35c:	f800283a 	ret
   2b360:	00c002c4 	movi	r3,11
   2b364:	188bc83a 	sub	r5,r3,r2
   2b368:	814ad83a 	srl	r5,r16,r5
   2b36c:	00c00434 	movhi	r3,16
   2b370:	18ffffc4 	addi	r3,r3,-1
   2b374:	81a0983a 	sll	r16,r16,r6
   2b378:	2101ffcc 	andi	r4,r4,2047
   2b37c:	28ca703a 	and	r5,r5,r3
   2b380:	003fed06 	br	2b338 <__reset+0xfff8b338>
   2b384:	0009883a 	mov	r4,zero
   2b388:	000b883a 	mov	r5,zero
   2b38c:	003fea06 	br	2b338 <__reset+0xfff8b338>

0002b390 <__extendsfdf2>:
   2b390:	200ad5fa 	srli	r5,r4,23
   2b394:	defffd04 	addi	sp,sp,-12
   2b398:	dc400115 	stw	r17,4(sp)
   2b39c:	29403fcc 	andi	r5,r5,255
   2b3a0:	29800044 	addi	r6,r5,1
   2b3a4:	04402034 	movhi	r17,128
   2b3a8:	dc000015 	stw	r16,0(sp)
   2b3ac:	8c7fffc4 	addi	r17,r17,-1
   2b3b0:	dfc00215 	stw	ra,8(sp)
   2b3b4:	31803fcc 	andi	r6,r6,255
   2b3b8:	00800044 	movi	r2,1
   2b3bc:	8922703a 	and	r17,r17,r4
   2b3c0:	2020d7fa 	srli	r16,r4,31
   2b3c4:	1180110e 	bge	r2,r6,2b40c <__extendsfdf2+0x7c>
   2b3c8:	880cd0fa 	srli	r6,r17,3
   2b3cc:	8822977a 	slli	r17,r17,29
   2b3d0:	2940e004 	addi	r5,r5,896
   2b3d4:	2941ffcc 	andi	r5,r5,2047
   2b3d8:	2804953a 	slli	r2,r5,20
   2b3dc:	01400434 	movhi	r5,16
   2b3e0:	800697fa 	slli	r3,r16,31
   2b3e4:	297fffc4 	addi	r5,r5,-1
   2b3e8:	314a703a 	and	r5,r6,r5
   2b3ec:	288ab03a 	or	r5,r5,r2
   2b3f0:	28c6b03a 	or	r3,r5,r3
   2b3f4:	8805883a 	mov	r2,r17
   2b3f8:	dfc00217 	ldw	ra,8(sp)
   2b3fc:	dc400117 	ldw	r17,4(sp)
   2b400:	dc000017 	ldw	r16,0(sp)
   2b404:	dec00304 	addi	sp,sp,12
   2b408:	f800283a 	ret
   2b40c:	2800111e 	bne	r5,zero,2b454 <__extendsfdf2+0xc4>
   2b410:	88001c26 	beq	r17,zero,2b484 <__extendsfdf2+0xf4>
   2b414:	8809883a 	mov	r4,r17
   2b418:	002b6480 	call	2b648 <__clzsi2>
   2b41c:	00c00284 	movi	r3,10
   2b420:	18801b16 	blt	r3,r2,2b490 <__extendsfdf2+0x100>
   2b424:	018002c4 	movi	r6,11
   2b428:	308dc83a 	sub	r6,r6,r2
   2b42c:	11000544 	addi	r4,r2,21
   2b430:	8986d83a 	srl	r3,r17,r6
   2b434:	8922983a 	sll	r17,r17,r4
   2b438:	0180e244 	movi	r6,905
   2b43c:	01400434 	movhi	r5,16
   2b440:	3085c83a 	sub	r2,r6,r2
   2b444:	297fffc4 	addi	r5,r5,-1
   2b448:	194c703a 	and	r6,r3,r5
   2b44c:	1141ffcc 	andi	r5,r2,2047
   2b450:	003fe006 	br	2b3d4 <__reset+0xfff8b3d4>
   2b454:	88000826 	beq	r17,zero,2b478 <__extendsfdf2+0xe8>
   2b458:	880cd0fa 	srli	r6,r17,3
   2b45c:	00800434 	movhi	r2,16
   2b460:	10bfffc4 	addi	r2,r2,-1
   2b464:	31800234 	orhi	r6,r6,8
   2b468:	8822977a 	slli	r17,r17,29
   2b46c:	308c703a 	and	r6,r6,r2
   2b470:	0141ffc4 	movi	r5,2047
   2b474:	003fd706 	br	2b3d4 <__reset+0xfff8b3d4>
   2b478:	0141ffc4 	movi	r5,2047
   2b47c:	000d883a 	mov	r6,zero
   2b480:	003fd406 	br	2b3d4 <__reset+0xfff8b3d4>
   2b484:	000b883a 	mov	r5,zero
   2b488:	000d883a 	mov	r6,zero
   2b48c:	003fd106 	br	2b3d4 <__reset+0xfff8b3d4>
   2b490:	11bffd44 	addi	r6,r2,-11
   2b494:	8986983a 	sll	r3,r17,r6
   2b498:	0023883a 	mov	r17,zero
   2b49c:	003fe606 	br	2b438 <__reset+0xfff8b438>

0002b4a0 <__truncdfsf2>:
   2b4a0:	2810d53a 	srli	r8,r5,20
   2b4a4:	01c00434 	movhi	r7,16
   2b4a8:	39ffffc4 	addi	r7,r7,-1
   2b4ac:	29ce703a 	and	r7,r5,r7
   2b4b0:	4201ffcc 	andi	r8,r8,2047
   2b4b4:	380e90fa 	slli	r7,r7,3
   2b4b8:	200cd77a 	srli	r6,r4,29
   2b4bc:	42400044 	addi	r9,r8,1
   2b4c0:	4a41ffcc 	andi	r9,r9,2047
   2b4c4:	00c00044 	movi	r3,1
   2b4c8:	280ad7fa 	srli	r5,r5,31
   2b4cc:	31ceb03a 	or	r7,r6,r7
   2b4d0:	200490fa 	slli	r2,r4,3
   2b4d4:	1a40230e 	bge	r3,r9,2b564 <__truncdfsf2+0xc4>
   2b4d8:	40ff2004 	addi	r3,r8,-896
   2b4dc:	01803f84 	movi	r6,254
   2b4e0:	30c01516 	blt	r6,r3,2b538 <__truncdfsf2+0x98>
   2b4e4:	00c0380e 	bge	zero,r3,2b5c8 <__truncdfsf2+0x128>
   2b4e8:	200c91ba 	slli	r6,r4,6
   2b4ec:	380e90fa 	slli	r7,r7,3
   2b4f0:	1004d77a 	srli	r2,r2,29
   2b4f4:	300cc03a 	cmpne	r6,r6,zero
   2b4f8:	31ccb03a 	or	r6,r6,r7
   2b4fc:	308cb03a 	or	r6,r6,r2
   2b500:	308001cc 	andi	r2,r6,7
   2b504:	10000426 	beq	r2,zero,2b518 <__truncdfsf2+0x78>
   2b508:	308003cc 	andi	r2,r6,15
   2b50c:	01000104 	movi	r4,4
   2b510:	11000126 	beq	r2,r4,2b518 <__truncdfsf2+0x78>
   2b514:	31800104 	addi	r6,r6,4
   2b518:	3081002c 	andhi	r2,r6,1024
   2b51c:	10001626 	beq	r2,zero,2b578 <__truncdfsf2+0xd8>
   2b520:	18c00044 	addi	r3,r3,1
   2b524:	00803fc4 	movi	r2,255
   2b528:	18800326 	beq	r3,r2,2b538 <__truncdfsf2+0x98>
   2b52c:	300c91ba 	slli	r6,r6,6
   2b530:	300cd27a 	srli	r6,r6,9
   2b534:	00000206 	br	2b540 <__truncdfsf2+0xa0>
   2b538:	00ffffc4 	movi	r3,-1
   2b53c:	000d883a 	mov	r6,zero
   2b540:	18c03fcc 	andi	r3,r3,255
   2b544:	180895fa 	slli	r4,r3,23
   2b548:	00c02034 	movhi	r3,128
   2b54c:	280a97fa 	slli	r5,r5,31
   2b550:	18ffffc4 	addi	r3,r3,-1
   2b554:	30c6703a 	and	r3,r6,r3
   2b558:	1906b03a 	or	r3,r3,r4
   2b55c:	1944b03a 	or	r2,r3,r5
   2b560:	f800283a 	ret
   2b564:	40000b1e 	bne	r8,zero,2b594 <__truncdfsf2+0xf4>
   2b568:	388cb03a 	or	r6,r7,r2
   2b56c:	0007883a 	mov	r3,zero
   2b570:	30000426 	beq	r6,zero,2b584 <__truncdfsf2+0xe4>
   2b574:	01800144 	movi	r6,5
   2b578:	00803fc4 	movi	r2,255
   2b57c:	300cd0fa 	srli	r6,r6,3
   2b580:	18800a26 	beq	r3,r2,2b5ac <__truncdfsf2+0x10c>
   2b584:	00802034 	movhi	r2,128
   2b588:	10bfffc4 	addi	r2,r2,-1
   2b58c:	308c703a 	and	r6,r6,r2
   2b590:	003feb06 	br	2b540 <__reset+0xfff8b540>
   2b594:	3888b03a 	or	r4,r7,r2
   2b598:	203fe726 	beq	r4,zero,2b538 <__reset+0xfff8b538>
   2b59c:	380c90fa 	slli	r6,r7,3
   2b5a0:	00c03fc4 	movi	r3,255
   2b5a4:	31808034 	orhi	r6,r6,512
   2b5a8:	003fd506 	br	2b500 <__reset+0xfff8b500>
   2b5ac:	303fe226 	beq	r6,zero,2b538 <__reset+0xfff8b538>
   2b5b0:	00802034 	movhi	r2,128
   2b5b4:	31801034 	orhi	r6,r6,64
   2b5b8:	10bfffc4 	addi	r2,r2,-1
   2b5bc:	00ffffc4 	movi	r3,-1
   2b5c0:	308c703a 	and	r6,r6,r2
   2b5c4:	003fde06 	br	2b540 <__reset+0xfff8b540>
   2b5c8:	013ffa44 	movi	r4,-23
   2b5cc:	19000e16 	blt	r3,r4,2b608 <__truncdfsf2+0x168>
   2b5d0:	01000784 	movi	r4,30
   2b5d4:	20c9c83a 	sub	r4,r4,r3
   2b5d8:	018007c4 	movi	r6,31
   2b5dc:	39c02034 	orhi	r7,r7,128
   2b5e0:	31000b16 	blt	r6,r4,2b610 <__truncdfsf2+0x170>
   2b5e4:	423f2084 	addi	r8,r8,-894
   2b5e8:	120c983a 	sll	r6,r2,r8
   2b5ec:	3a0e983a 	sll	r7,r7,r8
   2b5f0:	1104d83a 	srl	r2,r2,r4
   2b5f4:	300cc03a 	cmpne	r6,r6,zero
   2b5f8:	31ceb03a 	or	r7,r6,r7
   2b5fc:	388cb03a 	or	r6,r7,r2
   2b600:	0007883a 	mov	r3,zero
   2b604:	003fbe06 	br	2b500 <__reset+0xfff8b500>
   2b608:	0007883a 	mov	r3,zero
   2b60c:	003fd906 	br	2b574 <__reset+0xfff8b574>
   2b610:	01bfff84 	movi	r6,-2
   2b614:	30cdc83a 	sub	r6,r6,r3
   2b618:	00c00804 	movi	r3,32
   2b61c:	398cd83a 	srl	r6,r7,r6
   2b620:	20c00726 	beq	r4,r3,2b640 <__truncdfsf2+0x1a0>
   2b624:	423f2884 	addi	r8,r8,-862
   2b628:	3a0e983a 	sll	r7,r7,r8
   2b62c:	3884b03a 	or	r2,r7,r2
   2b630:	1004c03a 	cmpne	r2,r2,zero
   2b634:	118cb03a 	or	r6,r2,r6
   2b638:	0007883a 	mov	r3,zero
   2b63c:	003fb006 	br	2b500 <__reset+0xfff8b500>
   2b640:	000f883a 	mov	r7,zero
   2b644:	003ff906 	br	2b62c <__reset+0xfff8b62c>

0002b648 <__clzsi2>:
   2b648:	00bfffd4 	movui	r2,65535
   2b64c:	11000536 	bltu	r2,r4,2b664 <__clzsi2+0x1c>
   2b650:	00803fc4 	movi	r2,255
   2b654:	11000f36 	bltu	r2,r4,2b694 <__clzsi2+0x4c>
   2b658:	00800804 	movi	r2,32
   2b65c:	0007883a 	mov	r3,zero
   2b660:	00000506 	br	2b678 <__clzsi2+0x30>
   2b664:	00804034 	movhi	r2,256
   2b668:	10bfffc4 	addi	r2,r2,-1
   2b66c:	11000c2e 	bgeu	r2,r4,2b6a0 <__clzsi2+0x58>
   2b670:	00800204 	movi	r2,8
   2b674:	00c00604 	movi	r3,24
   2b678:	20c8d83a 	srl	r4,r4,r3
   2b67c:	00c000f4 	movhi	r3,3
   2b680:	18cbab84 	addi	r3,r3,11950
   2b684:	1909883a 	add	r4,r3,r4
   2b688:	20c00003 	ldbu	r3,0(r4)
   2b68c:	10c5c83a 	sub	r2,r2,r3
   2b690:	f800283a 	ret
   2b694:	00800604 	movi	r2,24
   2b698:	00c00204 	movi	r3,8
   2b69c:	003ff606 	br	2b678 <__reset+0xfff8b678>
   2b6a0:	00800404 	movi	r2,16
   2b6a4:	1007883a 	mov	r3,r2
   2b6a8:	003ff306 	br	2b678 <__reset+0xfff8b678>

0002b6ac <memcpy>:
   2b6ac:	defffd04 	addi	sp,sp,-12
   2b6b0:	dfc00215 	stw	ra,8(sp)
   2b6b4:	dc400115 	stw	r17,4(sp)
   2b6b8:	dc000015 	stw	r16,0(sp)
   2b6bc:	00c003c4 	movi	r3,15
   2b6c0:	2005883a 	mov	r2,r4
   2b6c4:	1980452e 	bgeu	r3,r6,2b7dc <memcpy+0x130>
   2b6c8:	2906b03a 	or	r3,r5,r4
   2b6cc:	18c000cc 	andi	r3,r3,3
   2b6d0:	1800441e 	bne	r3,zero,2b7e4 <memcpy+0x138>
   2b6d4:	347ffc04 	addi	r17,r6,-16
   2b6d8:	8822d13a 	srli	r17,r17,4
   2b6dc:	28c00104 	addi	r3,r5,4
   2b6e0:	23400104 	addi	r13,r4,4
   2b6e4:	8820913a 	slli	r16,r17,4
   2b6e8:	2b000204 	addi	r12,r5,8
   2b6ec:	22c00204 	addi	r11,r4,8
   2b6f0:	84000504 	addi	r16,r16,20
   2b6f4:	2a800304 	addi	r10,r5,12
   2b6f8:	22400304 	addi	r9,r4,12
   2b6fc:	2c21883a 	add	r16,r5,r16
   2b700:	2811883a 	mov	r8,r5
   2b704:	200f883a 	mov	r7,r4
   2b708:	41000017 	ldw	r4,0(r8)
   2b70c:	1fc00017 	ldw	ra,0(r3)
   2b710:	63c00017 	ldw	r15,0(r12)
   2b714:	39000015 	stw	r4,0(r7)
   2b718:	53800017 	ldw	r14,0(r10)
   2b71c:	6fc00015 	stw	ra,0(r13)
   2b720:	5bc00015 	stw	r15,0(r11)
   2b724:	4b800015 	stw	r14,0(r9)
   2b728:	18c00404 	addi	r3,r3,16
   2b72c:	39c00404 	addi	r7,r7,16
   2b730:	42000404 	addi	r8,r8,16
   2b734:	6b400404 	addi	r13,r13,16
   2b738:	63000404 	addi	r12,r12,16
   2b73c:	5ac00404 	addi	r11,r11,16
   2b740:	52800404 	addi	r10,r10,16
   2b744:	4a400404 	addi	r9,r9,16
   2b748:	1c3fef1e 	bne	r3,r16,2b708 <__reset+0xfff8b708>
   2b74c:	89c00044 	addi	r7,r17,1
   2b750:	380e913a 	slli	r7,r7,4
   2b754:	310003cc 	andi	r4,r6,15
   2b758:	02c000c4 	movi	r11,3
   2b75c:	11c7883a 	add	r3,r2,r7
   2b760:	29cb883a 	add	r5,r5,r7
   2b764:	5900212e 	bgeu	r11,r4,2b7ec <memcpy+0x140>
   2b768:	1813883a 	mov	r9,r3
   2b76c:	2811883a 	mov	r8,r5
   2b770:	200f883a 	mov	r7,r4
   2b774:	42800017 	ldw	r10,0(r8)
   2b778:	4a400104 	addi	r9,r9,4
   2b77c:	39ffff04 	addi	r7,r7,-4
   2b780:	4abfff15 	stw	r10,-4(r9)
   2b784:	42000104 	addi	r8,r8,4
   2b788:	59fffa36 	bltu	r11,r7,2b774 <__reset+0xfff8b774>
   2b78c:	213fff04 	addi	r4,r4,-4
   2b790:	2008d0ba 	srli	r4,r4,2
   2b794:	318000cc 	andi	r6,r6,3
   2b798:	21000044 	addi	r4,r4,1
   2b79c:	2109883a 	add	r4,r4,r4
   2b7a0:	2109883a 	add	r4,r4,r4
   2b7a4:	1907883a 	add	r3,r3,r4
   2b7a8:	290b883a 	add	r5,r5,r4
   2b7ac:	30000626 	beq	r6,zero,2b7c8 <memcpy+0x11c>
   2b7b0:	198d883a 	add	r6,r3,r6
   2b7b4:	29c00003 	ldbu	r7,0(r5)
   2b7b8:	18c00044 	addi	r3,r3,1
   2b7bc:	29400044 	addi	r5,r5,1
   2b7c0:	19ffffc5 	stb	r7,-1(r3)
   2b7c4:	19bffb1e 	bne	r3,r6,2b7b4 <__reset+0xfff8b7b4>
   2b7c8:	dfc00217 	ldw	ra,8(sp)
   2b7cc:	dc400117 	ldw	r17,4(sp)
   2b7d0:	dc000017 	ldw	r16,0(sp)
   2b7d4:	dec00304 	addi	sp,sp,12
   2b7d8:	f800283a 	ret
   2b7dc:	2007883a 	mov	r3,r4
   2b7e0:	003ff206 	br	2b7ac <__reset+0xfff8b7ac>
   2b7e4:	2007883a 	mov	r3,r4
   2b7e8:	003ff106 	br	2b7b0 <__reset+0xfff8b7b0>
   2b7ec:	200d883a 	mov	r6,r4
   2b7f0:	003fee06 	br	2b7ac <__reset+0xfff8b7ac>

0002b7f4 <memset>:
   2b7f4:	20c000cc 	andi	r3,r4,3
   2b7f8:	2005883a 	mov	r2,r4
   2b7fc:	18004426 	beq	r3,zero,2b910 <memset+0x11c>
   2b800:	31ffffc4 	addi	r7,r6,-1
   2b804:	30004026 	beq	r6,zero,2b908 <memset+0x114>
   2b808:	2813883a 	mov	r9,r5
   2b80c:	200d883a 	mov	r6,r4
   2b810:	2007883a 	mov	r3,r4
   2b814:	00000406 	br	2b828 <memset+0x34>
   2b818:	3a3fffc4 	addi	r8,r7,-1
   2b81c:	31800044 	addi	r6,r6,1
   2b820:	38003926 	beq	r7,zero,2b908 <memset+0x114>
   2b824:	400f883a 	mov	r7,r8
   2b828:	18c00044 	addi	r3,r3,1
   2b82c:	32400005 	stb	r9,0(r6)
   2b830:	1a0000cc 	andi	r8,r3,3
   2b834:	403ff81e 	bne	r8,zero,2b818 <__reset+0xfff8b818>
   2b838:	010000c4 	movi	r4,3
   2b83c:	21c02d2e 	bgeu	r4,r7,2b8f4 <memset+0x100>
   2b840:	29003fcc 	andi	r4,r5,255
   2b844:	200c923a 	slli	r6,r4,8
   2b848:	3108b03a 	or	r4,r6,r4
   2b84c:	200c943a 	slli	r6,r4,16
   2b850:	218cb03a 	or	r6,r4,r6
   2b854:	010003c4 	movi	r4,15
   2b858:	21c0182e 	bgeu	r4,r7,2b8bc <memset+0xc8>
   2b85c:	3b3ffc04 	addi	r12,r7,-16
   2b860:	6018d13a 	srli	r12,r12,4
   2b864:	1a000104 	addi	r8,r3,4
   2b868:	1ac00204 	addi	r11,r3,8
   2b86c:	6008913a 	slli	r4,r12,4
   2b870:	1a800304 	addi	r10,r3,12
   2b874:	1813883a 	mov	r9,r3
   2b878:	21000504 	addi	r4,r4,20
   2b87c:	1909883a 	add	r4,r3,r4
   2b880:	49800015 	stw	r6,0(r9)
   2b884:	41800015 	stw	r6,0(r8)
   2b888:	59800015 	stw	r6,0(r11)
   2b88c:	51800015 	stw	r6,0(r10)
   2b890:	42000404 	addi	r8,r8,16
   2b894:	4a400404 	addi	r9,r9,16
   2b898:	5ac00404 	addi	r11,r11,16
   2b89c:	52800404 	addi	r10,r10,16
   2b8a0:	413ff71e 	bne	r8,r4,2b880 <__reset+0xfff8b880>
   2b8a4:	63000044 	addi	r12,r12,1
   2b8a8:	6018913a 	slli	r12,r12,4
   2b8ac:	39c003cc 	andi	r7,r7,15
   2b8b0:	010000c4 	movi	r4,3
   2b8b4:	1b07883a 	add	r3,r3,r12
   2b8b8:	21c00e2e 	bgeu	r4,r7,2b8f4 <memset+0x100>
   2b8bc:	1813883a 	mov	r9,r3
   2b8c0:	3811883a 	mov	r8,r7
   2b8c4:	010000c4 	movi	r4,3
   2b8c8:	49800015 	stw	r6,0(r9)
   2b8cc:	423fff04 	addi	r8,r8,-4
   2b8d0:	4a400104 	addi	r9,r9,4
   2b8d4:	223ffc36 	bltu	r4,r8,2b8c8 <__reset+0xfff8b8c8>
   2b8d8:	393fff04 	addi	r4,r7,-4
   2b8dc:	2008d0ba 	srli	r4,r4,2
   2b8e0:	39c000cc 	andi	r7,r7,3
   2b8e4:	21000044 	addi	r4,r4,1
   2b8e8:	2109883a 	add	r4,r4,r4
   2b8ec:	2109883a 	add	r4,r4,r4
   2b8f0:	1907883a 	add	r3,r3,r4
   2b8f4:	38000526 	beq	r7,zero,2b90c <memset+0x118>
   2b8f8:	19cf883a 	add	r7,r3,r7
   2b8fc:	19400005 	stb	r5,0(r3)
   2b900:	18c00044 	addi	r3,r3,1
   2b904:	38fffd1e 	bne	r7,r3,2b8fc <__reset+0xfff8b8fc>
   2b908:	f800283a 	ret
   2b90c:	f800283a 	ret
   2b910:	2007883a 	mov	r3,r4
   2b914:	300f883a 	mov	r7,r6
   2b918:	003fc706 	br	2b838 <__reset+0xfff8b838>

0002b91c <_puts_r>:
   2b91c:	defff604 	addi	sp,sp,-40
   2b920:	dc000715 	stw	r16,28(sp)
   2b924:	2021883a 	mov	r16,r4
   2b928:	2809883a 	mov	r4,r5
   2b92c:	dc400815 	stw	r17,32(sp)
   2b930:	dfc00915 	stw	ra,36(sp)
   2b934:	2823883a 	mov	r17,r5
   2b938:	002b9f00 	call	2b9f0 <strlen>
   2b93c:	10c00044 	addi	r3,r2,1
   2b940:	d8800115 	stw	r2,4(sp)
   2b944:	008000f4 	movhi	r2,3
   2b948:	108bec04 	addi	r2,r2,12208
   2b94c:	d8800215 	stw	r2,8(sp)
   2b950:	00800044 	movi	r2,1
   2b954:	d8800315 	stw	r2,12(sp)
   2b958:	00800084 	movi	r2,2
   2b95c:	dc400015 	stw	r17,0(sp)
   2b960:	d8c00615 	stw	r3,24(sp)
   2b964:	dec00415 	stw	sp,16(sp)
   2b968:	d8800515 	stw	r2,20(sp)
   2b96c:	80000226 	beq	r16,zero,2b978 <_puts_r+0x5c>
   2b970:	80800e17 	ldw	r2,56(r16)
   2b974:	10001426 	beq	r2,zero,2b9c8 <_puts_r+0xac>
   2b978:	81400217 	ldw	r5,8(r16)
   2b97c:	2880030b 	ldhu	r2,12(r5)
   2b980:	10c8000c 	andi	r3,r2,8192
   2b984:	1800061e 	bne	r3,zero,2b9a0 <_puts_r+0x84>
   2b988:	29001917 	ldw	r4,100(r5)
   2b98c:	00f7ffc4 	movi	r3,-8193
   2b990:	10880014 	ori	r2,r2,8192
   2b994:	20c6703a 	and	r3,r4,r3
   2b998:	2880030d 	sth	r2,12(r5)
   2b99c:	28c01915 	stw	r3,100(r5)
   2b9a0:	d9800404 	addi	r6,sp,16
   2b9a4:	8009883a 	mov	r4,r16
   2b9a8:	002be280 	call	2be28 <__sfvwrite_r>
   2b9ac:	1000091e 	bne	r2,zero,2b9d4 <_puts_r+0xb8>
   2b9b0:	00800284 	movi	r2,10
   2b9b4:	dfc00917 	ldw	ra,36(sp)
   2b9b8:	dc400817 	ldw	r17,32(sp)
   2b9bc:	dc000717 	ldw	r16,28(sp)
   2b9c0:	dec00a04 	addi	sp,sp,40
   2b9c4:	f800283a 	ret
   2b9c8:	8009883a 	mov	r4,r16
   2b9cc:	002bdd80 	call	2bdd8 <__sinit>
   2b9d0:	003fe906 	br	2b978 <__reset+0xfff8b978>
   2b9d4:	00bfffc4 	movi	r2,-1
   2b9d8:	003ff606 	br	2b9b4 <__reset+0xfff8b9b4>

0002b9dc <puts>:
   2b9dc:	008000f4 	movhi	r2,3
   2b9e0:	10931804 	addi	r2,r2,19552
   2b9e4:	200b883a 	mov	r5,r4
   2b9e8:	11000017 	ldw	r4,0(r2)
   2b9ec:	002b91c1 	jmpi	2b91c <_puts_r>

0002b9f0 <strlen>:
   2b9f0:	208000cc 	andi	r2,r4,3
   2b9f4:	10002026 	beq	r2,zero,2ba78 <strlen+0x88>
   2b9f8:	20800007 	ldb	r2,0(r4)
   2b9fc:	10002026 	beq	r2,zero,2ba80 <strlen+0x90>
   2ba00:	2005883a 	mov	r2,r4
   2ba04:	00000206 	br	2ba10 <strlen+0x20>
   2ba08:	10c00007 	ldb	r3,0(r2)
   2ba0c:	18001826 	beq	r3,zero,2ba70 <strlen+0x80>
   2ba10:	10800044 	addi	r2,r2,1
   2ba14:	10c000cc 	andi	r3,r2,3
   2ba18:	183ffb1e 	bne	r3,zero,2ba08 <__reset+0xfff8ba08>
   2ba1c:	10c00017 	ldw	r3,0(r2)
   2ba20:	01ffbff4 	movhi	r7,65279
   2ba24:	39ffbfc4 	addi	r7,r7,-257
   2ba28:	00ca303a 	nor	r5,zero,r3
   2ba2c:	01a02074 	movhi	r6,32897
   2ba30:	19c7883a 	add	r3,r3,r7
   2ba34:	31a02004 	addi	r6,r6,-32640
   2ba38:	1946703a 	and	r3,r3,r5
   2ba3c:	1986703a 	and	r3,r3,r6
   2ba40:	1800091e 	bne	r3,zero,2ba68 <strlen+0x78>
   2ba44:	10800104 	addi	r2,r2,4
   2ba48:	10c00017 	ldw	r3,0(r2)
   2ba4c:	19cb883a 	add	r5,r3,r7
   2ba50:	00c6303a 	nor	r3,zero,r3
   2ba54:	28c6703a 	and	r3,r5,r3
   2ba58:	1986703a 	and	r3,r3,r6
   2ba5c:	183ff926 	beq	r3,zero,2ba44 <__reset+0xfff8ba44>
   2ba60:	00000106 	br	2ba68 <strlen+0x78>
   2ba64:	10800044 	addi	r2,r2,1
   2ba68:	10c00007 	ldb	r3,0(r2)
   2ba6c:	183ffd1e 	bne	r3,zero,2ba64 <__reset+0xfff8ba64>
   2ba70:	1105c83a 	sub	r2,r2,r4
   2ba74:	f800283a 	ret
   2ba78:	2005883a 	mov	r2,r4
   2ba7c:	003fe706 	br	2ba1c <__reset+0xfff8ba1c>
   2ba80:	0005883a 	mov	r2,zero
   2ba84:	f800283a 	ret

0002ba88 <__fp_unlock>:
   2ba88:	0005883a 	mov	r2,zero
   2ba8c:	f800283a 	ret

0002ba90 <_cleanup_r>:
   2ba90:	014000f4 	movhi	r5,3
   2ba94:	2975ed04 	addi	r5,r5,-10316
   2ba98:	002c3a81 	jmpi	2c3a8 <_fwalk_reent>

0002ba9c <__sinit.part.1>:
   2ba9c:	defff704 	addi	sp,sp,-36
   2baa0:	00c000f4 	movhi	r3,3
   2baa4:	dfc00815 	stw	ra,32(sp)
   2baa8:	ddc00715 	stw	r23,28(sp)
   2baac:	dd800615 	stw	r22,24(sp)
   2bab0:	dd400515 	stw	r21,20(sp)
   2bab4:	dd000415 	stw	r20,16(sp)
   2bab8:	dcc00315 	stw	r19,12(sp)
   2babc:	dc800215 	stw	r18,8(sp)
   2bac0:	dc400115 	stw	r17,4(sp)
   2bac4:	dc000015 	stw	r16,0(sp)
   2bac8:	18eea404 	addi	r3,r3,-17776
   2bacc:	24000117 	ldw	r16,4(r4)
   2bad0:	20c00f15 	stw	r3,60(r4)
   2bad4:	2080bb04 	addi	r2,r4,748
   2bad8:	00c000c4 	movi	r3,3
   2badc:	20c0b915 	stw	r3,740(r4)
   2bae0:	2080ba15 	stw	r2,744(r4)
   2bae4:	2000b815 	stw	zero,736(r4)
   2bae8:	05c00204 	movi	r23,8
   2baec:	00800104 	movi	r2,4
   2baf0:	2025883a 	mov	r18,r4
   2baf4:	b80d883a 	mov	r6,r23
   2baf8:	81001704 	addi	r4,r16,92
   2bafc:	000b883a 	mov	r5,zero
   2bb00:	80000015 	stw	zero,0(r16)
   2bb04:	80000115 	stw	zero,4(r16)
   2bb08:	80000215 	stw	zero,8(r16)
   2bb0c:	8080030d 	sth	r2,12(r16)
   2bb10:	80001915 	stw	zero,100(r16)
   2bb14:	8000038d 	sth	zero,14(r16)
   2bb18:	80000415 	stw	zero,16(r16)
   2bb1c:	80000515 	stw	zero,20(r16)
   2bb20:	80000615 	stw	zero,24(r16)
   2bb24:	002b7f40 	call	2b7f4 <memset>
   2bb28:	058000f4 	movhi	r22,3
   2bb2c:	94400217 	ldw	r17,8(r18)
   2bb30:	054000f4 	movhi	r21,3
   2bb34:	050000f4 	movhi	r20,3
   2bb38:	04c000f4 	movhi	r19,3
   2bb3c:	b5b51c04 	addi	r22,r22,-11152
   2bb40:	ad753304 	addi	r21,r21,-11060
   2bb44:	a5355204 	addi	r20,r20,-10936
   2bb48:	9cf56904 	addi	r19,r19,-10844
   2bb4c:	85800815 	stw	r22,32(r16)
   2bb50:	85400915 	stw	r21,36(r16)
   2bb54:	85000a15 	stw	r20,40(r16)
   2bb58:	84c00b15 	stw	r19,44(r16)
   2bb5c:	84000715 	stw	r16,28(r16)
   2bb60:	00800284 	movi	r2,10
   2bb64:	8880030d 	sth	r2,12(r17)
   2bb68:	00800044 	movi	r2,1
   2bb6c:	b80d883a 	mov	r6,r23
   2bb70:	89001704 	addi	r4,r17,92
   2bb74:	000b883a 	mov	r5,zero
   2bb78:	88000015 	stw	zero,0(r17)
   2bb7c:	88000115 	stw	zero,4(r17)
   2bb80:	88000215 	stw	zero,8(r17)
   2bb84:	88001915 	stw	zero,100(r17)
   2bb88:	8880038d 	sth	r2,14(r17)
   2bb8c:	88000415 	stw	zero,16(r17)
   2bb90:	88000515 	stw	zero,20(r17)
   2bb94:	88000615 	stw	zero,24(r17)
   2bb98:	002b7f40 	call	2b7f4 <memset>
   2bb9c:	94000317 	ldw	r16,12(r18)
   2bba0:	00800484 	movi	r2,18
   2bba4:	8c400715 	stw	r17,28(r17)
   2bba8:	8d800815 	stw	r22,32(r17)
   2bbac:	8d400915 	stw	r21,36(r17)
   2bbb0:	8d000a15 	stw	r20,40(r17)
   2bbb4:	8cc00b15 	stw	r19,44(r17)
   2bbb8:	8080030d 	sth	r2,12(r16)
   2bbbc:	00800084 	movi	r2,2
   2bbc0:	80000015 	stw	zero,0(r16)
   2bbc4:	80000115 	stw	zero,4(r16)
   2bbc8:	80000215 	stw	zero,8(r16)
   2bbcc:	80001915 	stw	zero,100(r16)
   2bbd0:	8080038d 	sth	r2,14(r16)
   2bbd4:	80000415 	stw	zero,16(r16)
   2bbd8:	80000515 	stw	zero,20(r16)
   2bbdc:	80000615 	stw	zero,24(r16)
   2bbe0:	b80d883a 	mov	r6,r23
   2bbe4:	000b883a 	mov	r5,zero
   2bbe8:	81001704 	addi	r4,r16,92
   2bbec:	002b7f40 	call	2b7f4 <memset>
   2bbf0:	00800044 	movi	r2,1
   2bbf4:	84000715 	stw	r16,28(r16)
   2bbf8:	85800815 	stw	r22,32(r16)
   2bbfc:	85400915 	stw	r21,36(r16)
   2bc00:	85000a15 	stw	r20,40(r16)
   2bc04:	84c00b15 	stw	r19,44(r16)
   2bc08:	90800e15 	stw	r2,56(r18)
   2bc0c:	dfc00817 	ldw	ra,32(sp)
   2bc10:	ddc00717 	ldw	r23,28(sp)
   2bc14:	dd800617 	ldw	r22,24(sp)
   2bc18:	dd400517 	ldw	r21,20(sp)
   2bc1c:	dd000417 	ldw	r20,16(sp)
   2bc20:	dcc00317 	ldw	r19,12(sp)
   2bc24:	dc800217 	ldw	r18,8(sp)
   2bc28:	dc400117 	ldw	r17,4(sp)
   2bc2c:	dc000017 	ldw	r16,0(sp)
   2bc30:	dec00904 	addi	sp,sp,36
   2bc34:	f800283a 	ret

0002bc38 <__fp_lock>:
   2bc38:	0005883a 	mov	r2,zero
   2bc3c:	f800283a 	ret

0002bc40 <__sfmoreglue>:
   2bc40:	defffc04 	addi	sp,sp,-16
   2bc44:	dc400115 	stw	r17,4(sp)
   2bc48:	2c7fffc4 	addi	r17,r5,-1
   2bc4c:	8c401a24 	muli	r17,r17,104
   2bc50:	dc800215 	stw	r18,8(sp)
   2bc54:	2825883a 	mov	r18,r5
   2bc58:	89401d04 	addi	r5,r17,116
   2bc5c:	dc000015 	stw	r16,0(sp)
   2bc60:	dfc00315 	stw	ra,12(sp)
   2bc64:	002c46c0 	call	2c46c <_malloc_r>
   2bc68:	1021883a 	mov	r16,r2
   2bc6c:	10000726 	beq	r2,zero,2bc8c <__sfmoreglue+0x4c>
   2bc70:	11000304 	addi	r4,r2,12
   2bc74:	10000015 	stw	zero,0(r2)
   2bc78:	14800115 	stw	r18,4(r2)
   2bc7c:	11000215 	stw	r4,8(r2)
   2bc80:	89801a04 	addi	r6,r17,104
   2bc84:	000b883a 	mov	r5,zero
   2bc88:	002b7f40 	call	2b7f4 <memset>
   2bc8c:	8005883a 	mov	r2,r16
   2bc90:	dfc00317 	ldw	ra,12(sp)
   2bc94:	dc800217 	ldw	r18,8(sp)
   2bc98:	dc400117 	ldw	r17,4(sp)
   2bc9c:	dc000017 	ldw	r16,0(sp)
   2bca0:	dec00404 	addi	sp,sp,16
   2bca4:	f800283a 	ret

0002bca8 <__sfp>:
   2bca8:	defffb04 	addi	sp,sp,-20
   2bcac:	dc000015 	stw	r16,0(sp)
   2bcb0:	040000f4 	movhi	r16,3
   2bcb4:	84131704 	addi	r16,r16,19548
   2bcb8:	dcc00315 	stw	r19,12(sp)
   2bcbc:	2027883a 	mov	r19,r4
   2bcc0:	81000017 	ldw	r4,0(r16)
   2bcc4:	dfc00415 	stw	ra,16(sp)
   2bcc8:	dc800215 	stw	r18,8(sp)
   2bccc:	20800e17 	ldw	r2,56(r4)
   2bcd0:	dc400115 	stw	r17,4(sp)
   2bcd4:	1000021e 	bne	r2,zero,2bce0 <__sfp+0x38>
   2bcd8:	002ba9c0 	call	2ba9c <__sinit.part.1>
   2bcdc:	81000017 	ldw	r4,0(r16)
   2bce0:	2480b804 	addi	r18,r4,736
   2bce4:	047fffc4 	movi	r17,-1
   2bce8:	91000117 	ldw	r4,4(r18)
   2bcec:	94000217 	ldw	r16,8(r18)
   2bcf0:	213fffc4 	addi	r4,r4,-1
   2bcf4:	20000a16 	blt	r4,zero,2bd20 <__sfp+0x78>
   2bcf8:	8080030f 	ldh	r2,12(r16)
   2bcfc:	10000c26 	beq	r2,zero,2bd30 <__sfp+0x88>
   2bd00:	80c01d04 	addi	r3,r16,116
   2bd04:	00000206 	br	2bd10 <__sfp+0x68>
   2bd08:	18bfe60f 	ldh	r2,-104(r3)
   2bd0c:	10000826 	beq	r2,zero,2bd30 <__sfp+0x88>
   2bd10:	213fffc4 	addi	r4,r4,-1
   2bd14:	1c3ffd04 	addi	r16,r3,-12
   2bd18:	18c01a04 	addi	r3,r3,104
   2bd1c:	247ffa1e 	bne	r4,r17,2bd08 <__reset+0xfff8bd08>
   2bd20:	90800017 	ldw	r2,0(r18)
   2bd24:	10001d26 	beq	r2,zero,2bd9c <__sfp+0xf4>
   2bd28:	1025883a 	mov	r18,r2
   2bd2c:	003fee06 	br	2bce8 <__reset+0xfff8bce8>
   2bd30:	00bfffc4 	movi	r2,-1
   2bd34:	8080038d 	sth	r2,14(r16)
   2bd38:	00800044 	movi	r2,1
   2bd3c:	8080030d 	sth	r2,12(r16)
   2bd40:	80001915 	stw	zero,100(r16)
   2bd44:	80000015 	stw	zero,0(r16)
   2bd48:	80000215 	stw	zero,8(r16)
   2bd4c:	80000115 	stw	zero,4(r16)
   2bd50:	80000415 	stw	zero,16(r16)
   2bd54:	80000515 	stw	zero,20(r16)
   2bd58:	80000615 	stw	zero,24(r16)
   2bd5c:	01800204 	movi	r6,8
   2bd60:	000b883a 	mov	r5,zero
   2bd64:	81001704 	addi	r4,r16,92
   2bd68:	002b7f40 	call	2b7f4 <memset>
   2bd6c:	8005883a 	mov	r2,r16
   2bd70:	80000c15 	stw	zero,48(r16)
   2bd74:	80000d15 	stw	zero,52(r16)
   2bd78:	80001115 	stw	zero,68(r16)
   2bd7c:	80001215 	stw	zero,72(r16)
   2bd80:	dfc00417 	ldw	ra,16(sp)
   2bd84:	dcc00317 	ldw	r19,12(sp)
   2bd88:	dc800217 	ldw	r18,8(sp)
   2bd8c:	dc400117 	ldw	r17,4(sp)
   2bd90:	dc000017 	ldw	r16,0(sp)
   2bd94:	dec00504 	addi	sp,sp,20
   2bd98:	f800283a 	ret
   2bd9c:	01400104 	movi	r5,4
   2bda0:	9809883a 	mov	r4,r19
   2bda4:	002bc400 	call	2bc40 <__sfmoreglue>
   2bda8:	90800015 	stw	r2,0(r18)
   2bdac:	103fde1e 	bne	r2,zero,2bd28 <__reset+0xfff8bd28>
   2bdb0:	00800304 	movi	r2,12
   2bdb4:	98800015 	stw	r2,0(r19)
   2bdb8:	0005883a 	mov	r2,zero
   2bdbc:	003ff006 	br	2bd80 <__reset+0xfff8bd80>

0002bdc0 <_cleanup>:
   2bdc0:	008000f4 	movhi	r2,3
   2bdc4:	10931704 	addi	r2,r2,19548
   2bdc8:	11000017 	ldw	r4,0(r2)
   2bdcc:	014000f4 	movhi	r5,3
   2bdd0:	2975ed04 	addi	r5,r5,-10316
   2bdd4:	002c3a81 	jmpi	2c3a8 <_fwalk_reent>

0002bdd8 <__sinit>:
   2bdd8:	20800e17 	ldw	r2,56(r4)
   2bddc:	10000126 	beq	r2,zero,2bde4 <__sinit+0xc>
   2bde0:	f800283a 	ret
   2bde4:	002ba9c1 	jmpi	2ba9c <__sinit.part.1>

0002bde8 <__sfp_lock_acquire>:
   2bde8:	f800283a 	ret

0002bdec <__sfp_lock_release>:
   2bdec:	f800283a 	ret

0002bdf0 <__sinit_lock_acquire>:
   2bdf0:	f800283a 	ret

0002bdf4 <__sinit_lock_release>:
   2bdf4:	f800283a 	ret

0002bdf8 <__fp_lock_all>:
   2bdf8:	008000f4 	movhi	r2,3
   2bdfc:	10931804 	addi	r2,r2,19552
   2be00:	11000017 	ldw	r4,0(r2)
   2be04:	014000f4 	movhi	r5,3
   2be08:	296f0e04 	addi	r5,r5,-17352
   2be0c:	002c2e41 	jmpi	2c2e4 <_fwalk>

0002be10 <__fp_unlock_all>:
   2be10:	008000f4 	movhi	r2,3
   2be14:	10931804 	addi	r2,r2,19552
   2be18:	11000017 	ldw	r4,0(r2)
   2be1c:	014000f4 	movhi	r5,3
   2be20:	296ea204 	addi	r5,r5,-17784
   2be24:	002c2e41 	jmpi	2c2e4 <_fwalk>

0002be28 <__sfvwrite_r>:
   2be28:	30800217 	ldw	r2,8(r6)
   2be2c:	10006726 	beq	r2,zero,2bfcc <__sfvwrite_r+0x1a4>
   2be30:	28c0030b 	ldhu	r3,12(r5)
   2be34:	defff404 	addi	sp,sp,-48
   2be38:	dd400715 	stw	r21,28(sp)
   2be3c:	dd000615 	stw	r20,24(sp)
   2be40:	dc000215 	stw	r16,8(sp)
   2be44:	dfc00b15 	stw	ra,44(sp)
   2be48:	df000a15 	stw	fp,40(sp)
   2be4c:	ddc00915 	stw	r23,36(sp)
   2be50:	dd800815 	stw	r22,32(sp)
   2be54:	dcc00515 	stw	r19,20(sp)
   2be58:	dc800415 	stw	r18,16(sp)
   2be5c:	dc400315 	stw	r17,12(sp)
   2be60:	1880020c 	andi	r2,r3,8
   2be64:	2821883a 	mov	r16,r5
   2be68:	202b883a 	mov	r21,r4
   2be6c:	3029883a 	mov	r20,r6
   2be70:	10002726 	beq	r2,zero,2bf10 <__sfvwrite_r+0xe8>
   2be74:	28800417 	ldw	r2,16(r5)
   2be78:	10002526 	beq	r2,zero,2bf10 <__sfvwrite_r+0xe8>
   2be7c:	1880008c 	andi	r2,r3,2
   2be80:	a4400017 	ldw	r17,0(r20)
   2be84:	10002a26 	beq	r2,zero,2bf30 <__sfvwrite_r+0x108>
   2be88:	05a00034 	movhi	r22,32768
   2be8c:	0027883a 	mov	r19,zero
   2be90:	0025883a 	mov	r18,zero
   2be94:	b5bf0004 	addi	r22,r22,-1024
   2be98:	980d883a 	mov	r6,r19
   2be9c:	a809883a 	mov	r4,r21
   2bea0:	90004626 	beq	r18,zero,2bfbc <__sfvwrite_r+0x194>
   2bea4:	900f883a 	mov	r7,r18
   2bea8:	b480022e 	bgeu	r22,r18,2beb4 <__sfvwrite_r+0x8c>
   2beac:	01e00034 	movhi	r7,32768
   2beb0:	39ff0004 	addi	r7,r7,-1024
   2beb4:	80800917 	ldw	r2,36(r16)
   2beb8:	81400717 	ldw	r5,28(r16)
   2bebc:	103ee83a 	callr	r2
   2bec0:	0080570e 	bge	zero,r2,2c020 <__sfvwrite_r+0x1f8>
   2bec4:	a0c00217 	ldw	r3,8(r20)
   2bec8:	98a7883a 	add	r19,r19,r2
   2becc:	90a5c83a 	sub	r18,r18,r2
   2bed0:	1885c83a 	sub	r2,r3,r2
   2bed4:	a0800215 	stw	r2,8(r20)
   2bed8:	103fef1e 	bne	r2,zero,2be98 <__reset+0xfff8be98>
   2bedc:	0005883a 	mov	r2,zero
   2bee0:	dfc00b17 	ldw	ra,44(sp)
   2bee4:	df000a17 	ldw	fp,40(sp)
   2bee8:	ddc00917 	ldw	r23,36(sp)
   2beec:	dd800817 	ldw	r22,32(sp)
   2bef0:	dd400717 	ldw	r21,28(sp)
   2bef4:	dd000617 	ldw	r20,24(sp)
   2bef8:	dcc00517 	ldw	r19,20(sp)
   2befc:	dc800417 	ldw	r18,16(sp)
   2bf00:	dc400317 	ldw	r17,12(sp)
   2bf04:	dc000217 	ldw	r16,8(sp)
   2bf08:	dec00c04 	addi	sp,sp,48
   2bf0c:	f800283a 	ret
   2bf10:	800b883a 	mov	r5,r16
   2bf14:	a809883a 	mov	r4,r21
   2bf18:	002d60c0 	call	2d60c <__swsetup_r>
   2bf1c:	1000eb1e 	bne	r2,zero,2c2cc <__sfvwrite_r+0x4a4>
   2bf20:	80c0030b 	ldhu	r3,12(r16)
   2bf24:	a4400017 	ldw	r17,0(r20)
   2bf28:	1880008c 	andi	r2,r3,2
   2bf2c:	103fd61e 	bne	r2,zero,2be88 <__reset+0xfff8be88>
   2bf30:	1880004c 	andi	r2,r3,1
   2bf34:	10003f1e 	bne	r2,zero,2c034 <__sfvwrite_r+0x20c>
   2bf38:	0039883a 	mov	fp,zero
   2bf3c:	0025883a 	mov	r18,zero
   2bf40:	90001a26 	beq	r18,zero,2bfac <__sfvwrite_r+0x184>
   2bf44:	1880800c 	andi	r2,r3,512
   2bf48:	84c00217 	ldw	r19,8(r16)
   2bf4c:	10002126 	beq	r2,zero,2bfd4 <__sfvwrite_r+0x1ac>
   2bf50:	982f883a 	mov	r23,r19
   2bf54:	94c09336 	bltu	r18,r19,2c1a4 <__sfvwrite_r+0x37c>
   2bf58:	1881200c 	andi	r2,r3,1152
   2bf5c:	10009e1e 	bne	r2,zero,2c1d8 <__sfvwrite_r+0x3b0>
   2bf60:	81000017 	ldw	r4,0(r16)
   2bf64:	b80d883a 	mov	r6,r23
   2bf68:	e00b883a 	mov	r5,fp
   2bf6c:	002cd5c0 	call	2cd5c <memmove>
   2bf70:	80c00217 	ldw	r3,8(r16)
   2bf74:	81000017 	ldw	r4,0(r16)
   2bf78:	9005883a 	mov	r2,r18
   2bf7c:	1ce7c83a 	sub	r19,r3,r19
   2bf80:	25cf883a 	add	r7,r4,r23
   2bf84:	84c00215 	stw	r19,8(r16)
   2bf88:	81c00015 	stw	r7,0(r16)
   2bf8c:	a0c00217 	ldw	r3,8(r20)
   2bf90:	e0b9883a 	add	fp,fp,r2
   2bf94:	90a5c83a 	sub	r18,r18,r2
   2bf98:	18a7c83a 	sub	r19,r3,r2
   2bf9c:	a4c00215 	stw	r19,8(r20)
   2bfa0:	983fce26 	beq	r19,zero,2bedc <__reset+0xfff8bedc>
   2bfa4:	80c0030b 	ldhu	r3,12(r16)
   2bfa8:	903fe61e 	bne	r18,zero,2bf44 <__reset+0xfff8bf44>
   2bfac:	8f000017 	ldw	fp,0(r17)
   2bfb0:	8c800117 	ldw	r18,4(r17)
   2bfb4:	8c400204 	addi	r17,r17,8
   2bfb8:	003fe106 	br	2bf40 <__reset+0xfff8bf40>
   2bfbc:	8cc00017 	ldw	r19,0(r17)
   2bfc0:	8c800117 	ldw	r18,4(r17)
   2bfc4:	8c400204 	addi	r17,r17,8
   2bfc8:	003fb306 	br	2be98 <__reset+0xfff8be98>
   2bfcc:	0005883a 	mov	r2,zero
   2bfd0:	f800283a 	ret
   2bfd4:	81000017 	ldw	r4,0(r16)
   2bfd8:	80800417 	ldw	r2,16(r16)
   2bfdc:	11005736 	bltu	r2,r4,2c13c <__sfvwrite_r+0x314>
   2bfe0:	85c00517 	ldw	r23,20(r16)
   2bfe4:	95c05536 	bltu	r18,r23,2c13c <__sfvwrite_r+0x314>
   2bfe8:	00a00034 	movhi	r2,32768
   2bfec:	10bfffc4 	addi	r2,r2,-1
   2bff0:	9009883a 	mov	r4,r18
   2bff4:	1480012e 	bgeu	r2,r18,2bffc <__sfvwrite_r+0x1d4>
   2bff8:	1009883a 	mov	r4,r2
   2bffc:	b80b883a 	mov	r5,r23
   2c000:	0027cf40 	call	27cf4 <__divsi3>
   2c004:	15cf383a 	mul	r7,r2,r23
   2c008:	81400717 	ldw	r5,28(r16)
   2c00c:	80800917 	ldw	r2,36(r16)
   2c010:	e00d883a 	mov	r6,fp
   2c014:	a809883a 	mov	r4,r21
   2c018:	103ee83a 	callr	r2
   2c01c:	00bfdb16 	blt	zero,r2,2bf8c <__reset+0xfff8bf8c>
   2c020:	8080030b 	ldhu	r2,12(r16)
   2c024:	10801014 	ori	r2,r2,64
   2c028:	8080030d 	sth	r2,12(r16)
   2c02c:	00bfffc4 	movi	r2,-1
   2c030:	003fab06 	br	2bee0 <__reset+0xfff8bee0>
   2c034:	0027883a 	mov	r19,zero
   2c038:	0011883a 	mov	r8,zero
   2c03c:	0039883a 	mov	fp,zero
   2c040:	0025883a 	mov	r18,zero
   2c044:	90001f26 	beq	r18,zero,2c0c4 <__sfvwrite_r+0x29c>
   2c048:	40005a26 	beq	r8,zero,2c1b4 <__sfvwrite_r+0x38c>
   2c04c:	982d883a 	mov	r22,r19
   2c050:	94c0012e 	bgeu	r18,r19,2c058 <__sfvwrite_r+0x230>
   2c054:	902d883a 	mov	r22,r18
   2c058:	81000017 	ldw	r4,0(r16)
   2c05c:	80800417 	ldw	r2,16(r16)
   2c060:	b02f883a 	mov	r23,r22
   2c064:	81c00517 	ldw	r7,20(r16)
   2c068:	1100032e 	bgeu	r2,r4,2c078 <__sfvwrite_r+0x250>
   2c06c:	80c00217 	ldw	r3,8(r16)
   2c070:	38c7883a 	add	r3,r7,r3
   2c074:	1d801816 	blt	r3,r22,2c0d8 <__sfvwrite_r+0x2b0>
   2c078:	b1c03e16 	blt	r22,r7,2c174 <__sfvwrite_r+0x34c>
   2c07c:	80800917 	ldw	r2,36(r16)
   2c080:	81400717 	ldw	r5,28(r16)
   2c084:	e00d883a 	mov	r6,fp
   2c088:	da000115 	stw	r8,4(sp)
   2c08c:	a809883a 	mov	r4,r21
   2c090:	103ee83a 	callr	r2
   2c094:	102f883a 	mov	r23,r2
   2c098:	da000117 	ldw	r8,4(sp)
   2c09c:	00bfe00e 	bge	zero,r2,2c020 <__reset+0xfff8c020>
   2c0a0:	9de7c83a 	sub	r19,r19,r23
   2c0a4:	98001f26 	beq	r19,zero,2c124 <__sfvwrite_r+0x2fc>
   2c0a8:	a0800217 	ldw	r2,8(r20)
   2c0ac:	e5f9883a 	add	fp,fp,r23
   2c0b0:	95e5c83a 	sub	r18,r18,r23
   2c0b4:	15efc83a 	sub	r23,r2,r23
   2c0b8:	a5c00215 	stw	r23,8(r20)
   2c0bc:	b83f8726 	beq	r23,zero,2bedc <__reset+0xfff8bedc>
   2c0c0:	903fe11e 	bne	r18,zero,2c048 <__reset+0xfff8c048>
   2c0c4:	8f000017 	ldw	fp,0(r17)
   2c0c8:	8c800117 	ldw	r18,4(r17)
   2c0cc:	0011883a 	mov	r8,zero
   2c0d0:	8c400204 	addi	r17,r17,8
   2c0d4:	003fdb06 	br	2c044 <__reset+0xfff8c044>
   2c0d8:	180d883a 	mov	r6,r3
   2c0dc:	e00b883a 	mov	r5,fp
   2c0e0:	da000115 	stw	r8,4(sp)
   2c0e4:	d8c00015 	stw	r3,0(sp)
   2c0e8:	002cd5c0 	call	2cd5c <memmove>
   2c0ec:	d8c00017 	ldw	r3,0(sp)
   2c0f0:	80800017 	ldw	r2,0(r16)
   2c0f4:	800b883a 	mov	r5,r16
   2c0f8:	a809883a 	mov	r4,r21
   2c0fc:	10c5883a 	add	r2,r2,r3
   2c100:	80800015 	stw	r2,0(r16)
   2c104:	d8c00015 	stw	r3,0(sp)
   2c108:	002dad40 	call	2dad4 <_fflush_r>
   2c10c:	d8c00017 	ldw	r3,0(sp)
   2c110:	da000117 	ldw	r8,4(sp)
   2c114:	103fc21e 	bne	r2,zero,2c020 <__reset+0xfff8c020>
   2c118:	182f883a 	mov	r23,r3
   2c11c:	9de7c83a 	sub	r19,r19,r23
   2c120:	983fe11e 	bne	r19,zero,2c0a8 <__reset+0xfff8c0a8>
   2c124:	800b883a 	mov	r5,r16
   2c128:	a809883a 	mov	r4,r21
   2c12c:	002dad40 	call	2dad4 <_fflush_r>
   2c130:	103fbb1e 	bne	r2,zero,2c020 <__reset+0xfff8c020>
   2c134:	0011883a 	mov	r8,zero
   2c138:	003fdb06 	br	2c0a8 <__reset+0xfff8c0a8>
   2c13c:	94c0012e 	bgeu	r18,r19,2c144 <__sfvwrite_r+0x31c>
   2c140:	9027883a 	mov	r19,r18
   2c144:	980d883a 	mov	r6,r19
   2c148:	e00b883a 	mov	r5,fp
   2c14c:	002cd5c0 	call	2cd5c <memmove>
   2c150:	80800217 	ldw	r2,8(r16)
   2c154:	80c00017 	ldw	r3,0(r16)
   2c158:	14c5c83a 	sub	r2,r2,r19
   2c15c:	1cc7883a 	add	r3,r3,r19
   2c160:	80800215 	stw	r2,8(r16)
   2c164:	80c00015 	stw	r3,0(r16)
   2c168:	10004326 	beq	r2,zero,2c278 <__sfvwrite_r+0x450>
   2c16c:	9805883a 	mov	r2,r19
   2c170:	003f8606 	br	2bf8c <__reset+0xfff8bf8c>
   2c174:	b00d883a 	mov	r6,r22
   2c178:	e00b883a 	mov	r5,fp
   2c17c:	da000115 	stw	r8,4(sp)
   2c180:	002cd5c0 	call	2cd5c <memmove>
   2c184:	80800217 	ldw	r2,8(r16)
   2c188:	80c00017 	ldw	r3,0(r16)
   2c18c:	da000117 	ldw	r8,4(sp)
   2c190:	1585c83a 	sub	r2,r2,r22
   2c194:	1dad883a 	add	r22,r3,r22
   2c198:	80800215 	stw	r2,8(r16)
   2c19c:	85800015 	stw	r22,0(r16)
   2c1a0:	003fbf06 	br	2c0a0 <__reset+0xfff8c0a0>
   2c1a4:	81000017 	ldw	r4,0(r16)
   2c1a8:	9027883a 	mov	r19,r18
   2c1ac:	902f883a 	mov	r23,r18
   2c1b0:	003f6c06 	br	2bf64 <__reset+0xfff8bf64>
   2c1b4:	900d883a 	mov	r6,r18
   2c1b8:	01400284 	movi	r5,10
   2c1bc:	e009883a 	mov	r4,fp
   2c1c0:	002cc780 	call	2cc78 <memchr>
   2c1c4:	10003e26 	beq	r2,zero,2c2c0 <__sfvwrite_r+0x498>
   2c1c8:	10800044 	addi	r2,r2,1
   2c1cc:	1727c83a 	sub	r19,r2,fp
   2c1d0:	02000044 	movi	r8,1
   2c1d4:	003f9d06 	br	2c04c <__reset+0xfff8c04c>
   2c1d8:	80800517 	ldw	r2,20(r16)
   2c1dc:	81400417 	ldw	r5,16(r16)
   2c1e0:	81c00017 	ldw	r7,0(r16)
   2c1e4:	10a7883a 	add	r19,r2,r2
   2c1e8:	9885883a 	add	r2,r19,r2
   2c1ec:	1026d7fa 	srli	r19,r2,31
   2c1f0:	396dc83a 	sub	r22,r7,r5
   2c1f4:	b1000044 	addi	r4,r22,1
   2c1f8:	9885883a 	add	r2,r19,r2
   2c1fc:	1027d07a 	srai	r19,r2,1
   2c200:	2485883a 	add	r2,r4,r18
   2c204:	980d883a 	mov	r6,r19
   2c208:	9880022e 	bgeu	r19,r2,2c214 <__sfvwrite_r+0x3ec>
   2c20c:	1027883a 	mov	r19,r2
   2c210:	100d883a 	mov	r6,r2
   2c214:	18c1000c 	andi	r3,r3,1024
   2c218:	18001c26 	beq	r3,zero,2c28c <__sfvwrite_r+0x464>
   2c21c:	300b883a 	mov	r5,r6
   2c220:	a809883a 	mov	r4,r21
   2c224:	002c46c0 	call	2c46c <_malloc_r>
   2c228:	102f883a 	mov	r23,r2
   2c22c:	10002926 	beq	r2,zero,2c2d4 <__sfvwrite_r+0x4ac>
   2c230:	81400417 	ldw	r5,16(r16)
   2c234:	b00d883a 	mov	r6,r22
   2c238:	1009883a 	mov	r4,r2
   2c23c:	002b6ac0 	call	2b6ac <memcpy>
   2c240:	8080030b 	ldhu	r2,12(r16)
   2c244:	00fedfc4 	movi	r3,-1153
   2c248:	10c4703a 	and	r2,r2,r3
   2c24c:	10802014 	ori	r2,r2,128
   2c250:	8080030d 	sth	r2,12(r16)
   2c254:	bd89883a 	add	r4,r23,r22
   2c258:	9d8fc83a 	sub	r7,r19,r22
   2c25c:	85c00415 	stw	r23,16(r16)
   2c260:	84c00515 	stw	r19,20(r16)
   2c264:	81000015 	stw	r4,0(r16)
   2c268:	9027883a 	mov	r19,r18
   2c26c:	81c00215 	stw	r7,8(r16)
   2c270:	902f883a 	mov	r23,r18
   2c274:	003f3b06 	br	2bf64 <__reset+0xfff8bf64>
   2c278:	800b883a 	mov	r5,r16
   2c27c:	a809883a 	mov	r4,r21
   2c280:	002dad40 	call	2dad4 <_fflush_r>
   2c284:	103fb926 	beq	r2,zero,2c16c <__reset+0xfff8c16c>
   2c288:	003f6506 	br	2c020 <__reset+0xfff8c020>
   2c28c:	a809883a 	mov	r4,r21
   2c290:	002ceb80 	call	2ceb8 <_realloc_r>
   2c294:	102f883a 	mov	r23,r2
   2c298:	103fee1e 	bne	r2,zero,2c254 <__reset+0xfff8c254>
   2c29c:	81400417 	ldw	r5,16(r16)
   2c2a0:	a809883a 	mov	r4,r21
   2c2a4:	002dc840 	call	2dc84 <_free_r>
   2c2a8:	8080030b 	ldhu	r2,12(r16)
   2c2ac:	00ffdfc4 	movi	r3,-129
   2c2b0:	1884703a 	and	r2,r3,r2
   2c2b4:	00c00304 	movi	r3,12
   2c2b8:	a8c00015 	stw	r3,0(r21)
   2c2bc:	003f5906 	br	2c024 <__reset+0xfff8c024>
   2c2c0:	94c00044 	addi	r19,r18,1
   2c2c4:	02000044 	movi	r8,1
   2c2c8:	003f6006 	br	2c04c <__reset+0xfff8c04c>
   2c2cc:	00bfffc4 	movi	r2,-1
   2c2d0:	003f0306 	br	2bee0 <__reset+0xfff8bee0>
   2c2d4:	00800304 	movi	r2,12
   2c2d8:	a8800015 	stw	r2,0(r21)
   2c2dc:	8080030b 	ldhu	r2,12(r16)
   2c2e0:	003f5006 	br	2c024 <__reset+0xfff8c024>

0002c2e4 <_fwalk>:
   2c2e4:	defff704 	addi	sp,sp,-36
   2c2e8:	dd000415 	stw	r20,16(sp)
   2c2ec:	dfc00815 	stw	ra,32(sp)
   2c2f0:	ddc00715 	stw	r23,28(sp)
   2c2f4:	dd800615 	stw	r22,24(sp)
   2c2f8:	dd400515 	stw	r21,20(sp)
   2c2fc:	dcc00315 	stw	r19,12(sp)
   2c300:	dc800215 	stw	r18,8(sp)
   2c304:	dc400115 	stw	r17,4(sp)
   2c308:	dc000015 	stw	r16,0(sp)
   2c30c:	2500b804 	addi	r20,r4,736
   2c310:	a0002326 	beq	r20,zero,2c3a0 <_fwalk+0xbc>
   2c314:	282b883a 	mov	r21,r5
   2c318:	002f883a 	mov	r23,zero
   2c31c:	05800044 	movi	r22,1
   2c320:	04ffffc4 	movi	r19,-1
   2c324:	a4400117 	ldw	r17,4(r20)
   2c328:	a4800217 	ldw	r18,8(r20)
   2c32c:	8c7fffc4 	addi	r17,r17,-1
   2c330:	88000d16 	blt	r17,zero,2c368 <_fwalk+0x84>
   2c334:	94000304 	addi	r16,r18,12
   2c338:	94800384 	addi	r18,r18,14
   2c33c:	8080000b 	ldhu	r2,0(r16)
   2c340:	8c7fffc4 	addi	r17,r17,-1
   2c344:	813ffd04 	addi	r4,r16,-12
   2c348:	b080042e 	bgeu	r22,r2,2c35c <_fwalk+0x78>
   2c34c:	9080000f 	ldh	r2,0(r18)
   2c350:	14c00226 	beq	r2,r19,2c35c <_fwalk+0x78>
   2c354:	a83ee83a 	callr	r21
   2c358:	b8aeb03a 	or	r23,r23,r2
   2c35c:	84001a04 	addi	r16,r16,104
   2c360:	94801a04 	addi	r18,r18,104
   2c364:	8cfff51e 	bne	r17,r19,2c33c <__reset+0xfff8c33c>
   2c368:	a5000017 	ldw	r20,0(r20)
   2c36c:	a03fed1e 	bne	r20,zero,2c324 <__reset+0xfff8c324>
   2c370:	b805883a 	mov	r2,r23
   2c374:	dfc00817 	ldw	ra,32(sp)
   2c378:	ddc00717 	ldw	r23,28(sp)
   2c37c:	dd800617 	ldw	r22,24(sp)
   2c380:	dd400517 	ldw	r21,20(sp)
   2c384:	dd000417 	ldw	r20,16(sp)
   2c388:	dcc00317 	ldw	r19,12(sp)
   2c38c:	dc800217 	ldw	r18,8(sp)
   2c390:	dc400117 	ldw	r17,4(sp)
   2c394:	dc000017 	ldw	r16,0(sp)
   2c398:	dec00904 	addi	sp,sp,36
   2c39c:	f800283a 	ret
   2c3a0:	002f883a 	mov	r23,zero
   2c3a4:	003ff206 	br	2c370 <__reset+0xfff8c370>

0002c3a8 <_fwalk_reent>:
   2c3a8:	defff704 	addi	sp,sp,-36
   2c3ac:	dd000415 	stw	r20,16(sp)
   2c3b0:	dfc00815 	stw	ra,32(sp)
   2c3b4:	ddc00715 	stw	r23,28(sp)
   2c3b8:	dd800615 	stw	r22,24(sp)
   2c3bc:	dd400515 	stw	r21,20(sp)
   2c3c0:	dcc00315 	stw	r19,12(sp)
   2c3c4:	dc800215 	stw	r18,8(sp)
   2c3c8:	dc400115 	stw	r17,4(sp)
   2c3cc:	dc000015 	stw	r16,0(sp)
   2c3d0:	2500b804 	addi	r20,r4,736
   2c3d4:	a0002326 	beq	r20,zero,2c464 <_fwalk_reent+0xbc>
   2c3d8:	282b883a 	mov	r21,r5
   2c3dc:	2027883a 	mov	r19,r4
   2c3e0:	002f883a 	mov	r23,zero
   2c3e4:	05800044 	movi	r22,1
   2c3e8:	04bfffc4 	movi	r18,-1
   2c3ec:	a4400117 	ldw	r17,4(r20)
   2c3f0:	a4000217 	ldw	r16,8(r20)
   2c3f4:	8c7fffc4 	addi	r17,r17,-1
   2c3f8:	88000c16 	blt	r17,zero,2c42c <_fwalk_reent+0x84>
   2c3fc:	84000304 	addi	r16,r16,12
   2c400:	8080000b 	ldhu	r2,0(r16)
   2c404:	8c7fffc4 	addi	r17,r17,-1
   2c408:	817ffd04 	addi	r5,r16,-12
   2c40c:	b080052e 	bgeu	r22,r2,2c424 <_fwalk_reent+0x7c>
   2c410:	8080008f 	ldh	r2,2(r16)
   2c414:	9809883a 	mov	r4,r19
   2c418:	14800226 	beq	r2,r18,2c424 <_fwalk_reent+0x7c>
   2c41c:	a83ee83a 	callr	r21
   2c420:	b8aeb03a 	or	r23,r23,r2
   2c424:	84001a04 	addi	r16,r16,104
   2c428:	8cbff51e 	bne	r17,r18,2c400 <__reset+0xfff8c400>
   2c42c:	a5000017 	ldw	r20,0(r20)
   2c430:	a03fee1e 	bne	r20,zero,2c3ec <__reset+0xfff8c3ec>
   2c434:	b805883a 	mov	r2,r23
   2c438:	dfc00817 	ldw	ra,32(sp)
   2c43c:	ddc00717 	ldw	r23,28(sp)
   2c440:	dd800617 	ldw	r22,24(sp)
   2c444:	dd400517 	ldw	r21,20(sp)
   2c448:	dd000417 	ldw	r20,16(sp)
   2c44c:	dcc00317 	ldw	r19,12(sp)
   2c450:	dc800217 	ldw	r18,8(sp)
   2c454:	dc400117 	ldw	r17,4(sp)
   2c458:	dc000017 	ldw	r16,0(sp)
   2c45c:	dec00904 	addi	sp,sp,36
   2c460:	f800283a 	ret
   2c464:	002f883a 	mov	r23,zero
   2c468:	003ff206 	br	2c434 <__reset+0xfff8c434>

0002c46c <_malloc_r>:
   2c46c:	defff504 	addi	sp,sp,-44
   2c470:	dc800315 	stw	r18,12(sp)
   2c474:	dfc00a15 	stw	ra,40(sp)
   2c478:	df000915 	stw	fp,36(sp)
   2c47c:	ddc00815 	stw	r23,32(sp)
   2c480:	dd800715 	stw	r22,28(sp)
   2c484:	dd400615 	stw	r21,24(sp)
   2c488:	dd000515 	stw	r20,20(sp)
   2c48c:	dcc00415 	stw	r19,16(sp)
   2c490:	dc400215 	stw	r17,8(sp)
   2c494:	dc000115 	stw	r16,4(sp)
   2c498:	288002c4 	addi	r2,r5,11
   2c49c:	00c00584 	movi	r3,22
   2c4a0:	2025883a 	mov	r18,r4
   2c4a4:	18807f2e 	bgeu	r3,r2,2c6a4 <_malloc_r+0x238>
   2c4a8:	047ffe04 	movi	r17,-8
   2c4ac:	1462703a 	and	r17,r2,r17
   2c4b0:	8800a316 	blt	r17,zero,2c740 <_malloc_r+0x2d4>
   2c4b4:	8940a236 	bltu	r17,r5,2c740 <_malloc_r+0x2d4>
   2c4b8:	002e7500 	call	2e750 <__malloc_lock>
   2c4bc:	00807dc4 	movi	r2,503
   2c4c0:	1441e92e 	bgeu	r2,r17,2cc68 <_malloc_r+0x7fc>
   2c4c4:	8804d27a 	srli	r2,r17,9
   2c4c8:	1000a126 	beq	r2,zero,2c750 <_malloc_r+0x2e4>
   2c4cc:	00c00104 	movi	r3,4
   2c4d0:	18811e36 	bltu	r3,r2,2c94c <_malloc_r+0x4e0>
   2c4d4:	8804d1ba 	srli	r2,r17,6
   2c4d8:	12000e44 	addi	r8,r2,57
   2c4dc:	11c00e04 	addi	r7,r2,56
   2c4e0:	4209883a 	add	r4,r8,r8
   2c4e4:	04c000f4 	movhi	r19,3
   2c4e8:	2109883a 	add	r4,r4,r4
   2c4ec:	9ccd2e04 	addi	r19,r19,13496
   2c4f0:	2109883a 	add	r4,r4,r4
   2c4f4:	9909883a 	add	r4,r19,r4
   2c4f8:	24000117 	ldw	r16,4(r4)
   2c4fc:	213ffe04 	addi	r4,r4,-8
   2c500:	24009726 	beq	r4,r16,2c760 <_malloc_r+0x2f4>
   2c504:	80800117 	ldw	r2,4(r16)
   2c508:	01bfff04 	movi	r6,-4
   2c50c:	014003c4 	movi	r5,15
   2c510:	1184703a 	and	r2,r2,r6
   2c514:	1447c83a 	sub	r3,r2,r17
   2c518:	28c00716 	blt	r5,r3,2c538 <_malloc_r+0xcc>
   2c51c:	1800920e 	bge	r3,zero,2c768 <_malloc_r+0x2fc>
   2c520:	84000317 	ldw	r16,12(r16)
   2c524:	24008e26 	beq	r4,r16,2c760 <_malloc_r+0x2f4>
   2c528:	80800117 	ldw	r2,4(r16)
   2c52c:	1184703a 	and	r2,r2,r6
   2c530:	1447c83a 	sub	r3,r2,r17
   2c534:	28fff90e 	bge	r5,r3,2c51c <__reset+0xfff8c51c>
   2c538:	3809883a 	mov	r4,r7
   2c53c:	018000f4 	movhi	r6,3
   2c540:	9c000417 	ldw	r16,16(r19)
   2c544:	318d2e04 	addi	r6,r6,13496
   2c548:	32000204 	addi	r8,r6,8
   2c54c:	82013426 	beq	r16,r8,2ca20 <_malloc_r+0x5b4>
   2c550:	80c00117 	ldw	r3,4(r16)
   2c554:	00bfff04 	movi	r2,-4
   2c558:	188e703a 	and	r7,r3,r2
   2c55c:	3c45c83a 	sub	r2,r7,r17
   2c560:	00c003c4 	movi	r3,15
   2c564:	18811f16 	blt	r3,r2,2c9e4 <_malloc_r+0x578>
   2c568:	32000515 	stw	r8,20(r6)
   2c56c:	32000415 	stw	r8,16(r6)
   2c570:	10007f0e 	bge	r2,zero,2c770 <_malloc_r+0x304>
   2c574:	00807fc4 	movi	r2,511
   2c578:	11c0fd36 	bltu	r2,r7,2c970 <_malloc_r+0x504>
   2c57c:	3806d0fa 	srli	r3,r7,3
   2c580:	01c00044 	movi	r7,1
   2c584:	30800117 	ldw	r2,4(r6)
   2c588:	19400044 	addi	r5,r3,1
   2c58c:	294b883a 	add	r5,r5,r5
   2c590:	1807d0ba 	srai	r3,r3,2
   2c594:	294b883a 	add	r5,r5,r5
   2c598:	294b883a 	add	r5,r5,r5
   2c59c:	298b883a 	add	r5,r5,r6
   2c5a0:	38c6983a 	sll	r3,r7,r3
   2c5a4:	29c00017 	ldw	r7,0(r5)
   2c5a8:	2a7ffe04 	addi	r9,r5,-8
   2c5ac:	1886b03a 	or	r3,r3,r2
   2c5b0:	82400315 	stw	r9,12(r16)
   2c5b4:	81c00215 	stw	r7,8(r16)
   2c5b8:	30c00115 	stw	r3,4(r6)
   2c5bc:	2c000015 	stw	r16,0(r5)
   2c5c0:	3c000315 	stw	r16,12(r7)
   2c5c4:	2005d0ba 	srai	r2,r4,2
   2c5c8:	01400044 	movi	r5,1
   2c5cc:	288a983a 	sll	r5,r5,r2
   2c5d0:	19406f36 	bltu	r3,r5,2c790 <_malloc_r+0x324>
   2c5d4:	28c4703a 	and	r2,r5,r3
   2c5d8:	10000a1e 	bne	r2,zero,2c604 <_malloc_r+0x198>
   2c5dc:	00bfff04 	movi	r2,-4
   2c5e0:	294b883a 	add	r5,r5,r5
   2c5e4:	2088703a 	and	r4,r4,r2
   2c5e8:	28c4703a 	and	r2,r5,r3
   2c5ec:	21000104 	addi	r4,r4,4
   2c5f0:	1000041e 	bne	r2,zero,2c604 <_malloc_r+0x198>
   2c5f4:	294b883a 	add	r5,r5,r5
   2c5f8:	28c4703a 	and	r2,r5,r3
   2c5fc:	21000104 	addi	r4,r4,4
   2c600:	103ffc26 	beq	r2,zero,2c5f4 <__reset+0xfff8c5f4>
   2c604:	02bfff04 	movi	r10,-4
   2c608:	024003c4 	movi	r9,15
   2c60c:	21800044 	addi	r6,r4,1
   2c610:	318d883a 	add	r6,r6,r6
   2c614:	318d883a 	add	r6,r6,r6
   2c618:	318d883a 	add	r6,r6,r6
   2c61c:	998d883a 	add	r6,r19,r6
   2c620:	333ffe04 	addi	r12,r6,-8
   2c624:	2017883a 	mov	r11,r4
   2c628:	31800104 	addi	r6,r6,4
   2c62c:	34000017 	ldw	r16,0(r6)
   2c630:	31fffd04 	addi	r7,r6,-12
   2c634:	81c0041e 	bne	r16,r7,2c648 <_malloc_r+0x1dc>
   2c638:	0000fb06 	br	2ca28 <_malloc_r+0x5bc>
   2c63c:	1801030e 	bge	r3,zero,2ca4c <_malloc_r+0x5e0>
   2c640:	84000317 	ldw	r16,12(r16)
   2c644:	81c0f826 	beq	r16,r7,2ca28 <_malloc_r+0x5bc>
   2c648:	80800117 	ldw	r2,4(r16)
   2c64c:	1284703a 	and	r2,r2,r10
   2c650:	1447c83a 	sub	r3,r2,r17
   2c654:	48fff90e 	bge	r9,r3,2c63c <__reset+0xfff8c63c>
   2c658:	80800317 	ldw	r2,12(r16)
   2c65c:	81000217 	ldw	r4,8(r16)
   2c660:	89400054 	ori	r5,r17,1
   2c664:	81400115 	stw	r5,4(r16)
   2c668:	20800315 	stw	r2,12(r4)
   2c66c:	11000215 	stw	r4,8(r2)
   2c670:	8463883a 	add	r17,r16,r17
   2c674:	9c400515 	stw	r17,20(r19)
   2c678:	9c400415 	stw	r17,16(r19)
   2c67c:	18800054 	ori	r2,r3,1
   2c680:	88800115 	stw	r2,4(r17)
   2c684:	8a000315 	stw	r8,12(r17)
   2c688:	8a000215 	stw	r8,8(r17)
   2c68c:	88e3883a 	add	r17,r17,r3
   2c690:	88c00015 	stw	r3,0(r17)
   2c694:	9009883a 	mov	r4,r18
   2c698:	002e7740 	call	2e774 <__malloc_unlock>
   2c69c:	80800204 	addi	r2,r16,8
   2c6a0:	00001b06 	br	2c710 <_malloc_r+0x2a4>
   2c6a4:	04400404 	movi	r17,16
   2c6a8:	89402536 	bltu	r17,r5,2c740 <_malloc_r+0x2d4>
   2c6ac:	002e7500 	call	2e750 <__malloc_lock>
   2c6b0:	00800184 	movi	r2,6
   2c6b4:	01000084 	movi	r4,2
   2c6b8:	04c000f4 	movhi	r19,3
   2c6bc:	1085883a 	add	r2,r2,r2
   2c6c0:	9ccd2e04 	addi	r19,r19,13496
   2c6c4:	1085883a 	add	r2,r2,r2
   2c6c8:	9885883a 	add	r2,r19,r2
   2c6cc:	14000117 	ldw	r16,4(r2)
   2c6d0:	10fffe04 	addi	r3,r2,-8
   2c6d4:	80c0d926 	beq	r16,r3,2ca3c <_malloc_r+0x5d0>
   2c6d8:	80c00117 	ldw	r3,4(r16)
   2c6dc:	81000317 	ldw	r4,12(r16)
   2c6e0:	00bfff04 	movi	r2,-4
   2c6e4:	1884703a 	and	r2,r3,r2
   2c6e8:	81400217 	ldw	r5,8(r16)
   2c6ec:	8085883a 	add	r2,r16,r2
   2c6f0:	10c00117 	ldw	r3,4(r2)
   2c6f4:	29000315 	stw	r4,12(r5)
   2c6f8:	21400215 	stw	r5,8(r4)
   2c6fc:	18c00054 	ori	r3,r3,1
   2c700:	10c00115 	stw	r3,4(r2)
   2c704:	9009883a 	mov	r4,r18
   2c708:	002e7740 	call	2e774 <__malloc_unlock>
   2c70c:	80800204 	addi	r2,r16,8
   2c710:	dfc00a17 	ldw	ra,40(sp)
   2c714:	df000917 	ldw	fp,36(sp)
   2c718:	ddc00817 	ldw	r23,32(sp)
   2c71c:	dd800717 	ldw	r22,28(sp)
   2c720:	dd400617 	ldw	r21,24(sp)
   2c724:	dd000517 	ldw	r20,20(sp)
   2c728:	dcc00417 	ldw	r19,16(sp)
   2c72c:	dc800317 	ldw	r18,12(sp)
   2c730:	dc400217 	ldw	r17,8(sp)
   2c734:	dc000117 	ldw	r16,4(sp)
   2c738:	dec00b04 	addi	sp,sp,44
   2c73c:	f800283a 	ret
   2c740:	00800304 	movi	r2,12
   2c744:	90800015 	stw	r2,0(r18)
   2c748:	0005883a 	mov	r2,zero
   2c74c:	003ff006 	br	2c710 <__reset+0xfff8c710>
   2c750:	01002004 	movi	r4,128
   2c754:	02001004 	movi	r8,64
   2c758:	01c00fc4 	movi	r7,63
   2c75c:	003f6106 	br	2c4e4 <__reset+0xfff8c4e4>
   2c760:	4009883a 	mov	r4,r8
   2c764:	003f7506 	br	2c53c <__reset+0xfff8c53c>
   2c768:	81000317 	ldw	r4,12(r16)
   2c76c:	003fde06 	br	2c6e8 <__reset+0xfff8c6e8>
   2c770:	81c5883a 	add	r2,r16,r7
   2c774:	11400117 	ldw	r5,4(r2)
   2c778:	9009883a 	mov	r4,r18
   2c77c:	29400054 	ori	r5,r5,1
   2c780:	11400115 	stw	r5,4(r2)
   2c784:	002e7740 	call	2e774 <__malloc_unlock>
   2c788:	80800204 	addi	r2,r16,8
   2c78c:	003fe006 	br	2c710 <__reset+0xfff8c710>
   2c790:	9c000217 	ldw	r16,8(r19)
   2c794:	00bfff04 	movi	r2,-4
   2c798:	85800117 	ldw	r22,4(r16)
   2c79c:	b0ac703a 	and	r22,r22,r2
   2c7a0:	b4400336 	bltu	r22,r17,2c7b0 <_malloc_r+0x344>
   2c7a4:	b445c83a 	sub	r2,r22,r17
   2c7a8:	00c003c4 	movi	r3,15
   2c7ac:	18805d16 	blt	r3,r2,2c924 <_malloc_r+0x4b8>
   2c7b0:	05c000f4 	movhi	r23,3
   2c7b4:	008000f4 	movhi	r2,3
   2c7b8:	10934604 	addi	r2,r2,19736
   2c7bc:	bdd31904 	addi	r23,r23,19556
   2c7c0:	15400017 	ldw	r21,0(r2)
   2c7c4:	b8c00017 	ldw	r3,0(r23)
   2c7c8:	00bfffc4 	movi	r2,-1
   2c7cc:	858d883a 	add	r6,r16,r22
   2c7d0:	8d6b883a 	add	r21,r17,r21
   2c7d4:	1880ea26 	beq	r3,r2,2cb80 <_malloc_r+0x714>
   2c7d8:	ad4403c4 	addi	r21,r21,4111
   2c7dc:	00bc0004 	movi	r2,-4096
   2c7e0:	a8aa703a 	and	r21,r21,r2
   2c7e4:	a80b883a 	mov	r5,r21
   2c7e8:	9009883a 	mov	r4,r18
   2c7ec:	d9800015 	stw	r6,0(sp)
   2c7f0:	002d41c0 	call	2d41c <_sbrk_r>
   2c7f4:	1029883a 	mov	r20,r2
   2c7f8:	00bfffc4 	movi	r2,-1
   2c7fc:	d9800017 	ldw	r6,0(sp)
   2c800:	a080e826 	beq	r20,r2,2cba4 <_malloc_r+0x738>
   2c804:	a180a636 	bltu	r20,r6,2caa0 <_malloc_r+0x634>
   2c808:	07000134 	movhi	fp,4
   2c80c:	e723bc04 	addi	fp,fp,-28944
   2c810:	e0800017 	ldw	r2,0(fp)
   2c814:	a887883a 	add	r3,r21,r2
   2c818:	e0c00015 	stw	r3,0(fp)
   2c81c:	3500e626 	beq	r6,r20,2cbb8 <_malloc_r+0x74c>
   2c820:	b9000017 	ldw	r4,0(r23)
   2c824:	00bfffc4 	movi	r2,-1
   2c828:	2080ee26 	beq	r4,r2,2cbe4 <_malloc_r+0x778>
   2c82c:	a185c83a 	sub	r2,r20,r6
   2c830:	10c5883a 	add	r2,r2,r3
   2c834:	e0800015 	stw	r2,0(fp)
   2c838:	a0c001cc 	andi	r3,r20,7
   2c83c:	1800bc26 	beq	r3,zero,2cb30 <_malloc_r+0x6c4>
   2c840:	a0e9c83a 	sub	r20,r20,r3
   2c844:	00840204 	movi	r2,4104
   2c848:	a5000204 	addi	r20,r20,8
   2c84c:	10c7c83a 	sub	r3,r2,r3
   2c850:	a545883a 	add	r2,r20,r21
   2c854:	1083ffcc 	andi	r2,r2,4095
   2c858:	18abc83a 	sub	r21,r3,r2
   2c85c:	a80b883a 	mov	r5,r21
   2c860:	9009883a 	mov	r4,r18
   2c864:	002d41c0 	call	2d41c <_sbrk_r>
   2c868:	00ffffc4 	movi	r3,-1
   2c86c:	10c0e126 	beq	r2,r3,2cbf4 <_malloc_r+0x788>
   2c870:	1505c83a 	sub	r2,r2,r20
   2c874:	1545883a 	add	r2,r2,r21
   2c878:	10800054 	ori	r2,r2,1
   2c87c:	e0c00017 	ldw	r3,0(fp)
   2c880:	9d000215 	stw	r20,8(r19)
   2c884:	a0800115 	stw	r2,4(r20)
   2c888:	a8c7883a 	add	r3,r21,r3
   2c88c:	e0c00015 	stw	r3,0(fp)
   2c890:	84c00e26 	beq	r16,r19,2c8cc <_malloc_r+0x460>
   2c894:	018003c4 	movi	r6,15
   2c898:	3580a72e 	bgeu	r6,r22,2cb38 <_malloc_r+0x6cc>
   2c89c:	81400117 	ldw	r5,4(r16)
   2c8a0:	013ffe04 	movi	r4,-8
   2c8a4:	b0bffd04 	addi	r2,r22,-12
   2c8a8:	1104703a 	and	r2,r2,r4
   2c8ac:	2900004c 	andi	r4,r5,1
   2c8b0:	2088b03a 	or	r4,r4,r2
   2c8b4:	81000115 	stw	r4,4(r16)
   2c8b8:	01400144 	movi	r5,5
   2c8bc:	8089883a 	add	r4,r16,r2
   2c8c0:	21400115 	stw	r5,4(r4)
   2c8c4:	21400215 	stw	r5,8(r4)
   2c8c8:	3080cd36 	bltu	r6,r2,2cc00 <_malloc_r+0x794>
   2c8cc:	008000f4 	movhi	r2,3
   2c8d0:	10934504 	addi	r2,r2,19732
   2c8d4:	11000017 	ldw	r4,0(r2)
   2c8d8:	20c0012e 	bgeu	r4,r3,2c8e0 <_malloc_r+0x474>
   2c8dc:	10c00015 	stw	r3,0(r2)
   2c8e0:	008000f4 	movhi	r2,3
   2c8e4:	10934404 	addi	r2,r2,19728
   2c8e8:	11000017 	ldw	r4,0(r2)
   2c8ec:	9c000217 	ldw	r16,8(r19)
   2c8f0:	20c0012e 	bgeu	r4,r3,2c8f8 <_malloc_r+0x48c>
   2c8f4:	10c00015 	stw	r3,0(r2)
   2c8f8:	80c00117 	ldw	r3,4(r16)
   2c8fc:	00bfff04 	movi	r2,-4
   2c900:	1886703a 	and	r3,r3,r2
   2c904:	1c45c83a 	sub	r2,r3,r17
   2c908:	1c400236 	bltu	r3,r17,2c914 <_malloc_r+0x4a8>
   2c90c:	00c003c4 	movi	r3,15
   2c910:	18800416 	blt	r3,r2,2c924 <_malloc_r+0x4b8>
   2c914:	9009883a 	mov	r4,r18
   2c918:	002e7740 	call	2e774 <__malloc_unlock>
   2c91c:	0005883a 	mov	r2,zero
   2c920:	003f7b06 	br	2c710 <__reset+0xfff8c710>
   2c924:	88c00054 	ori	r3,r17,1
   2c928:	80c00115 	stw	r3,4(r16)
   2c92c:	8463883a 	add	r17,r16,r17
   2c930:	10800054 	ori	r2,r2,1
   2c934:	9c400215 	stw	r17,8(r19)
   2c938:	88800115 	stw	r2,4(r17)
   2c93c:	9009883a 	mov	r4,r18
   2c940:	002e7740 	call	2e774 <__malloc_unlock>
   2c944:	80800204 	addi	r2,r16,8
   2c948:	003f7106 	br	2c710 <__reset+0xfff8c710>
   2c94c:	00c00504 	movi	r3,20
   2c950:	18804a2e 	bgeu	r3,r2,2ca7c <_malloc_r+0x610>
   2c954:	00c01504 	movi	r3,84
   2c958:	18806e36 	bltu	r3,r2,2cb14 <_malloc_r+0x6a8>
   2c95c:	8804d33a 	srli	r2,r17,12
   2c960:	12001bc4 	addi	r8,r2,111
   2c964:	11c01b84 	addi	r7,r2,110
   2c968:	4209883a 	add	r4,r8,r8
   2c96c:	003edd06 	br	2c4e4 <__reset+0xfff8c4e4>
   2c970:	3804d27a 	srli	r2,r7,9
   2c974:	00c00104 	movi	r3,4
   2c978:	1880442e 	bgeu	r3,r2,2ca8c <_malloc_r+0x620>
   2c97c:	00c00504 	movi	r3,20
   2c980:	18808136 	bltu	r3,r2,2cb88 <_malloc_r+0x71c>
   2c984:	11401704 	addi	r5,r2,92
   2c988:	10c016c4 	addi	r3,r2,91
   2c98c:	294b883a 	add	r5,r5,r5
   2c990:	294b883a 	add	r5,r5,r5
   2c994:	294b883a 	add	r5,r5,r5
   2c998:	994b883a 	add	r5,r19,r5
   2c99c:	28800017 	ldw	r2,0(r5)
   2c9a0:	018000f4 	movhi	r6,3
   2c9a4:	297ffe04 	addi	r5,r5,-8
   2c9a8:	318d2e04 	addi	r6,r6,13496
   2c9ac:	28806526 	beq	r5,r2,2cb44 <_malloc_r+0x6d8>
   2c9b0:	01bfff04 	movi	r6,-4
   2c9b4:	10c00117 	ldw	r3,4(r2)
   2c9b8:	1986703a 	and	r3,r3,r6
   2c9bc:	38c0022e 	bgeu	r7,r3,2c9c8 <_malloc_r+0x55c>
   2c9c0:	10800217 	ldw	r2,8(r2)
   2c9c4:	28bffb1e 	bne	r5,r2,2c9b4 <__reset+0xfff8c9b4>
   2c9c8:	11400317 	ldw	r5,12(r2)
   2c9cc:	98c00117 	ldw	r3,4(r19)
   2c9d0:	81400315 	stw	r5,12(r16)
   2c9d4:	80800215 	stw	r2,8(r16)
   2c9d8:	2c000215 	stw	r16,8(r5)
   2c9dc:	14000315 	stw	r16,12(r2)
   2c9e0:	003ef806 	br	2c5c4 <__reset+0xfff8c5c4>
   2c9e4:	88c00054 	ori	r3,r17,1
   2c9e8:	80c00115 	stw	r3,4(r16)
   2c9ec:	8463883a 	add	r17,r16,r17
   2c9f0:	34400515 	stw	r17,20(r6)
   2c9f4:	34400415 	stw	r17,16(r6)
   2c9f8:	10c00054 	ori	r3,r2,1
   2c9fc:	8a000315 	stw	r8,12(r17)
   2ca00:	8a000215 	stw	r8,8(r17)
   2ca04:	88c00115 	stw	r3,4(r17)
   2ca08:	88a3883a 	add	r17,r17,r2
   2ca0c:	88800015 	stw	r2,0(r17)
   2ca10:	9009883a 	mov	r4,r18
   2ca14:	002e7740 	call	2e774 <__malloc_unlock>
   2ca18:	80800204 	addi	r2,r16,8
   2ca1c:	003f3c06 	br	2c710 <__reset+0xfff8c710>
   2ca20:	30c00117 	ldw	r3,4(r6)
   2ca24:	003ee706 	br	2c5c4 <__reset+0xfff8c5c4>
   2ca28:	5ac00044 	addi	r11,r11,1
   2ca2c:	588000cc 	andi	r2,r11,3
   2ca30:	31800204 	addi	r6,r6,8
   2ca34:	103efd1e 	bne	r2,zero,2c62c <__reset+0xfff8c62c>
   2ca38:	00002406 	br	2cacc <_malloc_r+0x660>
   2ca3c:	14000317 	ldw	r16,12(r2)
   2ca40:	143f251e 	bne	r2,r16,2c6d8 <__reset+0xfff8c6d8>
   2ca44:	21000084 	addi	r4,r4,2
   2ca48:	003ebc06 	br	2c53c <__reset+0xfff8c53c>
   2ca4c:	8085883a 	add	r2,r16,r2
   2ca50:	10c00117 	ldw	r3,4(r2)
   2ca54:	81000317 	ldw	r4,12(r16)
   2ca58:	81400217 	ldw	r5,8(r16)
   2ca5c:	18c00054 	ori	r3,r3,1
   2ca60:	10c00115 	stw	r3,4(r2)
   2ca64:	29000315 	stw	r4,12(r5)
   2ca68:	21400215 	stw	r5,8(r4)
   2ca6c:	9009883a 	mov	r4,r18
   2ca70:	002e7740 	call	2e774 <__malloc_unlock>
   2ca74:	80800204 	addi	r2,r16,8
   2ca78:	003f2506 	br	2c710 <__reset+0xfff8c710>
   2ca7c:	12001704 	addi	r8,r2,92
   2ca80:	11c016c4 	addi	r7,r2,91
   2ca84:	4209883a 	add	r4,r8,r8
   2ca88:	003e9606 	br	2c4e4 <__reset+0xfff8c4e4>
   2ca8c:	3804d1ba 	srli	r2,r7,6
   2ca90:	11400e44 	addi	r5,r2,57
   2ca94:	10c00e04 	addi	r3,r2,56
   2ca98:	294b883a 	add	r5,r5,r5
   2ca9c:	003fbc06 	br	2c990 <__reset+0xfff8c990>
   2caa0:	84ff5926 	beq	r16,r19,2c808 <__reset+0xfff8c808>
   2caa4:	008000f4 	movhi	r2,3
   2caa8:	108d2e04 	addi	r2,r2,13496
   2caac:	14000217 	ldw	r16,8(r2)
   2cab0:	00bfff04 	movi	r2,-4
   2cab4:	80c00117 	ldw	r3,4(r16)
   2cab8:	1886703a 	and	r3,r3,r2
   2cabc:	003f9106 	br	2c904 <__reset+0xfff8c904>
   2cac0:	60800217 	ldw	r2,8(r12)
   2cac4:	213fffc4 	addi	r4,r4,-1
   2cac8:	1300651e 	bne	r2,r12,2cc60 <_malloc_r+0x7f4>
   2cacc:	208000cc 	andi	r2,r4,3
   2cad0:	633ffe04 	addi	r12,r12,-8
   2cad4:	103ffa1e 	bne	r2,zero,2cac0 <__reset+0xfff8cac0>
   2cad8:	98800117 	ldw	r2,4(r19)
   2cadc:	0146303a 	nor	r3,zero,r5
   2cae0:	1884703a 	and	r2,r3,r2
   2cae4:	98800115 	stw	r2,4(r19)
   2cae8:	294b883a 	add	r5,r5,r5
   2caec:	117f2836 	bltu	r2,r5,2c790 <__reset+0xfff8c790>
   2caf0:	283f2726 	beq	r5,zero,2c790 <__reset+0xfff8c790>
   2caf4:	2886703a 	and	r3,r5,r2
   2caf8:	5809883a 	mov	r4,r11
   2cafc:	183ec31e 	bne	r3,zero,2c60c <__reset+0xfff8c60c>
   2cb00:	294b883a 	add	r5,r5,r5
   2cb04:	2886703a 	and	r3,r5,r2
   2cb08:	21000104 	addi	r4,r4,4
   2cb0c:	183ffc26 	beq	r3,zero,2cb00 <__reset+0xfff8cb00>
   2cb10:	003ebe06 	br	2c60c <__reset+0xfff8c60c>
   2cb14:	00c05504 	movi	r3,340
   2cb18:	18801236 	bltu	r3,r2,2cb64 <_malloc_r+0x6f8>
   2cb1c:	8804d3fa 	srli	r2,r17,15
   2cb20:	12001e04 	addi	r8,r2,120
   2cb24:	11c01dc4 	addi	r7,r2,119
   2cb28:	4209883a 	add	r4,r8,r8
   2cb2c:	003e6d06 	br	2c4e4 <__reset+0xfff8c4e4>
   2cb30:	00c40004 	movi	r3,4096
   2cb34:	003f4606 	br	2c850 <__reset+0xfff8c850>
   2cb38:	00800044 	movi	r2,1
   2cb3c:	a0800115 	stw	r2,4(r20)
   2cb40:	003f7406 	br	2c914 <__reset+0xfff8c914>
   2cb44:	1805d0ba 	srai	r2,r3,2
   2cb48:	01c00044 	movi	r7,1
   2cb4c:	30c00117 	ldw	r3,4(r6)
   2cb50:	388e983a 	sll	r7,r7,r2
   2cb54:	2805883a 	mov	r2,r5
   2cb58:	38c6b03a 	or	r3,r7,r3
   2cb5c:	30c00115 	stw	r3,4(r6)
   2cb60:	003f9b06 	br	2c9d0 <__reset+0xfff8c9d0>
   2cb64:	00c15504 	movi	r3,1364
   2cb68:	18801a36 	bltu	r3,r2,2cbd4 <_malloc_r+0x768>
   2cb6c:	8804d4ba 	srli	r2,r17,18
   2cb70:	12001f44 	addi	r8,r2,125
   2cb74:	11c01f04 	addi	r7,r2,124
   2cb78:	4209883a 	add	r4,r8,r8
   2cb7c:	003e5906 	br	2c4e4 <__reset+0xfff8c4e4>
   2cb80:	ad400404 	addi	r21,r21,16
   2cb84:	003f1706 	br	2c7e4 <__reset+0xfff8c7e4>
   2cb88:	00c01504 	movi	r3,84
   2cb8c:	18802336 	bltu	r3,r2,2cc1c <_malloc_r+0x7b0>
   2cb90:	3804d33a 	srli	r2,r7,12
   2cb94:	11401bc4 	addi	r5,r2,111
   2cb98:	10c01b84 	addi	r3,r2,110
   2cb9c:	294b883a 	add	r5,r5,r5
   2cba0:	003f7b06 	br	2c990 <__reset+0xfff8c990>
   2cba4:	9c000217 	ldw	r16,8(r19)
   2cba8:	00bfff04 	movi	r2,-4
   2cbac:	80c00117 	ldw	r3,4(r16)
   2cbb0:	1886703a 	and	r3,r3,r2
   2cbb4:	003f5306 	br	2c904 <__reset+0xfff8c904>
   2cbb8:	3083ffcc 	andi	r2,r6,4095
   2cbbc:	103f181e 	bne	r2,zero,2c820 <__reset+0xfff8c820>
   2cbc0:	99000217 	ldw	r4,8(r19)
   2cbc4:	b545883a 	add	r2,r22,r21
   2cbc8:	10800054 	ori	r2,r2,1
   2cbcc:	20800115 	stw	r2,4(r4)
   2cbd0:	003f3e06 	br	2c8cc <__reset+0xfff8c8cc>
   2cbd4:	01003f84 	movi	r4,254
   2cbd8:	02001fc4 	movi	r8,127
   2cbdc:	01c01f84 	movi	r7,126
   2cbe0:	003e4006 	br	2c4e4 <__reset+0xfff8c4e4>
   2cbe4:	008000f4 	movhi	r2,3
   2cbe8:	10931904 	addi	r2,r2,19556
   2cbec:	15000015 	stw	r20,0(r2)
   2cbf0:	003f1106 	br	2c838 <__reset+0xfff8c838>
   2cbf4:	00800044 	movi	r2,1
   2cbf8:	002b883a 	mov	r21,zero
   2cbfc:	003f1f06 	br	2c87c <__reset+0xfff8c87c>
   2cc00:	81400204 	addi	r5,r16,8
   2cc04:	9009883a 	mov	r4,r18
   2cc08:	002dc840 	call	2dc84 <_free_r>
   2cc0c:	00800134 	movhi	r2,4
   2cc10:	10a3bc04 	addi	r2,r2,-28944
   2cc14:	10c00017 	ldw	r3,0(r2)
   2cc18:	003f2c06 	br	2c8cc <__reset+0xfff8c8cc>
   2cc1c:	00c05504 	movi	r3,340
   2cc20:	18800536 	bltu	r3,r2,2cc38 <_malloc_r+0x7cc>
   2cc24:	3804d3fa 	srli	r2,r7,15
   2cc28:	11401e04 	addi	r5,r2,120
   2cc2c:	10c01dc4 	addi	r3,r2,119
   2cc30:	294b883a 	add	r5,r5,r5
   2cc34:	003f5606 	br	2c990 <__reset+0xfff8c990>
   2cc38:	00c15504 	movi	r3,1364
   2cc3c:	18800536 	bltu	r3,r2,2cc54 <_malloc_r+0x7e8>
   2cc40:	3804d4ba 	srli	r2,r7,18
   2cc44:	11401f44 	addi	r5,r2,125
   2cc48:	10c01f04 	addi	r3,r2,124
   2cc4c:	294b883a 	add	r5,r5,r5
   2cc50:	003f4f06 	br	2c990 <__reset+0xfff8c990>
   2cc54:	01403f84 	movi	r5,254
   2cc58:	00c01f84 	movi	r3,126
   2cc5c:	003f4c06 	br	2c990 <__reset+0xfff8c990>
   2cc60:	98800117 	ldw	r2,4(r19)
   2cc64:	003fa006 	br	2cae8 <__reset+0xfff8cae8>
   2cc68:	8808d0fa 	srli	r4,r17,3
   2cc6c:	20800044 	addi	r2,r4,1
   2cc70:	1085883a 	add	r2,r2,r2
   2cc74:	003e9006 	br	2c6b8 <__reset+0xfff8c6b8>

0002cc78 <memchr>:
   2cc78:	208000cc 	andi	r2,r4,3
   2cc7c:	280f883a 	mov	r7,r5
   2cc80:	10003426 	beq	r2,zero,2cd54 <memchr+0xdc>
   2cc84:	30bfffc4 	addi	r2,r6,-1
   2cc88:	30001a26 	beq	r6,zero,2ccf4 <memchr+0x7c>
   2cc8c:	20c00003 	ldbu	r3,0(r4)
   2cc90:	29803fcc 	andi	r6,r5,255
   2cc94:	30c0051e 	bne	r6,r3,2ccac <memchr+0x34>
   2cc98:	00001806 	br	2ccfc <memchr+0x84>
   2cc9c:	10001526 	beq	r2,zero,2ccf4 <memchr+0x7c>
   2cca0:	20c00003 	ldbu	r3,0(r4)
   2cca4:	10bfffc4 	addi	r2,r2,-1
   2cca8:	30c01426 	beq	r6,r3,2ccfc <memchr+0x84>
   2ccac:	21000044 	addi	r4,r4,1
   2ccb0:	20c000cc 	andi	r3,r4,3
   2ccb4:	183ff91e 	bne	r3,zero,2cc9c <__reset+0xfff8cc9c>
   2ccb8:	020000c4 	movi	r8,3
   2ccbc:	40801136 	bltu	r8,r2,2cd04 <memchr+0x8c>
   2ccc0:	10000c26 	beq	r2,zero,2ccf4 <memchr+0x7c>
   2ccc4:	20c00003 	ldbu	r3,0(r4)
   2ccc8:	29403fcc 	andi	r5,r5,255
   2cccc:	28c00b26 	beq	r5,r3,2ccfc <memchr+0x84>
   2ccd0:	20c00044 	addi	r3,r4,1
   2ccd4:	39803fcc 	andi	r6,r7,255
   2ccd8:	2089883a 	add	r4,r4,r2
   2ccdc:	00000306 	br	2ccec <memchr+0x74>
   2cce0:	18c00044 	addi	r3,r3,1
   2cce4:	197fffc3 	ldbu	r5,-1(r3)
   2cce8:	31400526 	beq	r6,r5,2cd00 <memchr+0x88>
   2ccec:	1805883a 	mov	r2,r3
   2ccf0:	20fffb1e 	bne	r4,r3,2cce0 <__reset+0xfff8cce0>
   2ccf4:	0005883a 	mov	r2,zero
   2ccf8:	f800283a 	ret
   2ccfc:	2005883a 	mov	r2,r4
   2cd00:	f800283a 	ret
   2cd04:	28c03fcc 	andi	r3,r5,255
   2cd08:	1812923a 	slli	r9,r3,8
   2cd0c:	02ffbff4 	movhi	r11,65279
   2cd10:	02a02074 	movhi	r10,32897
   2cd14:	48d2b03a 	or	r9,r9,r3
   2cd18:	4806943a 	slli	r3,r9,16
   2cd1c:	5affbfc4 	addi	r11,r11,-257
   2cd20:	52a02004 	addi	r10,r10,-32640
   2cd24:	48d2b03a 	or	r9,r9,r3
   2cd28:	20c00017 	ldw	r3,0(r4)
   2cd2c:	48c6f03a 	xor	r3,r9,r3
   2cd30:	1acd883a 	add	r6,r3,r11
   2cd34:	00c6303a 	nor	r3,zero,r3
   2cd38:	30c6703a 	and	r3,r6,r3
   2cd3c:	1a86703a 	and	r3,r3,r10
   2cd40:	183fe01e 	bne	r3,zero,2ccc4 <__reset+0xfff8ccc4>
   2cd44:	10bfff04 	addi	r2,r2,-4
   2cd48:	21000104 	addi	r4,r4,4
   2cd4c:	40bff636 	bltu	r8,r2,2cd28 <__reset+0xfff8cd28>
   2cd50:	003fdb06 	br	2ccc0 <__reset+0xfff8ccc0>
   2cd54:	3005883a 	mov	r2,r6
   2cd58:	003fd706 	br	2ccb8 <__reset+0xfff8ccb8>

0002cd5c <memmove>:
   2cd5c:	2005883a 	mov	r2,r4
   2cd60:	29000b2e 	bgeu	r5,r4,2cd90 <memmove+0x34>
   2cd64:	298f883a 	add	r7,r5,r6
   2cd68:	21c0092e 	bgeu	r4,r7,2cd90 <memmove+0x34>
   2cd6c:	2187883a 	add	r3,r4,r6
   2cd70:	198bc83a 	sub	r5,r3,r6
   2cd74:	30004826 	beq	r6,zero,2ce98 <memmove+0x13c>
   2cd78:	39ffffc4 	addi	r7,r7,-1
   2cd7c:	39000003 	ldbu	r4,0(r7)
   2cd80:	18ffffc4 	addi	r3,r3,-1
   2cd84:	19000005 	stb	r4,0(r3)
   2cd88:	28fffb1e 	bne	r5,r3,2cd78 <__reset+0xfff8cd78>
   2cd8c:	f800283a 	ret
   2cd90:	00c003c4 	movi	r3,15
   2cd94:	1980412e 	bgeu	r3,r6,2ce9c <memmove+0x140>
   2cd98:	2886b03a 	or	r3,r5,r2
   2cd9c:	18c000cc 	andi	r3,r3,3
   2cda0:	1800401e 	bne	r3,zero,2cea4 <memmove+0x148>
   2cda4:	33fffc04 	addi	r15,r6,-16
   2cda8:	781ed13a 	srli	r15,r15,4
   2cdac:	28c00104 	addi	r3,r5,4
   2cdb0:	13400104 	addi	r13,r2,4
   2cdb4:	781c913a 	slli	r14,r15,4
   2cdb8:	2b000204 	addi	r12,r5,8
   2cdbc:	12c00204 	addi	r11,r2,8
   2cdc0:	73800504 	addi	r14,r14,20
   2cdc4:	2a800304 	addi	r10,r5,12
   2cdc8:	12400304 	addi	r9,r2,12
   2cdcc:	2b9d883a 	add	r14,r5,r14
   2cdd0:	2811883a 	mov	r8,r5
   2cdd4:	100f883a 	mov	r7,r2
   2cdd8:	41000017 	ldw	r4,0(r8)
   2cddc:	39c00404 	addi	r7,r7,16
   2cde0:	18c00404 	addi	r3,r3,16
   2cde4:	393ffc15 	stw	r4,-16(r7)
   2cde8:	193ffc17 	ldw	r4,-16(r3)
   2cdec:	6b400404 	addi	r13,r13,16
   2cdf0:	5ac00404 	addi	r11,r11,16
   2cdf4:	693ffc15 	stw	r4,-16(r13)
   2cdf8:	61000017 	ldw	r4,0(r12)
   2cdfc:	4a400404 	addi	r9,r9,16
   2ce00:	42000404 	addi	r8,r8,16
   2ce04:	593ffc15 	stw	r4,-16(r11)
   2ce08:	51000017 	ldw	r4,0(r10)
   2ce0c:	63000404 	addi	r12,r12,16
   2ce10:	52800404 	addi	r10,r10,16
   2ce14:	493ffc15 	stw	r4,-16(r9)
   2ce18:	1bbfef1e 	bne	r3,r14,2cdd8 <__reset+0xfff8cdd8>
   2ce1c:	79000044 	addi	r4,r15,1
   2ce20:	2008913a 	slli	r4,r4,4
   2ce24:	328003cc 	andi	r10,r6,15
   2ce28:	02c000c4 	movi	r11,3
   2ce2c:	1107883a 	add	r3,r2,r4
   2ce30:	290b883a 	add	r5,r5,r4
   2ce34:	5a801e2e 	bgeu	r11,r10,2ceb0 <memmove+0x154>
   2ce38:	1813883a 	mov	r9,r3
   2ce3c:	2811883a 	mov	r8,r5
   2ce40:	500f883a 	mov	r7,r10
   2ce44:	41000017 	ldw	r4,0(r8)
   2ce48:	4a400104 	addi	r9,r9,4
   2ce4c:	39ffff04 	addi	r7,r7,-4
   2ce50:	493fff15 	stw	r4,-4(r9)
   2ce54:	42000104 	addi	r8,r8,4
   2ce58:	59fffa36 	bltu	r11,r7,2ce44 <__reset+0xfff8ce44>
   2ce5c:	513fff04 	addi	r4,r10,-4
   2ce60:	2008d0ba 	srli	r4,r4,2
   2ce64:	318000cc 	andi	r6,r6,3
   2ce68:	21000044 	addi	r4,r4,1
   2ce6c:	2109883a 	add	r4,r4,r4
   2ce70:	2109883a 	add	r4,r4,r4
   2ce74:	1907883a 	add	r3,r3,r4
   2ce78:	290b883a 	add	r5,r5,r4
   2ce7c:	30000b26 	beq	r6,zero,2ceac <memmove+0x150>
   2ce80:	198d883a 	add	r6,r3,r6
   2ce84:	29c00003 	ldbu	r7,0(r5)
   2ce88:	18c00044 	addi	r3,r3,1
   2ce8c:	29400044 	addi	r5,r5,1
   2ce90:	19ffffc5 	stb	r7,-1(r3)
   2ce94:	19bffb1e 	bne	r3,r6,2ce84 <__reset+0xfff8ce84>
   2ce98:	f800283a 	ret
   2ce9c:	1007883a 	mov	r3,r2
   2cea0:	003ff606 	br	2ce7c <__reset+0xfff8ce7c>
   2cea4:	1007883a 	mov	r3,r2
   2cea8:	003ff506 	br	2ce80 <__reset+0xfff8ce80>
   2ceac:	f800283a 	ret
   2ceb0:	500d883a 	mov	r6,r10
   2ceb4:	003ff106 	br	2ce7c <__reset+0xfff8ce7c>

0002ceb8 <_realloc_r>:
   2ceb8:	defff604 	addi	sp,sp,-40
   2cebc:	dc800215 	stw	r18,8(sp)
   2cec0:	dfc00915 	stw	ra,36(sp)
   2cec4:	df000815 	stw	fp,32(sp)
   2cec8:	ddc00715 	stw	r23,28(sp)
   2cecc:	dd800615 	stw	r22,24(sp)
   2ced0:	dd400515 	stw	r21,20(sp)
   2ced4:	dd000415 	stw	r20,16(sp)
   2ced8:	dcc00315 	stw	r19,12(sp)
   2cedc:	dc400115 	stw	r17,4(sp)
   2cee0:	dc000015 	stw	r16,0(sp)
   2cee4:	3025883a 	mov	r18,r6
   2cee8:	2800b726 	beq	r5,zero,2d1c8 <_realloc_r+0x310>
   2ceec:	282b883a 	mov	r21,r5
   2cef0:	2029883a 	mov	r20,r4
   2cef4:	002e7500 	call	2e750 <__malloc_lock>
   2cef8:	a8bfff17 	ldw	r2,-4(r21)
   2cefc:	043fff04 	movi	r16,-4
   2cf00:	90c002c4 	addi	r3,r18,11
   2cf04:	01000584 	movi	r4,22
   2cf08:	acfffe04 	addi	r19,r21,-8
   2cf0c:	1420703a 	and	r16,r2,r16
   2cf10:	20c0332e 	bgeu	r4,r3,2cfe0 <_realloc_r+0x128>
   2cf14:	047ffe04 	movi	r17,-8
   2cf18:	1c62703a 	and	r17,r3,r17
   2cf1c:	8807883a 	mov	r3,r17
   2cf20:	88005816 	blt	r17,zero,2d084 <_realloc_r+0x1cc>
   2cf24:	8c805736 	bltu	r17,r18,2d084 <_realloc_r+0x1cc>
   2cf28:	80c0300e 	bge	r16,r3,2cfec <_realloc_r+0x134>
   2cf2c:	070000f4 	movhi	fp,3
   2cf30:	e70d2e04 	addi	fp,fp,13496
   2cf34:	e1c00217 	ldw	r7,8(fp)
   2cf38:	9c09883a 	add	r4,r19,r16
   2cf3c:	22000117 	ldw	r8,4(r4)
   2cf40:	21c06326 	beq	r4,r7,2d0d0 <_realloc_r+0x218>
   2cf44:	017fff84 	movi	r5,-2
   2cf48:	414a703a 	and	r5,r8,r5
   2cf4c:	214b883a 	add	r5,r4,r5
   2cf50:	29800117 	ldw	r6,4(r5)
   2cf54:	3180004c 	andi	r6,r6,1
   2cf58:	30003f26 	beq	r6,zero,2d058 <_realloc_r+0x1a0>
   2cf5c:	1080004c 	andi	r2,r2,1
   2cf60:	10008326 	beq	r2,zero,2d170 <_realloc_r+0x2b8>
   2cf64:	900b883a 	mov	r5,r18
   2cf68:	a009883a 	mov	r4,r20
   2cf6c:	002c46c0 	call	2c46c <_malloc_r>
   2cf70:	1025883a 	mov	r18,r2
   2cf74:	10011e26 	beq	r2,zero,2d3f0 <_realloc_r+0x538>
   2cf78:	a93fff17 	ldw	r4,-4(r21)
   2cf7c:	10fffe04 	addi	r3,r2,-8
   2cf80:	00bfff84 	movi	r2,-2
   2cf84:	2084703a 	and	r2,r4,r2
   2cf88:	9885883a 	add	r2,r19,r2
   2cf8c:	1880ee26 	beq	r3,r2,2d348 <_realloc_r+0x490>
   2cf90:	81bfff04 	addi	r6,r16,-4
   2cf94:	00800904 	movi	r2,36
   2cf98:	1180b836 	bltu	r2,r6,2d27c <_realloc_r+0x3c4>
   2cf9c:	00c004c4 	movi	r3,19
   2cfa0:	19809636 	bltu	r3,r6,2d1fc <_realloc_r+0x344>
   2cfa4:	9005883a 	mov	r2,r18
   2cfa8:	a807883a 	mov	r3,r21
   2cfac:	19000017 	ldw	r4,0(r3)
   2cfb0:	11000015 	stw	r4,0(r2)
   2cfb4:	19000117 	ldw	r4,4(r3)
   2cfb8:	11000115 	stw	r4,4(r2)
   2cfbc:	18c00217 	ldw	r3,8(r3)
   2cfc0:	10c00215 	stw	r3,8(r2)
   2cfc4:	a80b883a 	mov	r5,r21
   2cfc8:	a009883a 	mov	r4,r20
   2cfcc:	002dc840 	call	2dc84 <_free_r>
   2cfd0:	a009883a 	mov	r4,r20
   2cfd4:	002e7740 	call	2e774 <__malloc_unlock>
   2cfd8:	9005883a 	mov	r2,r18
   2cfdc:	00001206 	br	2d028 <_realloc_r+0x170>
   2cfe0:	00c00404 	movi	r3,16
   2cfe4:	1823883a 	mov	r17,r3
   2cfe8:	003fce06 	br	2cf24 <__reset+0xfff8cf24>
   2cfec:	a825883a 	mov	r18,r21
   2cff0:	8445c83a 	sub	r2,r16,r17
   2cff4:	00c003c4 	movi	r3,15
   2cff8:	18802636 	bltu	r3,r2,2d094 <_realloc_r+0x1dc>
   2cffc:	99800117 	ldw	r6,4(r19)
   2d000:	9c07883a 	add	r3,r19,r16
   2d004:	3180004c 	andi	r6,r6,1
   2d008:	3420b03a 	or	r16,r6,r16
   2d00c:	9c000115 	stw	r16,4(r19)
   2d010:	18800117 	ldw	r2,4(r3)
   2d014:	10800054 	ori	r2,r2,1
   2d018:	18800115 	stw	r2,4(r3)
   2d01c:	a009883a 	mov	r4,r20
   2d020:	002e7740 	call	2e774 <__malloc_unlock>
   2d024:	9005883a 	mov	r2,r18
   2d028:	dfc00917 	ldw	ra,36(sp)
   2d02c:	df000817 	ldw	fp,32(sp)
   2d030:	ddc00717 	ldw	r23,28(sp)
   2d034:	dd800617 	ldw	r22,24(sp)
   2d038:	dd400517 	ldw	r21,20(sp)
   2d03c:	dd000417 	ldw	r20,16(sp)
   2d040:	dcc00317 	ldw	r19,12(sp)
   2d044:	dc800217 	ldw	r18,8(sp)
   2d048:	dc400117 	ldw	r17,4(sp)
   2d04c:	dc000017 	ldw	r16,0(sp)
   2d050:	dec00a04 	addi	sp,sp,40
   2d054:	f800283a 	ret
   2d058:	017fff04 	movi	r5,-4
   2d05c:	414a703a 	and	r5,r8,r5
   2d060:	814d883a 	add	r6,r16,r5
   2d064:	30c01f16 	blt	r6,r3,2d0e4 <_realloc_r+0x22c>
   2d068:	20800317 	ldw	r2,12(r4)
   2d06c:	20c00217 	ldw	r3,8(r4)
   2d070:	a825883a 	mov	r18,r21
   2d074:	3021883a 	mov	r16,r6
   2d078:	18800315 	stw	r2,12(r3)
   2d07c:	10c00215 	stw	r3,8(r2)
   2d080:	003fdb06 	br	2cff0 <__reset+0xfff8cff0>
   2d084:	00800304 	movi	r2,12
   2d088:	a0800015 	stw	r2,0(r20)
   2d08c:	0005883a 	mov	r2,zero
   2d090:	003fe506 	br	2d028 <__reset+0xfff8d028>
   2d094:	98c00117 	ldw	r3,4(r19)
   2d098:	9c4b883a 	add	r5,r19,r17
   2d09c:	11000054 	ori	r4,r2,1
   2d0a0:	18c0004c 	andi	r3,r3,1
   2d0a4:	1c62b03a 	or	r17,r3,r17
   2d0a8:	9c400115 	stw	r17,4(r19)
   2d0ac:	29000115 	stw	r4,4(r5)
   2d0b0:	2885883a 	add	r2,r5,r2
   2d0b4:	10c00117 	ldw	r3,4(r2)
   2d0b8:	29400204 	addi	r5,r5,8
   2d0bc:	a009883a 	mov	r4,r20
   2d0c0:	18c00054 	ori	r3,r3,1
   2d0c4:	10c00115 	stw	r3,4(r2)
   2d0c8:	002dc840 	call	2dc84 <_free_r>
   2d0cc:	003fd306 	br	2d01c <__reset+0xfff8d01c>
   2d0d0:	017fff04 	movi	r5,-4
   2d0d4:	414a703a 	and	r5,r8,r5
   2d0d8:	89800404 	addi	r6,r17,16
   2d0dc:	8151883a 	add	r8,r16,r5
   2d0e0:	4180590e 	bge	r8,r6,2d248 <_realloc_r+0x390>
   2d0e4:	1080004c 	andi	r2,r2,1
   2d0e8:	103f9e1e 	bne	r2,zero,2cf64 <__reset+0xfff8cf64>
   2d0ec:	adbffe17 	ldw	r22,-8(r21)
   2d0f0:	00bfff04 	movi	r2,-4
   2d0f4:	9dadc83a 	sub	r22,r19,r22
   2d0f8:	b1800117 	ldw	r6,4(r22)
   2d0fc:	3084703a 	and	r2,r6,r2
   2d100:	20002026 	beq	r4,zero,2d184 <_realloc_r+0x2cc>
   2d104:	80af883a 	add	r23,r16,r2
   2d108:	b96f883a 	add	r23,r23,r5
   2d10c:	21c05f26 	beq	r4,r7,2d28c <_realloc_r+0x3d4>
   2d110:	b8c01c16 	blt	r23,r3,2d184 <_realloc_r+0x2cc>
   2d114:	20800317 	ldw	r2,12(r4)
   2d118:	20c00217 	ldw	r3,8(r4)
   2d11c:	81bfff04 	addi	r6,r16,-4
   2d120:	01000904 	movi	r4,36
   2d124:	18800315 	stw	r2,12(r3)
   2d128:	10c00215 	stw	r3,8(r2)
   2d12c:	b0c00217 	ldw	r3,8(r22)
   2d130:	b0800317 	ldw	r2,12(r22)
   2d134:	b4800204 	addi	r18,r22,8
   2d138:	18800315 	stw	r2,12(r3)
   2d13c:	10c00215 	stw	r3,8(r2)
   2d140:	21801b36 	bltu	r4,r6,2d1b0 <_realloc_r+0x2f8>
   2d144:	008004c4 	movi	r2,19
   2d148:	1180352e 	bgeu	r2,r6,2d220 <_realloc_r+0x368>
   2d14c:	a8800017 	ldw	r2,0(r21)
   2d150:	b0800215 	stw	r2,8(r22)
   2d154:	a8800117 	ldw	r2,4(r21)
   2d158:	b0800315 	stw	r2,12(r22)
   2d15c:	008006c4 	movi	r2,27
   2d160:	11807f36 	bltu	r2,r6,2d360 <_realloc_r+0x4a8>
   2d164:	b0800404 	addi	r2,r22,16
   2d168:	ad400204 	addi	r21,r21,8
   2d16c:	00002d06 	br	2d224 <_realloc_r+0x36c>
   2d170:	adbffe17 	ldw	r22,-8(r21)
   2d174:	00bfff04 	movi	r2,-4
   2d178:	9dadc83a 	sub	r22,r19,r22
   2d17c:	b1000117 	ldw	r4,4(r22)
   2d180:	2084703a 	and	r2,r4,r2
   2d184:	b03f7726 	beq	r22,zero,2cf64 <__reset+0xfff8cf64>
   2d188:	80af883a 	add	r23,r16,r2
   2d18c:	b8ff7516 	blt	r23,r3,2cf64 <__reset+0xfff8cf64>
   2d190:	b0800317 	ldw	r2,12(r22)
   2d194:	b0c00217 	ldw	r3,8(r22)
   2d198:	81bfff04 	addi	r6,r16,-4
   2d19c:	01000904 	movi	r4,36
   2d1a0:	18800315 	stw	r2,12(r3)
   2d1a4:	10c00215 	stw	r3,8(r2)
   2d1a8:	b4800204 	addi	r18,r22,8
   2d1ac:	21bfe52e 	bgeu	r4,r6,2d144 <__reset+0xfff8d144>
   2d1b0:	a80b883a 	mov	r5,r21
   2d1b4:	9009883a 	mov	r4,r18
   2d1b8:	002cd5c0 	call	2cd5c <memmove>
   2d1bc:	b821883a 	mov	r16,r23
   2d1c0:	b027883a 	mov	r19,r22
   2d1c4:	003f8a06 	br	2cff0 <__reset+0xfff8cff0>
   2d1c8:	300b883a 	mov	r5,r6
   2d1cc:	dfc00917 	ldw	ra,36(sp)
   2d1d0:	df000817 	ldw	fp,32(sp)
   2d1d4:	ddc00717 	ldw	r23,28(sp)
   2d1d8:	dd800617 	ldw	r22,24(sp)
   2d1dc:	dd400517 	ldw	r21,20(sp)
   2d1e0:	dd000417 	ldw	r20,16(sp)
   2d1e4:	dcc00317 	ldw	r19,12(sp)
   2d1e8:	dc800217 	ldw	r18,8(sp)
   2d1ec:	dc400117 	ldw	r17,4(sp)
   2d1f0:	dc000017 	ldw	r16,0(sp)
   2d1f4:	dec00a04 	addi	sp,sp,40
   2d1f8:	002c46c1 	jmpi	2c46c <_malloc_r>
   2d1fc:	a8c00017 	ldw	r3,0(r21)
   2d200:	90c00015 	stw	r3,0(r18)
   2d204:	a8c00117 	ldw	r3,4(r21)
   2d208:	90c00115 	stw	r3,4(r18)
   2d20c:	00c006c4 	movi	r3,27
   2d210:	19804536 	bltu	r3,r6,2d328 <_realloc_r+0x470>
   2d214:	90800204 	addi	r2,r18,8
   2d218:	a8c00204 	addi	r3,r21,8
   2d21c:	003f6306 	br	2cfac <__reset+0xfff8cfac>
   2d220:	9005883a 	mov	r2,r18
   2d224:	a8c00017 	ldw	r3,0(r21)
   2d228:	b821883a 	mov	r16,r23
   2d22c:	b027883a 	mov	r19,r22
   2d230:	10c00015 	stw	r3,0(r2)
   2d234:	a8c00117 	ldw	r3,4(r21)
   2d238:	10c00115 	stw	r3,4(r2)
   2d23c:	a8c00217 	ldw	r3,8(r21)
   2d240:	10c00215 	stw	r3,8(r2)
   2d244:	003f6a06 	br	2cff0 <__reset+0xfff8cff0>
   2d248:	9c67883a 	add	r19,r19,r17
   2d24c:	4445c83a 	sub	r2,r8,r17
   2d250:	e4c00215 	stw	r19,8(fp)
   2d254:	10800054 	ori	r2,r2,1
   2d258:	98800115 	stw	r2,4(r19)
   2d25c:	a8bfff17 	ldw	r2,-4(r21)
   2d260:	a009883a 	mov	r4,r20
   2d264:	1080004c 	andi	r2,r2,1
   2d268:	1462b03a 	or	r17,r2,r17
   2d26c:	ac7fff15 	stw	r17,-4(r21)
   2d270:	002e7740 	call	2e774 <__malloc_unlock>
   2d274:	a805883a 	mov	r2,r21
   2d278:	003f6b06 	br	2d028 <__reset+0xfff8d028>
   2d27c:	a80b883a 	mov	r5,r21
   2d280:	9009883a 	mov	r4,r18
   2d284:	002cd5c0 	call	2cd5c <memmove>
   2d288:	003f4e06 	br	2cfc4 <__reset+0xfff8cfc4>
   2d28c:	89000404 	addi	r4,r17,16
   2d290:	b93fbc16 	blt	r23,r4,2d184 <__reset+0xfff8d184>
   2d294:	b0800317 	ldw	r2,12(r22)
   2d298:	b0c00217 	ldw	r3,8(r22)
   2d29c:	81bfff04 	addi	r6,r16,-4
   2d2a0:	01000904 	movi	r4,36
   2d2a4:	18800315 	stw	r2,12(r3)
   2d2a8:	10c00215 	stw	r3,8(r2)
   2d2ac:	b4800204 	addi	r18,r22,8
   2d2b0:	21804336 	bltu	r4,r6,2d3c0 <_realloc_r+0x508>
   2d2b4:	008004c4 	movi	r2,19
   2d2b8:	11803f2e 	bgeu	r2,r6,2d3b8 <_realloc_r+0x500>
   2d2bc:	a8800017 	ldw	r2,0(r21)
   2d2c0:	b0800215 	stw	r2,8(r22)
   2d2c4:	a8800117 	ldw	r2,4(r21)
   2d2c8:	b0800315 	stw	r2,12(r22)
   2d2cc:	008006c4 	movi	r2,27
   2d2d0:	11803f36 	bltu	r2,r6,2d3d0 <_realloc_r+0x518>
   2d2d4:	b0800404 	addi	r2,r22,16
   2d2d8:	ad400204 	addi	r21,r21,8
   2d2dc:	a8c00017 	ldw	r3,0(r21)
   2d2e0:	10c00015 	stw	r3,0(r2)
   2d2e4:	a8c00117 	ldw	r3,4(r21)
   2d2e8:	10c00115 	stw	r3,4(r2)
   2d2ec:	a8c00217 	ldw	r3,8(r21)
   2d2f0:	10c00215 	stw	r3,8(r2)
   2d2f4:	b447883a 	add	r3,r22,r17
   2d2f8:	bc45c83a 	sub	r2,r23,r17
   2d2fc:	e0c00215 	stw	r3,8(fp)
   2d300:	10800054 	ori	r2,r2,1
   2d304:	18800115 	stw	r2,4(r3)
   2d308:	b0800117 	ldw	r2,4(r22)
   2d30c:	a009883a 	mov	r4,r20
   2d310:	1080004c 	andi	r2,r2,1
   2d314:	1462b03a 	or	r17,r2,r17
   2d318:	b4400115 	stw	r17,4(r22)
   2d31c:	002e7740 	call	2e774 <__malloc_unlock>
   2d320:	9005883a 	mov	r2,r18
   2d324:	003f4006 	br	2d028 <__reset+0xfff8d028>
   2d328:	a8c00217 	ldw	r3,8(r21)
   2d32c:	90c00215 	stw	r3,8(r18)
   2d330:	a8c00317 	ldw	r3,12(r21)
   2d334:	90c00315 	stw	r3,12(r18)
   2d338:	30801126 	beq	r6,r2,2d380 <_realloc_r+0x4c8>
   2d33c:	90800404 	addi	r2,r18,16
   2d340:	a8c00404 	addi	r3,r21,16
   2d344:	003f1906 	br	2cfac <__reset+0xfff8cfac>
   2d348:	90ffff17 	ldw	r3,-4(r18)
   2d34c:	00bfff04 	movi	r2,-4
   2d350:	a825883a 	mov	r18,r21
   2d354:	1884703a 	and	r2,r3,r2
   2d358:	80a1883a 	add	r16,r16,r2
   2d35c:	003f2406 	br	2cff0 <__reset+0xfff8cff0>
   2d360:	a8800217 	ldw	r2,8(r21)
   2d364:	b0800415 	stw	r2,16(r22)
   2d368:	a8800317 	ldw	r2,12(r21)
   2d36c:	b0800515 	stw	r2,20(r22)
   2d370:	31000a26 	beq	r6,r4,2d39c <_realloc_r+0x4e4>
   2d374:	b0800604 	addi	r2,r22,24
   2d378:	ad400404 	addi	r21,r21,16
   2d37c:	003fa906 	br	2d224 <__reset+0xfff8d224>
   2d380:	a9000417 	ldw	r4,16(r21)
   2d384:	90800604 	addi	r2,r18,24
   2d388:	a8c00604 	addi	r3,r21,24
   2d38c:	91000415 	stw	r4,16(r18)
   2d390:	a9000517 	ldw	r4,20(r21)
   2d394:	91000515 	stw	r4,20(r18)
   2d398:	003f0406 	br	2cfac <__reset+0xfff8cfac>
   2d39c:	a8c00417 	ldw	r3,16(r21)
   2d3a0:	ad400604 	addi	r21,r21,24
   2d3a4:	b0800804 	addi	r2,r22,32
   2d3a8:	b0c00615 	stw	r3,24(r22)
   2d3ac:	a8ffff17 	ldw	r3,-4(r21)
   2d3b0:	b0c00715 	stw	r3,28(r22)
   2d3b4:	003f9b06 	br	2d224 <__reset+0xfff8d224>
   2d3b8:	9005883a 	mov	r2,r18
   2d3bc:	003fc706 	br	2d2dc <__reset+0xfff8d2dc>
   2d3c0:	a80b883a 	mov	r5,r21
   2d3c4:	9009883a 	mov	r4,r18
   2d3c8:	002cd5c0 	call	2cd5c <memmove>
   2d3cc:	003fc906 	br	2d2f4 <__reset+0xfff8d2f4>
   2d3d0:	a8800217 	ldw	r2,8(r21)
   2d3d4:	b0800415 	stw	r2,16(r22)
   2d3d8:	a8800317 	ldw	r2,12(r21)
   2d3dc:	b0800515 	stw	r2,20(r22)
   2d3e0:	31000726 	beq	r6,r4,2d400 <_realloc_r+0x548>
   2d3e4:	b0800604 	addi	r2,r22,24
   2d3e8:	ad400404 	addi	r21,r21,16
   2d3ec:	003fbb06 	br	2d2dc <__reset+0xfff8d2dc>
   2d3f0:	a009883a 	mov	r4,r20
   2d3f4:	002e7740 	call	2e774 <__malloc_unlock>
   2d3f8:	0005883a 	mov	r2,zero
   2d3fc:	003f0a06 	br	2d028 <__reset+0xfff8d028>
   2d400:	a8c00417 	ldw	r3,16(r21)
   2d404:	ad400604 	addi	r21,r21,24
   2d408:	b0800804 	addi	r2,r22,32
   2d40c:	b0c00615 	stw	r3,24(r22)
   2d410:	a8ffff17 	ldw	r3,-4(r21)
   2d414:	b0c00715 	stw	r3,28(r22)
   2d418:	003fb006 	br	2d2dc <__reset+0xfff8d2dc>

0002d41c <_sbrk_r>:
   2d41c:	defffd04 	addi	sp,sp,-12
   2d420:	dc000015 	stw	r16,0(sp)
   2d424:	040000f4 	movhi	r16,3
   2d428:	dc400115 	stw	r17,4(sp)
   2d42c:	84134704 	addi	r16,r16,19740
   2d430:	2023883a 	mov	r17,r4
   2d434:	2809883a 	mov	r4,r5
   2d438:	dfc00215 	stw	ra,8(sp)
   2d43c:	80000015 	stw	zero,0(r16)
   2d440:	002e9340 	call	2e934 <sbrk>
   2d444:	00ffffc4 	movi	r3,-1
   2d448:	10c00526 	beq	r2,r3,2d460 <_sbrk_r+0x44>
   2d44c:	dfc00217 	ldw	ra,8(sp)
   2d450:	dc400117 	ldw	r17,4(sp)
   2d454:	dc000017 	ldw	r16,0(sp)
   2d458:	dec00304 	addi	sp,sp,12
   2d45c:	f800283a 	ret
   2d460:	80c00017 	ldw	r3,0(r16)
   2d464:	183ff926 	beq	r3,zero,2d44c <__reset+0xfff8d44c>
   2d468:	88c00015 	stw	r3,0(r17)
   2d46c:	003ff706 	br	2d44c <__reset+0xfff8d44c>

0002d470 <__sread>:
   2d470:	defffe04 	addi	sp,sp,-8
   2d474:	dc000015 	stw	r16,0(sp)
   2d478:	2821883a 	mov	r16,r5
   2d47c:	2940038f 	ldh	r5,14(r5)
   2d480:	dfc00115 	stw	ra,4(sp)
   2d484:	002e1b00 	call	2e1b0 <_read_r>
   2d488:	10000716 	blt	r2,zero,2d4a8 <__sread+0x38>
   2d48c:	80c01417 	ldw	r3,80(r16)
   2d490:	1887883a 	add	r3,r3,r2
   2d494:	80c01415 	stw	r3,80(r16)
   2d498:	dfc00117 	ldw	ra,4(sp)
   2d49c:	dc000017 	ldw	r16,0(sp)
   2d4a0:	dec00204 	addi	sp,sp,8
   2d4a4:	f800283a 	ret
   2d4a8:	80c0030b 	ldhu	r3,12(r16)
   2d4ac:	18fbffcc 	andi	r3,r3,61439
   2d4b0:	80c0030d 	sth	r3,12(r16)
   2d4b4:	dfc00117 	ldw	ra,4(sp)
   2d4b8:	dc000017 	ldw	r16,0(sp)
   2d4bc:	dec00204 	addi	sp,sp,8
   2d4c0:	f800283a 	ret

0002d4c4 <__seofread>:
   2d4c4:	0005883a 	mov	r2,zero
   2d4c8:	f800283a 	ret

0002d4cc <__swrite>:
   2d4cc:	2880030b 	ldhu	r2,12(r5)
   2d4d0:	defffb04 	addi	sp,sp,-20
   2d4d4:	dcc00315 	stw	r19,12(sp)
   2d4d8:	dc800215 	stw	r18,8(sp)
   2d4dc:	dc400115 	stw	r17,4(sp)
   2d4e0:	dc000015 	stw	r16,0(sp)
   2d4e4:	dfc00415 	stw	ra,16(sp)
   2d4e8:	10c0400c 	andi	r3,r2,256
   2d4ec:	2821883a 	mov	r16,r5
   2d4f0:	2023883a 	mov	r17,r4
   2d4f4:	3025883a 	mov	r18,r6
   2d4f8:	3827883a 	mov	r19,r7
   2d4fc:	18000526 	beq	r3,zero,2d514 <__swrite+0x48>
   2d500:	2940038f 	ldh	r5,14(r5)
   2d504:	01c00084 	movi	r7,2
   2d508:	000d883a 	mov	r6,zero
   2d50c:	002df940 	call	2df94 <_lseek_r>
   2d510:	8080030b 	ldhu	r2,12(r16)
   2d514:	8140038f 	ldh	r5,14(r16)
   2d518:	10bbffcc 	andi	r2,r2,61439
   2d51c:	980f883a 	mov	r7,r19
   2d520:	900d883a 	mov	r6,r18
   2d524:	8809883a 	mov	r4,r17
   2d528:	8080030d 	sth	r2,12(r16)
   2d52c:	dfc00417 	ldw	ra,16(sp)
   2d530:	dcc00317 	ldw	r19,12(sp)
   2d534:	dc800217 	ldw	r18,8(sp)
   2d538:	dc400117 	ldw	r17,4(sp)
   2d53c:	dc000017 	ldw	r16,0(sp)
   2d540:	dec00504 	addi	sp,sp,20
   2d544:	002d5ac1 	jmpi	2d5ac <_write_r>

0002d548 <__sseek>:
   2d548:	defffe04 	addi	sp,sp,-8
   2d54c:	dc000015 	stw	r16,0(sp)
   2d550:	2821883a 	mov	r16,r5
   2d554:	2940038f 	ldh	r5,14(r5)
   2d558:	dfc00115 	stw	ra,4(sp)
   2d55c:	002df940 	call	2df94 <_lseek_r>
   2d560:	00ffffc4 	movi	r3,-1
   2d564:	10c00826 	beq	r2,r3,2d588 <__sseek+0x40>
   2d568:	80c0030b 	ldhu	r3,12(r16)
   2d56c:	80801415 	stw	r2,80(r16)
   2d570:	18c40014 	ori	r3,r3,4096
   2d574:	80c0030d 	sth	r3,12(r16)
   2d578:	dfc00117 	ldw	ra,4(sp)
   2d57c:	dc000017 	ldw	r16,0(sp)
   2d580:	dec00204 	addi	sp,sp,8
   2d584:	f800283a 	ret
   2d588:	80c0030b 	ldhu	r3,12(r16)
   2d58c:	18fbffcc 	andi	r3,r3,61439
   2d590:	80c0030d 	sth	r3,12(r16)
   2d594:	dfc00117 	ldw	ra,4(sp)
   2d598:	dc000017 	ldw	r16,0(sp)
   2d59c:	dec00204 	addi	sp,sp,8
   2d5a0:	f800283a 	ret

0002d5a4 <__sclose>:
   2d5a4:	2940038f 	ldh	r5,14(r5)
   2d5a8:	002d7601 	jmpi	2d760 <_close_r>

0002d5ac <_write_r>:
   2d5ac:	defffd04 	addi	sp,sp,-12
   2d5b0:	2805883a 	mov	r2,r5
   2d5b4:	dc000015 	stw	r16,0(sp)
   2d5b8:	040000f4 	movhi	r16,3
   2d5bc:	dc400115 	stw	r17,4(sp)
   2d5c0:	300b883a 	mov	r5,r6
   2d5c4:	84134704 	addi	r16,r16,19740
   2d5c8:	2023883a 	mov	r17,r4
   2d5cc:	380d883a 	mov	r6,r7
   2d5d0:	1009883a 	mov	r4,r2
   2d5d4:	dfc00215 	stw	ra,8(sp)
   2d5d8:	80000015 	stw	zero,0(r16)
   2d5dc:	002ea200 	call	2ea20 <write>
   2d5e0:	00ffffc4 	movi	r3,-1
   2d5e4:	10c00526 	beq	r2,r3,2d5fc <_write_r+0x50>
   2d5e8:	dfc00217 	ldw	ra,8(sp)
   2d5ec:	dc400117 	ldw	r17,4(sp)
   2d5f0:	dc000017 	ldw	r16,0(sp)
   2d5f4:	dec00304 	addi	sp,sp,12
   2d5f8:	f800283a 	ret
   2d5fc:	80c00017 	ldw	r3,0(r16)
   2d600:	183ff926 	beq	r3,zero,2d5e8 <__reset+0xfff8d5e8>
   2d604:	88c00015 	stw	r3,0(r17)
   2d608:	003ff706 	br	2d5e8 <__reset+0xfff8d5e8>

0002d60c <__swsetup_r>:
   2d60c:	008000f4 	movhi	r2,3
   2d610:	defffd04 	addi	sp,sp,-12
   2d614:	10931804 	addi	r2,r2,19552
   2d618:	dc400115 	stw	r17,4(sp)
   2d61c:	2023883a 	mov	r17,r4
   2d620:	11000017 	ldw	r4,0(r2)
   2d624:	dc000015 	stw	r16,0(sp)
   2d628:	dfc00215 	stw	ra,8(sp)
   2d62c:	2821883a 	mov	r16,r5
   2d630:	20000226 	beq	r4,zero,2d63c <__swsetup_r+0x30>
   2d634:	20800e17 	ldw	r2,56(r4)
   2d638:	10003126 	beq	r2,zero,2d700 <__swsetup_r+0xf4>
   2d63c:	8080030b 	ldhu	r2,12(r16)
   2d640:	10c0020c 	andi	r3,r2,8
   2d644:	1009883a 	mov	r4,r2
   2d648:	18000f26 	beq	r3,zero,2d688 <__swsetup_r+0x7c>
   2d64c:	80c00417 	ldw	r3,16(r16)
   2d650:	18001526 	beq	r3,zero,2d6a8 <__swsetup_r+0x9c>
   2d654:	1100004c 	andi	r4,r2,1
   2d658:	20001c1e 	bne	r4,zero,2d6cc <__swsetup_r+0xc0>
   2d65c:	1080008c 	andi	r2,r2,2
   2d660:	1000291e 	bne	r2,zero,2d708 <__swsetup_r+0xfc>
   2d664:	80800517 	ldw	r2,20(r16)
   2d668:	80800215 	stw	r2,8(r16)
   2d66c:	18001c26 	beq	r3,zero,2d6e0 <__swsetup_r+0xd4>
   2d670:	0005883a 	mov	r2,zero
   2d674:	dfc00217 	ldw	ra,8(sp)
   2d678:	dc400117 	ldw	r17,4(sp)
   2d67c:	dc000017 	ldw	r16,0(sp)
   2d680:	dec00304 	addi	sp,sp,12
   2d684:	f800283a 	ret
   2d688:	2080040c 	andi	r2,r4,16
   2d68c:	10002e26 	beq	r2,zero,2d748 <__swsetup_r+0x13c>
   2d690:	2080010c 	andi	r2,r4,4
   2d694:	10001e1e 	bne	r2,zero,2d710 <__swsetup_r+0x104>
   2d698:	80c00417 	ldw	r3,16(r16)
   2d69c:	20800214 	ori	r2,r4,8
   2d6a0:	8080030d 	sth	r2,12(r16)
   2d6a4:	183feb1e 	bne	r3,zero,2d654 <__reset+0xfff8d654>
   2d6a8:	1100a00c 	andi	r4,r2,640
   2d6ac:	01408004 	movi	r5,512
   2d6b0:	217fe826 	beq	r4,r5,2d654 <__reset+0xfff8d654>
   2d6b4:	800b883a 	mov	r5,r16
   2d6b8:	8809883a 	mov	r4,r17
   2d6bc:	002dff40 	call	2dff4 <__smakebuf_r>
   2d6c0:	8080030b 	ldhu	r2,12(r16)
   2d6c4:	80c00417 	ldw	r3,16(r16)
   2d6c8:	003fe206 	br	2d654 <__reset+0xfff8d654>
   2d6cc:	80800517 	ldw	r2,20(r16)
   2d6d0:	80000215 	stw	zero,8(r16)
   2d6d4:	0085c83a 	sub	r2,zero,r2
   2d6d8:	80800615 	stw	r2,24(r16)
   2d6dc:	183fe41e 	bne	r3,zero,2d670 <__reset+0xfff8d670>
   2d6e0:	80c0030b 	ldhu	r3,12(r16)
   2d6e4:	0005883a 	mov	r2,zero
   2d6e8:	1900200c 	andi	r4,r3,128
   2d6ec:	203fe126 	beq	r4,zero,2d674 <__reset+0xfff8d674>
   2d6f0:	18c01014 	ori	r3,r3,64
   2d6f4:	80c0030d 	sth	r3,12(r16)
   2d6f8:	00bfffc4 	movi	r2,-1
   2d6fc:	003fdd06 	br	2d674 <__reset+0xfff8d674>
   2d700:	002bdd80 	call	2bdd8 <__sinit>
   2d704:	003fcd06 	br	2d63c <__reset+0xfff8d63c>
   2d708:	0005883a 	mov	r2,zero
   2d70c:	003fd606 	br	2d668 <__reset+0xfff8d668>
   2d710:	81400c17 	ldw	r5,48(r16)
   2d714:	28000626 	beq	r5,zero,2d730 <__swsetup_r+0x124>
   2d718:	80801004 	addi	r2,r16,64
   2d71c:	28800326 	beq	r5,r2,2d72c <__swsetup_r+0x120>
   2d720:	8809883a 	mov	r4,r17
   2d724:	002dc840 	call	2dc84 <_free_r>
   2d728:	8100030b 	ldhu	r4,12(r16)
   2d72c:	80000c15 	stw	zero,48(r16)
   2d730:	80c00417 	ldw	r3,16(r16)
   2d734:	00bff6c4 	movi	r2,-37
   2d738:	1108703a 	and	r4,r2,r4
   2d73c:	80000115 	stw	zero,4(r16)
   2d740:	80c00015 	stw	r3,0(r16)
   2d744:	003fd506 	br	2d69c <__reset+0xfff8d69c>
   2d748:	00800244 	movi	r2,9
   2d74c:	88800015 	stw	r2,0(r17)
   2d750:	20801014 	ori	r2,r4,64
   2d754:	8080030d 	sth	r2,12(r16)
   2d758:	00bfffc4 	movi	r2,-1
   2d75c:	003fc506 	br	2d674 <__reset+0xfff8d674>

0002d760 <_close_r>:
   2d760:	defffd04 	addi	sp,sp,-12
   2d764:	dc000015 	stw	r16,0(sp)
   2d768:	040000f4 	movhi	r16,3
   2d76c:	dc400115 	stw	r17,4(sp)
   2d770:	84134704 	addi	r16,r16,19740
   2d774:	2023883a 	mov	r17,r4
   2d778:	2809883a 	mov	r4,r5
   2d77c:	dfc00215 	stw	ra,8(sp)
   2d780:	80000015 	stw	zero,0(r16)
   2d784:	002e2fc0 	call	2e2fc <close>
   2d788:	00ffffc4 	movi	r3,-1
   2d78c:	10c00526 	beq	r2,r3,2d7a4 <_close_r+0x44>
   2d790:	dfc00217 	ldw	ra,8(sp)
   2d794:	dc400117 	ldw	r17,4(sp)
   2d798:	dc000017 	ldw	r16,0(sp)
   2d79c:	dec00304 	addi	sp,sp,12
   2d7a0:	f800283a 	ret
   2d7a4:	80c00017 	ldw	r3,0(r16)
   2d7a8:	183ff926 	beq	r3,zero,2d790 <__reset+0xfff8d790>
   2d7ac:	88c00015 	stw	r3,0(r17)
   2d7b0:	003ff706 	br	2d790 <__reset+0xfff8d790>

0002d7b4 <_fclose_r>:
   2d7b4:	28003926 	beq	r5,zero,2d89c <_fclose_r+0xe8>
   2d7b8:	defffc04 	addi	sp,sp,-16
   2d7bc:	dc400115 	stw	r17,4(sp)
   2d7c0:	dc000015 	stw	r16,0(sp)
   2d7c4:	dfc00315 	stw	ra,12(sp)
   2d7c8:	dc800215 	stw	r18,8(sp)
   2d7cc:	2023883a 	mov	r17,r4
   2d7d0:	2821883a 	mov	r16,r5
   2d7d4:	20000226 	beq	r4,zero,2d7e0 <_fclose_r+0x2c>
   2d7d8:	20800e17 	ldw	r2,56(r4)
   2d7dc:	10002726 	beq	r2,zero,2d87c <_fclose_r+0xc8>
   2d7e0:	8080030f 	ldh	r2,12(r16)
   2d7e4:	1000071e 	bne	r2,zero,2d804 <_fclose_r+0x50>
   2d7e8:	0005883a 	mov	r2,zero
   2d7ec:	dfc00317 	ldw	ra,12(sp)
   2d7f0:	dc800217 	ldw	r18,8(sp)
   2d7f4:	dc400117 	ldw	r17,4(sp)
   2d7f8:	dc000017 	ldw	r16,0(sp)
   2d7fc:	dec00404 	addi	sp,sp,16
   2d800:	f800283a 	ret
   2d804:	800b883a 	mov	r5,r16
   2d808:	8809883a 	mov	r4,r17
   2d80c:	002d8b80 	call	2d8b8 <__sflush_r>
   2d810:	1025883a 	mov	r18,r2
   2d814:	80800b17 	ldw	r2,44(r16)
   2d818:	10000426 	beq	r2,zero,2d82c <_fclose_r+0x78>
   2d81c:	81400717 	ldw	r5,28(r16)
   2d820:	8809883a 	mov	r4,r17
   2d824:	103ee83a 	callr	r2
   2d828:	10001616 	blt	r2,zero,2d884 <_fclose_r+0xd0>
   2d82c:	8080030b 	ldhu	r2,12(r16)
   2d830:	1080200c 	andi	r2,r2,128
   2d834:	1000151e 	bne	r2,zero,2d88c <_fclose_r+0xd8>
   2d838:	81400c17 	ldw	r5,48(r16)
   2d83c:	28000526 	beq	r5,zero,2d854 <_fclose_r+0xa0>
   2d840:	80801004 	addi	r2,r16,64
   2d844:	28800226 	beq	r5,r2,2d850 <_fclose_r+0x9c>
   2d848:	8809883a 	mov	r4,r17
   2d84c:	002dc840 	call	2dc84 <_free_r>
   2d850:	80000c15 	stw	zero,48(r16)
   2d854:	81401117 	ldw	r5,68(r16)
   2d858:	28000326 	beq	r5,zero,2d868 <_fclose_r+0xb4>
   2d85c:	8809883a 	mov	r4,r17
   2d860:	002dc840 	call	2dc84 <_free_r>
   2d864:	80001115 	stw	zero,68(r16)
   2d868:	002bde80 	call	2bde8 <__sfp_lock_acquire>
   2d86c:	8000030d 	sth	zero,12(r16)
   2d870:	002bdec0 	call	2bdec <__sfp_lock_release>
   2d874:	9005883a 	mov	r2,r18
   2d878:	003fdc06 	br	2d7ec <__reset+0xfff8d7ec>
   2d87c:	002bdd80 	call	2bdd8 <__sinit>
   2d880:	003fd706 	br	2d7e0 <__reset+0xfff8d7e0>
   2d884:	04bfffc4 	movi	r18,-1
   2d888:	003fe806 	br	2d82c <__reset+0xfff8d82c>
   2d88c:	81400417 	ldw	r5,16(r16)
   2d890:	8809883a 	mov	r4,r17
   2d894:	002dc840 	call	2dc84 <_free_r>
   2d898:	003fe706 	br	2d838 <__reset+0xfff8d838>
   2d89c:	0005883a 	mov	r2,zero
   2d8a0:	f800283a 	ret

0002d8a4 <fclose>:
   2d8a4:	008000f4 	movhi	r2,3
   2d8a8:	10931804 	addi	r2,r2,19552
   2d8ac:	200b883a 	mov	r5,r4
   2d8b0:	11000017 	ldw	r4,0(r2)
   2d8b4:	002d7b41 	jmpi	2d7b4 <_fclose_r>

0002d8b8 <__sflush_r>:
   2d8b8:	2880030b 	ldhu	r2,12(r5)
   2d8bc:	defffb04 	addi	sp,sp,-20
   2d8c0:	dcc00315 	stw	r19,12(sp)
   2d8c4:	dc400115 	stw	r17,4(sp)
   2d8c8:	dfc00415 	stw	ra,16(sp)
   2d8cc:	dc800215 	stw	r18,8(sp)
   2d8d0:	dc000015 	stw	r16,0(sp)
   2d8d4:	10c0020c 	andi	r3,r2,8
   2d8d8:	2823883a 	mov	r17,r5
   2d8dc:	2027883a 	mov	r19,r4
   2d8e0:	1800311e 	bne	r3,zero,2d9a8 <__sflush_r+0xf0>
   2d8e4:	28c00117 	ldw	r3,4(r5)
   2d8e8:	10820014 	ori	r2,r2,2048
   2d8ec:	2880030d 	sth	r2,12(r5)
   2d8f0:	00c04b0e 	bge	zero,r3,2da20 <__sflush_r+0x168>
   2d8f4:	8a000a17 	ldw	r8,40(r17)
   2d8f8:	40002326 	beq	r8,zero,2d988 <__sflush_r+0xd0>
   2d8fc:	9c000017 	ldw	r16,0(r19)
   2d900:	10c4000c 	andi	r3,r2,4096
   2d904:	98000015 	stw	zero,0(r19)
   2d908:	18004826 	beq	r3,zero,2da2c <__sflush_r+0x174>
   2d90c:	89801417 	ldw	r6,80(r17)
   2d910:	10c0010c 	andi	r3,r2,4
   2d914:	18000626 	beq	r3,zero,2d930 <__sflush_r+0x78>
   2d918:	88c00117 	ldw	r3,4(r17)
   2d91c:	88800c17 	ldw	r2,48(r17)
   2d920:	30cdc83a 	sub	r6,r6,r3
   2d924:	10000226 	beq	r2,zero,2d930 <__sflush_r+0x78>
   2d928:	88800f17 	ldw	r2,60(r17)
   2d92c:	308dc83a 	sub	r6,r6,r2
   2d930:	89400717 	ldw	r5,28(r17)
   2d934:	000f883a 	mov	r7,zero
   2d938:	9809883a 	mov	r4,r19
   2d93c:	403ee83a 	callr	r8
   2d940:	00ffffc4 	movi	r3,-1
   2d944:	10c04426 	beq	r2,r3,2da58 <__sflush_r+0x1a0>
   2d948:	88c0030b 	ldhu	r3,12(r17)
   2d94c:	89000417 	ldw	r4,16(r17)
   2d950:	88000115 	stw	zero,4(r17)
   2d954:	197dffcc 	andi	r5,r3,63487
   2d958:	8940030d 	sth	r5,12(r17)
   2d95c:	89000015 	stw	r4,0(r17)
   2d960:	18c4000c 	andi	r3,r3,4096
   2d964:	18002c1e 	bne	r3,zero,2da18 <__sflush_r+0x160>
   2d968:	89400c17 	ldw	r5,48(r17)
   2d96c:	9c000015 	stw	r16,0(r19)
   2d970:	28000526 	beq	r5,zero,2d988 <__sflush_r+0xd0>
   2d974:	88801004 	addi	r2,r17,64
   2d978:	28800226 	beq	r5,r2,2d984 <__sflush_r+0xcc>
   2d97c:	9809883a 	mov	r4,r19
   2d980:	002dc840 	call	2dc84 <_free_r>
   2d984:	88000c15 	stw	zero,48(r17)
   2d988:	0005883a 	mov	r2,zero
   2d98c:	dfc00417 	ldw	ra,16(sp)
   2d990:	dcc00317 	ldw	r19,12(sp)
   2d994:	dc800217 	ldw	r18,8(sp)
   2d998:	dc400117 	ldw	r17,4(sp)
   2d99c:	dc000017 	ldw	r16,0(sp)
   2d9a0:	dec00504 	addi	sp,sp,20
   2d9a4:	f800283a 	ret
   2d9a8:	2c800417 	ldw	r18,16(r5)
   2d9ac:	903ff626 	beq	r18,zero,2d988 <__reset+0xfff8d988>
   2d9b0:	2c000017 	ldw	r16,0(r5)
   2d9b4:	108000cc 	andi	r2,r2,3
   2d9b8:	2c800015 	stw	r18,0(r5)
   2d9bc:	84a1c83a 	sub	r16,r16,r18
   2d9c0:	1000131e 	bne	r2,zero,2da10 <__sflush_r+0x158>
   2d9c4:	28800517 	ldw	r2,20(r5)
   2d9c8:	88800215 	stw	r2,8(r17)
   2d9cc:	04000316 	blt	zero,r16,2d9dc <__sflush_r+0x124>
   2d9d0:	003fed06 	br	2d988 <__reset+0xfff8d988>
   2d9d4:	90a5883a 	add	r18,r18,r2
   2d9d8:	043feb0e 	bge	zero,r16,2d988 <__reset+0xfff8d988>
   2d9dc:	88800917 	ldw	r2,36(r17)
   2d9e0:	89400717 	ldw	r5,28(r17)
   2d9e4:	800f883a 	mov	r7,r16
   2d9e8:	900d883a 	mov	r6,r18
   2d9ec:	9809883a 	mov	r4,r19
   2d9f0:	103ee83a 	callr	r2
   2d9f4:	80a1c83a 	sub	r16,r16,r2
   2d9f8:	00bff616 	blt	zero,r2,2d9d4 <__reset+0xfff8d9d4>
   2d9fc:	88c0030b 	ldhu	r3,12(r17)
   2da00:	00bfffc4 	movi	r2,-1
   2da04:	18c01014 	ori	r3,r3,64
   2da08:	88c0030d 	sth	r3,12(r17)
   2da0c:	003fdf06 	br	2d98c <__reset+0xfff8d98c>
   2da10:	0005883a 	mov	r2,zero
   2da14:	003fec06 	br	2d9c8 <__reset+0xfff8d9c8>
   2da18:	88801415 	stw	r2,80(r17)
   2da1c:	003fd206 	br	2d968 <__reset+0xfff8d968>
   2da20:	28c00f17 	ldw	r3,60(r5)
   2da24:	00ffb316 	blt	zero,r3,2d8f4 <__reset+0xfff8d8f4>
   2da28:	003fd706 	br	2d988 <__reset+0xfff8d988>
   2da2c:	89400717 	ldw	r5,28(r17)
   2da30:	000d883a 	mov	r6,zero
   2da34:	01c00044 	movi	r7,1
   2da38:	9809883a 	mov	r4,r19
   2da3c:	403ee83a 	callr	r8
   2da40:	100d883a 	mov	r6,r2
   2da44:	00bfffc4 	movi	r2,-1
   2da48:	30801426 	beq	r6,r2,2da9c <__sflush_r+0x1e4>
   2da4c:	8880030b 	ldhu	r2,12(r17)
   2da50:	8a000a17 	ldw	r8,40(r17)
   2da54:	003fae06 	br	2d910 <__reset+0xfff8d910>
   2da58:	98c00017 	ldw	r3,0(r19)
   2da5c:	183fba26 	beq	r3,zero,2d948 <__reset+0xfff8d948>
   2da60:	01000744 	movi	r4,29
   2da64:	19000626 	beq	r3,r4,2da80 <__sflush_r+0x1c8>
   2da68:	01000584 	movi	r4,22
   2da6c:	19000426 	beq	r3,r4,2da80 <__sflush_r+0x1c8>
   2da70:	88c0030b 	ldhu	r3,12(r17)
   2da74:	18c01014 	ori	r3,r3,64
   2da78:	88c0030d 	sth	r3,12(r17)
   2da7c:	003fc306 	br	2d98c <__reset+0xfff8d98c>
   2da80:	8880030b 	ldhu	r2,12(r17)
   2da84:	88c00417 	ldw	r3,16(r17)
   2da88:	88000115 	stw	zero,4(r17)
   2da8c:	10bdffcc 	andi	r2,r2,63487
   2da90:	8880030d 	sth	r2,12(r17)
   2da94:	88c00015 	stw	r3,0(r17)
   2da98:	003fb306 	br	2d968 <__reset+0xfff8d968>
   2da9c:	98800017 	ldw	r2,0(r19)
   2daa0:	103fea26 	beq	r2,zero,2da4c <__reset+0xfff8da4c>
   2daa4:	00c00744 	movi	r3,29
   2daa8:	10c00226 	beq	r2,r3,2dab4 <__sflush_r+0x1fc>
   2daac:	00c00584 	movi	r3,22
   2dab0:	10c0031e 	bne	r2,r3,2dac0 <__sflush_r+0x208>
   2dab4:	9c000015 	stw	r16,0(r19)
   2dab8:	0005883a 	mov	r2,zero
   2dabc:	003fb306 	br	2d98c <__reset+0xfff8d98c>
   2dac0:	88c0030b 	ldhu	r3,12(r17)
   2dac4:	3005883a 	mov	r2,r6
   2dac8:	18c01014 	ori	r3,r3,64
   2dacc:	88c0030d 	sth	r3,12(r17)
   2dad0:	003fae06 	br	2d98c <__reset+0xfff8d98c>

0002dad4 <_fflush_r>:
   2dad4:	defffd04 	addi	sp,sp,-12
   2dad8:	dc000115 	stw	r16,4(sp)
   2dadc:	dfc00215 	stw	ra,8(sp)
   2dae0:	2021883a 	mov	r16,r4
   2dae4:	20000226 	beq	r4,zero,2daf0 <_fflush_r+0x1c>
   2dae8:	20800e17 	ldw	r2,56(r4)
   2daec:	10000c26 	beq	r2,zero,2db20 <_fflush_r+0x4c>
   2daf0:	2880030f 	ldh	r2,12(r5)
   2daf4:	1000051e 	bne	r2,zero,2db0c <_fflush_r+0x38>
   2daf8:	0005883a 	mov	r2,zero
   2dafc:	dfc00217 	ldw	ra,8(sp)
   2db00:	dc000117 	ldw	r16,4(sp)
   2db04:	dec00304 	addi	sp,sp,12
   2db08:	f800283a 	ret
   2db0c:	8009883a 	mov	r4,r16
   2db10:	dfc00217 	ldw	ra,8(sp)
   2db14:	dc000117 	ldw	r16,4(sp)
   2db18:	dec00304 	addi	sp,sp,12
   2db1c:	002d8b81 	jmpi	2d8b8 <__sflush_r>
   2db20:	d9400015 	stw	r5,0(sp)
   2db24:	002bdd80 	call	2bdd8 <__sinit>
   2db28:	d9400017 	ldw	r5,0(sp)
   2db2c:	003ff006 	br	2daf0 <__reset+0xfff8daf0>

0002db30 <fflush>:
   2db30:	20000526 	beq	r4,zero,2db48 <fflush+0x18>
   2db34:	008000f4 	movhi	r2,3
   2db38:	10931804 	addi	r2,r2,19552
   2db3c:	200b883a 	mov	r5,r4
   2db40:	11000017 	ldw	r4,0(r2)
   2db44:	002dad41 	jmpi	2dad4 <_fflush_r>
   2db48:	008000f4 	movhi	r2,3
   2db4c:	10931704 	addi	r2,r2,19548
   2db50:	11000017 	ldw	r4,0(r2)
   2db54:	014000f4 	movhi	r5,3
   2db58:	2976b504 	addi	r5,r5,-9516
   2db5c:	002c3a81 	jmpi	2c3a8 <_fwalk_reent>

0002db60 <_malloc_trim_r>:
   2db60:	defffb04 	addi	sp,sp,-20
   2db64:	dcc00315 	stw	r19,12(sp)
   2db68:	04c000f4 	movhi	r19,3
   2db6c:	dc800215 	stw	r18,8(sp)
   2db70:	dc400115 	stw	r17,4(sp)
   2db74:	dc000015 	stw	r16,0(sp)
   2db78:	dfc00415 	stw	ra,16(sp)
   2db7c:	2821883a 	mov	r16,r5
   2db80:	9ccd2e04 	addi	r19,r19,13496
   2db84:	2025883a 	mov	r18,r4
   2db88:	002e7500 	call	2e750 <__malloc_lock>
   2db8c:	98800217 	ldw	r2,8(r19)
   2db90:	14400117 	ldw	r17,4(r2)
   2db94:	00bfff04 	movi	r2,-4
   2db98:	88a2703a 	and	r17,r17,r2
   2db9c:	8c21c83a 	sub	r16,r17,r16
   2dba0:	8403fbc4 	addi	r16,r16,4079
   2dba4:	8020d33a 	srli	r16,r16,12
   2dba8:	0083ffc4 	movi	r2,4095
   2dbac:	843fffc4 	addi	r16,r16,-1
   2dbb0:	8020933a 	slli	r16,r16,12
   2dbb4:	1400060e 	bge	r2,r16,2dbd0 <_malloc_trim_r+0x70>
   2dbb8:	000b883a 	mov	r5,zero
   2dbbc:	9009883a 	mov	r4,r18
   2dbc0:	002d41c0 	call	2d41c <_sbrk_r>
   2dbc4:	98c00217 	ldw	r3,8(r19)
   2dbc8:	1c47883a 	add	r3,r3,r17
   2dbcc:	10c00a26 	beq	r2,r3,2dbf8 <_malloc_trim_r+0x98>
   2dbd0:	9009883a 	mov	r4,r18
   2dbd4:	002e7740 	call	2e774 <__malloc_unlock>
   2dbd8:	0005883a 	mov	r2,zero
   2dbdc:	dfc00417 	ldw	ra,16(sp)
   2dbe0:	dcc00317 	ldw	r19,12(sp)
   2dbe4:	dc800217 	ldw	r18,8(sp)
   2dbe8:	dc400117 	ldw	r17,4(sp)
   2dbec:	dc000017 	ldw	r16,0(sp)
   2dbf0:	dec00504 	addi	sp,sp,20
   2dbf4:	f800283a 	ret
   2dbf8:	040bc83a 	sub	r5,zero,r16
   2dbfc:	9009883a 	mov	r4,r18
   2dc00:	002d41c0 	call	2d41c <_sbrk_r>
   2dc04:	00ffffc4 	movi	r3,-1
   2dc08:	10c00d26 	beq	r2,r3,2dc40 <_malloc_trim_r+0xe0>
   2dc0c:	00c00134 	movhi	r3,4
   2dc10:	18e3bc04 	addi	r3,r3,-28944
   2dc14:	18800017 	ldw	r2,0(r3)
   2dc18:	99000217 	ldw	r4,8(r19)
   2dc1c:	8c23c83a 	sub	r17,r17,r16
   2dc20:	8c400054 	ori	r17,r17,1
   2dc24:	1421c83a 	sub	r16,r2,r16
   2dc28:	24400115 	stw	r17,4(r4)
   2dc2c:	9009883a 	mov	r4,r18
   2dc30:	1c000015 	stw	r16,0(r3)
   2dc34:	002e7740 	call	2e774 <__malloc_unlock>
   2dc38:	00800044 	movi	r2,1
   2dc3c:	003fe706 	br	2dbdc <__reset+0xfff8dbdc>
   2dc40:	000b883a 	mov	r5,zero
   2dc44:	9009883a 	mov	r4,r18
   2dc48:	002d41c0 	call	2d41c <_sbrk_r>
   2dc4c:	99000217 	ldw	r4,8(r19)
   2dc50:	014003c4 	movi	r5,15
   2dc54:	1107c83a 	sub	r3,r2,r4
   2dc58:	28ffdd0e 	bge	r5,r3,2dbd0 <__reset+0xfff8dbd0>
   2dc5c:	014000f4 	movhi	r5,3
   2dc60:	29531904 	addi	r5,r5,19556
   2dc64:	29400017 	ldw	r5,0(r5)
   2dc68:	18c00054 	ori	r3,r3,1
   2dc6c:	20c00115 	stw	r3,4(r4)
   2dc70:	00c00134 	movhi	r3,4
   2dc74:	1145c83a 	sub	r2,r2,r5
   2dc78:	18e3bc04 	addi	r3,r3,-28944
   2dc7c:	18800015 	stw	r2,0(r3)
   2dc80:	003fd306 	br	2dbd0 <__reset+0xfff8dbd0>

0002dc84 <_free_r>:
   2dc84:	28004126 	beq	r5,zero,2dd8c <_free_r+0x108>
   2dc88:	defffd04 	addi	sp,sp,-12
   2dc8c:	dc400115 	stw	r17,4(sp)
   2dc90:	dc000015 	stw	r16,0(sp)
   2dc94:	2023883a 	mov	r17,r4
   2dc98:	2821883a 	mov	r16,r5
   2dc9c:	dfc00215 	stw	ra,8(sp)
   2dca0:	002e7500 	call	2e750 <__malloc_lock>
   2dca4:	81ffff17 	ldw	r7,-4(r16)
   2dca8:	00bfff84 	movi	r2,-2
   2dcac:	010000f4 	movhi	r4,3
   2dcb0:	81bffe04 	addi	r6,r16,-8
   2dcb4:	3884703a 	and	r2,r7,r2
   2dcb8:	210d2e04 	addi	r4,r4,13496
   2dcbc:	308b883a 	add	r5,r6,r2
   2dcc0:	2a400117 	ldw	r9,4(r5)
   2dcc4:	22000217 	ldw	r8,8(r4)
   2dcc8:	00ffff04 	movi	r3,-4
   2dccc:	48c6703a 	and	r3,r9,r3
   2dcd0:	2a005726 	beq	r5,r8,2de30 <_free_r+0x1ac>
   2dcd4:	28c00115 	stw	r3,4(r5)
   2dcd8:	39c0004c 	andi	r7,r7,1
   2dcdc:	3800091e 	bne	r7,zero,2dd04 <_free_r+0x80>
   2dce0:	823ffe17 	ldw	r8,-8(r16)
   2dce4:	22400204 	addi	r9,r4,8
   2dce8:	320dc83a 	sub	r6,r6,r8
   2dcec:	31c00217 	ldw	r7,8(r6)
   2dcf0:	1205883a 	add	r2,r2,r8
   2dcf4:	3a406526 	beq	r7,r9,2de8c <_free_r+0x208>
   2dcf8:	32000317 	ldw	r8,12(r6)
   2dcfc:	3a000315 	stw	r8,12(r7)
   2dd00:	41c00215 	stw	r7,8(r8)
   2dd04:	28cf883a 	add	r7,r5,r3
   2dd08:	39c00117 	ldw	r7,4(r7)
   2dd0c:	39c0004c 	andi	r7,r7,1
   2dd10:	38003a26 	beq	r7,zero,2ddfc <_free_r+0x178>
   2dd14:	10c00054 	ori	r3,r2,1
   2dd18:	30c00115 	stw	r3,4(r6)
   2dd1c:	3087883a 	add	r3,r6,r2
   2dd20:	18800015 	stw	r2,0(r3)
   2dd24:	00c07fc4 	movi	r3,511
   2dd28:	18801936 	bltu	r3,r2,2dd90 <_free_r+0x10c>
   2dd2c:	1004d0fa 	srli	r2,r2,3
   2dd30:	01c00044 	movi	r7,1
   2dd34:	21400117 	ldw	r5,4(r4)
   2dd38:	10c00044 	addi	r3,r2,1
   2dd3c:	18c7883a 	add	r3,r3,r3
   2dd40:	1005d0ba 	srai	r2,r2,2
   2dd44:	18c7883a 	add	r3,r3,r3
   2dd48:	18c7883a 	add	r3,r3,r3
   2dd4c:	1907883a 	add	r3,r3,r4
   2dd50:	3884983a 	sll	r2,r7,r2
   2dd54:	19c00017 	ldw	r7,0(r3)
   2dd58:	1a3ffe04 	addi	r8,r3,-8
   2dd5c:	1144b03a 	or	r2,r2,r5
   2dd60:	32000315 	stw	r8,12(r6)
   2dd64:	31c00215 	stw	r7,8(r6)
   2dd68:	20800115 	stw	r2,4(r4)
   2dd6c:	19800015 	stw	r6,0(r3)
   2dd70:	39800315 	stw	r6,12(r7)
   2dd74:	8809883a 	mov	r4,r17
   2dd78:	dfc00217 	ldw	ra,8(sp)
   2dd7c:	dc400117 	ldw	r17,4(sp)
   2dd80:	dc000017 	ldw	r16,0(sp)
   2dd84:	dec00304 	addi	sp,sp,12
   2dd88:	002e7741 	jmpi	2e774 <__malloc_unlock>
   2dd8c:	f800283a 	ret
   2dd90:	100ad27a 	srli	r5,r2,9
   2dd94:	00c00104 	movi	r3,4
   2dd98:	19404a36 	bltu	r3,r5,2dec4 <_free_r+0x240>
   2dd9c:	100ad1ba 	srli	r5,r2,6
   2dda0:	28c00e44 	addi	r3,r5,57
   2dda4:	18c7883a 	add	r3,r3,r3
   2dda8:	29400e04 	addi	r5,r5,56
   2ddac:	18c7883a 	add	r3,r3,r3
   2ddb0:	18c7883a 	add	r3,r3,r3
   2ddb4:	1909883a 	add	r4,r3,r4
   2ddb8:	20c00017 	ldw	r3,0(r4)
   2ddbc:	01c000f4 	movhi	r7,3
   2ddc0:	213ffe04 	addi	r4,r4,-8
   2ddc4:	39cd2e04 	addi	r7,r7,13496
   2ddc8:	20c04426 	beq	r4,r3,2dedc <_free_r+0x258>
   2ddcc:	01ffff04 	movi	r7,-4
   2ddd0:	19400117 	ldw	r5,4(r3)
   2ddd4:	29ca703a 	and	r5,r5,r7
   2ddd8:	1140022e 	bgeu	r2,r5,2dde4 <_free_r+0x160>
   2dddc:	18c00217 	ldw	r3,8(r3)
   2dde0:	20fffb1e 	bne	r4,r3,2ddd0 <__reset+0xfff8ddd0>
   2dde4:	19000317 	ldw	r4,12(r3)
   2dde8:	31000315 	stw	r4,12(r6)
   2ddec:	30c00215 	stw	r3,8(r6)
   2ddf0:	21800215 	stw	r6,8(r4)
   2ddf4:	19800315 	stw	r6,12(r3)
   2ddf8:	003fde06 	br	2dd74 <__reset+0xfff8dd74>
   2ddfc:	29c00217 	ldw	r7,8(r5)
   2de00:	10c5883a 	add	r2,r2,r3
   2de04:	00c000f4 	movhi	r3,3
   2de08:	18cd3004 	addi	r3,r3,13504
   2de0c:	38c03b26 	beq	r7,r3,2defc <_free_r+0x278>
   2de10:	2a000317 	ldw	r8,12(r5)
   2de14:	11400054 	ori	r5,r2,1
   2de18:	3087883a 	add	r3,r6,r2
   2de1c:	3a000315 	stw	r8,12(r7)
   2de20:	41c00215 	stw	r7,8(r8)
   2de24:	31400115 	stw	r5,4(r6)
   2de28:	18800015 	stw	r2,0(r3)
   2de2c:	003fbd06 	br	2dd24 <__reset+0xfff8dd24>
   2de30:	39c0004c 	andi	r7,r7,1
   2de34:	10c5883a 	add	r2,r2,r3
   2de38:	3800071e 	bne	r7,zero,2de58 <_free_r+0x1d4>
   2de3c:	81fffe17 	ldw	r7,-8(r16)
   2de40:	31cdc83a 	sub	r6,r6,r7
   2de44:	30c00317 	ldw	r3,12(r6)
   2de48:	31400217 	ldw	r5,8(r6)
   2de4c:	11c5883a 	add	r2,r2,r7
   2de50:	28c00315 	stw	r3,12(r5)
   2de54:	19400215 	stw	r5,8(r3)
   2de58:	10c00054 	ori	r3,r2,1
   2de5c:	30c00115 	stw	r3,4(r6)
   2de60:	00c000f4 	movhi	r3,3
   2de64:	18d31a04 	addi	r3,r3,19560
   2de68:	18c00017 	ldw	r3,0(r3)
   2de6c:	21800215 	stw	r6,8(r4)
   2de70:	10ffc036 	bltu	r2,r3,2dd74 <__reset+0xfff8dd74>
   2de74:	008000f4 	movhi	r2,3
   2de78:	10934604 	addi	r2,r2,19736
   2de7c:	11400017 	ldw	r5,0(r2)
   2de80:	8809883a 	mov	r4,r17
   2de84:	002db600 	call	2db60 <_malloc_trim_r>
   2de88:	003fba06 	br	2dd74 <__reset+0xfff8dd74>
   2de8c:	28c9883a 	add	r4,r5,r3
   2de90:	21000117 	ldw	r4,4(r4)
   2de94:	2100004c 	andi	r4,r4,1
   2de98:	2000391e 	bne	r4,zero,2df80 <_free_r+0x2fc>
   2de9c:	29c00217 	ldw	r7,8(r5)
   2dea0:	29000317 	ldw	r4,12(r5)
   2dea4:	1885883a 	add	r2,r3,r2
   2dea8:	10c00054 	ori	r3,r2,1
   2deac:	39000315 	stw	r4,12(r7)
   2deb0:	21c00215 	stw	r7,8(r4)
   2deb4:	30c00115 	stw	r3,4(r6)
   2deb8:	308d883a 	add	r6,r6,r2
   2debc:	30800015 	stw	r2,0(r6)
   2dec0:	003fac06 	br	2dd74 <__reset+0xfff8dd74>
   2dec4:	00c00504 	movi	r3,20
   2dec8:	19401536 	bltu	r3,r5,2df20 <_free_r+0x29c>
   2decc:	28c01704 	addi	r3,r5,92
   2ded0:	18c7883a 	add	r3,r3,r3
   2ded4:	294016c4 	addi	r5,r5,91
   2ded8:	003fb406 	br	2ddac <__reset+0xfff8ddac>
   2dedc:	280bd0ba 	srai	r5,r5,2
   2dee0:	00c00044 	movi	r3,1
   2dee4:	38800117 	ldw	r2,4(r7)
   2dee8:	194a983a 	sll	r5,r3,r5
   2deec:	2007883a 	mov	r3,r4
   2def0:	2884b03a 	or	r2,r5,r2
   2def4:	38800115 	stw	r2,4(r7)
   2def8:	003fbb06 	br	2dde8 <__reset+0xfff8dde8>
   2defc:	21800515 	stw	r6,20(r4)
   2df00:	21800415 	stw	r6,16(r4)
   2df04:	10c00054 	ori	r3,r2,1
   2df08:	31c00315 	stw	r7,12(r6)
   2df0c:	31c00215 	stw	r7,8(r6)
   2df10:	30c00115 	stw	r3,4(r6)
   2df14:	308d883a 	add	r6,r6,r2
   2df18:	30800015 	stw	r2,0(r6)
   2df1c:	003f9506 	br	2dd74 <__reset+0xfff8dd74>
   2df20:	00c01504 	movi	r3,84
   2df24:	19400536 	bltu	r3,r5,2df3c <_free_r+0x2b8>
   2df28:	100ad33a 	srli	r5,r2,12
   2df2c:	28c01bc4 	addi	r3,r5,111
   2df30:	18c7883a 	add	r3,r3,r3
   2df34:	29401b84 	addi	r5,r5,110
   2df38:	003f9c06 	br	2ddac <__reset+0xfff8ddac>
   2df3c:	00c05504 	movi	r3,340
   2df40:	19400536 	bltu	r3,r5,2df58 <_free_r+0x2d4>
   2df44:	100ad3fa 	srli	r5,r2,15
   2df48:	28c01e04 	addi	r3,r5,120
   2df4c:	18c7883a 	add	r3,r3,r3
   2df50:	29401dc4 	addi	r5,r5,119
   2df54:	003f9506 	br	2ddac <__reset+0xfff8ddac>
   2df58:	00c15504 	movi	r3,1364
   2df5c:	19400536 	bltu	r3,r5,2df74 <_free_r+0x2f0>
   2df60:	100ad4ba 	srli	r5,r2,18
   2df64:	28c01f44 	addi	r3,r5,125
   2df68:	18c7883a 	add	r3,r3,r3
   2df6c:	29401f04 	addi	r5,r5,124
   2df70:	003f8e06 	br	2ddac <__reset+0xfff8ddac>
   2df74:	00c03f84 	movi	r3,254
   2df78:	01401f84 	movi	r5,126
   2df7c:	003f8b06 	br	2ddac <__reset+0xfff8ddac>
   2df80:	10c00054 	ori	r3,r2,1
   2df84:	30c00115 	stw	r3,4(r6)
   2df88:	308d883a 	add	r6,r6,r2
   2df8c:	30800015 	stw	r2,0(r6)
   2df90:	003f7806 	br	2dd74 <__reset+0xfff8dd74>

0002df94 <_lseek_r>:
   2df94:	defffd04 	addi	sp,sp,-12
   2df98:	2805883a 	mov	r2,r5
   2df9c:	dc000015 	stw	r16,0(sp)
   2dfa0:	040000f4 	movhi	r16,3
   2dfa4:	dc400115 	stw	r17,4(sp)
   2dfa8:	300b883a 	mov	r5,r6
   2dfac:	84134704 	addi	r16,r16,19740
   2dfb0:	2023883a 	mov	r17,r4
   2dfb4:	380d883a 	mov	r6,r7
   2dfb8:	1009883a 	mov	r4,r2
   2dfbc:	dfc00215 	stw	ra,8(sp)
   2dfc0:	80000015 	stw	zero,0(r16)
   2dfc4:	002e6000 	call	2e600 <lseek>
   2dfc8:	00ffffc4 	movi	r3,-1
   2dfcc:	10c00526 	beq	r2,r3,2dfe4 <_lseek_r+0x50>
   2dfd0:	dfc00217 	ldw	ra,8(sp)
   2dfd4:	dc400117 	ldw	r17,4(sp)
   2dfd8:	dc000017 	ldw	r16,0(sp)
   2dfdc:	dec00304 	addi	sp,sp,12
   2dfe0:	f800283a 	ret
   2dfe4:	80c00017 	ldw	r3,0(r16)
   2dfe8:	183ff926 	beq	r3,zero,2dfd0 <__reset+0xfff8dfd0>
   2dfec:	88c00015 	stw	r3,0(r17)
   2dff0:	003ff706 	br	2dfd0 <__reset+0xfff8dfd0>

0002dff4 <__smakebuf_r>:
   2dff4:	2880030b 	ldhu	r2,12(r5)
   2dff8:	10c0008c 	andi	r3,r2,2
   2dffc:	1800411e 	bne	r3,zero,2e104 <__smakebuf_r+0x110>
   2e000:	deffec04 	addi	sp,sp,-80
   2e004:	dc000f15 	stw	r16,60(sp)
   2e008:	2821883a 	mov	r16,r5
   2e00c:	2940038f 	ldh	r5,14(r5)
   2e010:	dc401015 	stw	r17,64(sp)
   2e014:	dfc01315 	stw	ra,76(sp)
   2e018:	dcc01215 	stw	r19,72(sp)
   2e01c:	dc801115 	stw	r18,68(sp)
   2e020:	2023883a 	mov	r17,r4
   2e024:	28001c16 	blt	r5,zero,2e098 <__smakebuf_r+0xa4>
   2e028:	d80d883a 	mov	r6,sp
   2e02c:	002e2100 	call	2e210 <_fstat_r>
   2e030:	10001816 	blt	r2,zero,2e094 <__smakebuf_r+0xa0>
   2e034:	d8800117 	ldw	r2,4(sp)
   2e038:	00e00014 	movui	r3,32768
   2e03c:	10bc000c 	andi	r2,r2,61440
   2e040:	14c80020 	cmpeqi	r19,r2,8192
   2e044:	10c03726 	beq	r2,r3,2e124 <__smakebuf_r+0x130>
   2e048:	80c0030b 	ldhu	r3,12(r16)
   2e04c:	18c20014 	ori	r3,r3,2048
   2e050:	80c0030d 	sth	r3,12(r16)
   2e054:	00c80004 	movi	r3,8192
   2e058:	10c0521e 	bne	r2,r3,2e1a4 <__smakebuf_r+0x1b0>
   2e05c:	8140038f 	ldh	r5,14(r16)
   2e060:	8809883a 	mov	r4,r17
   2e064:	002e26c0 	call	2e26c <_isatty_r>
   2e068:	10004c26 	beq	r2,zero,2e19c <__smakebuf_r+0x1a8>
   2e06c:	8080030b 	ldhu	r2,12(r16)
   2e070:	80c010c4 	addi	r3,r16,67
   2e074:	80c00015 	stw	r3,0(r16)
   2e078:	10800054 	ori	r2,r2,1
   2e07c:	8080030d 	sth	r2,12(r16)
   2e080:	00800044 	movi	r2,1
   2e084:	80c00415 	stw	r3,16(r16)
   2e088:	80800515 	stw	r2,20(r16)
   2e08c:	04810004 	movi	r18,1024
   2e090:	00000706 	br	2e0b0 <__smakebuf_r+0xbc>
   2e094:	8080030b 	ldhu	r2,12(r16)
   2e098:	10c0200c 	andi	r3,r2,128
   2e09c:	18001f1e 	bne	r3,zero,2e11c <__smakebuf_r+0x128>
   2e0a0:	04810004 	movi	r18,1024
   2e0a4:	10820014 	ori	r2,r2,2048
   2e0a8:	8080030d 	sth	r2,12(r16)
   2e0ac:	0027883a 	mov	r19,zero
   2e0b0:	900b883a 	mov	r5,r18
   2e0b4:	8809883a 	mov	r4,r17
   2e0b8:	002c46c0 	call	2c46c <_malloc_r>
   2e0bc:	10002c26 	beq	r2,zero,2e170 <__smakebuf_r+0x17c>
   2e0c0:	80c0030b 	ldhu	r3,12(r16)
   2e0c4:	010000f4 	movhi	r4,3
   2e0c8:	212ea404 	addi	r4,r4,-17776
   2e0cc:	89000f15 	stw	r4,60(r17)
   2e0d0:	18c02014 	ori	r3,r3,128
   2e0d4:	80c0030d 	sth	r3,12(r16)
   2e0d8:	80800015 	stw	r2,0(r16)
   2e0dc:	80800415 	stw	r2,16(r16)
   2e0e0:	84800515 	stw	r18,20(r16)
   2e0e4:	98001a1e 	bne	r19,zero,2e150 <__smakebuf_r+0x15c>
   2e0e8:	dfc01317 	ldw	ra,76(sp)
   2e0ec:	dcc01217 	ldw	r19,72(sp)
   2e0f0:	dc801117 	ldw	r18,68(sp)
   2e0f4:	dc401017 	ldw	r17,64(sp)
   2e0f8:	dc000f17 	ldw	r16,60(sp)
   2e0fc:	dec01404 	addi	sp,sp,80
   2e100:	f800283a 	ret
   2e104:	288010c4 	addi	r2,r5,67
   2e108:	28800015 	stw	r2,0(r5)
   2e10c:	28800415 	stw	r2,16(r5)
   2e110:	00800044 	movi	r2,1
   2e114:	28800515 	stw	r2,20(r5)
   2e118:	f800283a 	ret
   2e11c:	04801004 	movi	r18,64
   2e120:	003fe006 	br	2e0a4 <__reset+0xfff8e0a4>
   2e124:	81000a17 	ldw	r4,40(r16)
   2e128:	00c000f4 	movhi	r3,3
   2e12c:	18f55204 	addi	r3,r3,-10936
   2e130:	20ffc51e 	bne	r4,r3,2e048 <__reset+0xfff8e048>
   2e134:	8080030b 	ldhu	r2,12(r16)
   2e138:	04810004 	movi	r18,1024
   2e13c:	84801315 	stw	r18,76(r16)
   2e140:	1484b03a 	or	r2,r2,r18
   2e144:	8080030d 	sth	r2,12(r16)
   2e148:	0027883a 	mov	r19,zero
   2e14c:	003fd806 	br	2e0b0 <__reset+0xfff8e0b0>
   2e150:	8140038f 	ldh	r5,14(r16)
   2e154:	8809883a 	mov	r4,r17
   2e158:	002e26c0 	call	2e26c <_isatty_r>
   2e15c:	103fe226 	beq	r2,zero,2e0e8 <__reset+0xfff8e0e8>
   2e160:	8080030b 	ldhu	r2,12(r16)
   2e164:	10800054 	ori	r2,r2,1
   2e168:	8080030d 	sth	r2,12(r16)
   2e16c:	003fde06 	br	2e0e8 <__reset+0xfff8e0e8>
   2e170:	8080030b 	ldhu	r2,12(r16)
   2e174:	10c0800c 	andi	r3,r2,512
   2e178:	183fdb1e 	bne	r3,zero,2e0e8 <__reset+0xfff8e0e8>
   2e17c:	10800094 	ori	r2,r2,2
   2e180:	80c010c4 	addi	r3,r16,67
   2e184:	8080030d 	sth	r2,12(r16)
   2e188:	00800044 	movi	r2,1
   2e18c:	80c00015 	stw	r3,0(r16)
   2e190:	80c00415 	stw	r3,16(r16)
   2e194:	80800515 	stw	r2,20(r16)
   2e198:	003fd306 	br	2e0e8 <__reset+0xfff8e0e8>
   2e19c:	04810004 	movi	r18,1024
   2e1a0:	003fc306 	br	2e0b0 <__reset+0xfff8e0b0>
   2e1a4:	0027883a 	mov	r19,zero
   2e1a8:	04810004 	movi	r18,1024
   2e1ac:	003fc006 	br	2e0b0 <__reset+0xfff8e0b0>

0002e1b0 <_read_r>:
   2e1b0:	defffd04 	addi	sp,sp,-12
   2e1b4:	2805883a 	mov	r2,r5
   2e1b8:	dc000015 	stw	r16,0(sp)
   2e1bc:	040000f4 	movhi	r16,3
   2e1c0:	dc400115 	stw	r17,4(sp)
   2e1c4:	300b883a 	mov	r5,r6
   2e1c8:	84134704 	addi	r16,r16,19740
   2e1cc:	2023883a 	mov	r17,r4
   2e1d0:	380d883a 	mov	r6,r7
   2e1d4:	1009883a 	mov	r4,r2
   2e1d8:	dfc00215 	stw	ra,8(sp)
   2e1dc:	80000015 	stw	zero,0(r16)
   2e1e0:	002e7d40 	call	2e7d4 <read>
   2e1e4:	00ffffc4 	movi	r3,-1
   2e1e8:	10c00526 	beq	r2,r3,2e200 <_read_r+0x50>
   2e1ec:	dfc00217 	ldw	ra,8(sp)
   2e1f0:	dc400117 	ldw	r17,4(sp)
   2e1f4:	dc000017 	ldw	r16,0(sp)
   2e1f8:	dec00304 	addi	sp,sp,12
   2e1fc:	f800283a 	ret
   2e200:	80c00017 	ldw	r3,0(r16)
   2e204:	183ff926 	beq	r3,zero,2e1ec <__reset+0xfff8e1ec>
   2e208:	88c00015 	stw	r3,0(r17)
   2e20c:	003ff706 	br	2e1ec <__reset+0xfff8e1ec>

0002e210 <_fstat_r>:
   2e210:	defffd04 	addi	sp,sp,-12
   2e214:	2805883a 	mov	r2,r5
   2e218:	dc000015 	stw	r16,0(sp)
   2e21c:	040000f4 	movhi	r16,3
   2e220:	dc400115 	stw	r17,4(sp)
   2e224:	84134704 	addi	r16,r16,19740
   2e228:	2023883a 	mov	r17,r4
   2e22c:	300b883a 	mov	r5,r6
   2e230:	1009883a 	mov	r4,r2
   2e234:	dfc00215 	stw	ra,8(sp)
   2e238:	80000015 	stw	zero,0(r16)
   2e23c:	002e4340 	call	2e434 <fstat>
   2e240:	00ffffc4 	movi	r3,-1
   2e244:	10c00526 	beq	r2,r3,2e25c <_fstat_r+0x4c>
   2e248:	dfc00217 	ldw	ra,8(sp)
   2e24c:	dc400117 	ldw	r17,4(sp)
   2e250:	dc000017 	ldw	r16,0(sp)
   2e254:	dec00304 	addi	sp,sp,12
   2e258:	f800283a 	ret
   2e25c:	80c00017 	ldw	r3,0(r16)
   2e260:	183ff926 	beq	r3,zero,2e248 <__reset+0xfff8e248>
   2e264:	88c00015 	stw	r3,0(r17)
   2e268:	003ff706 	br	2e248 <__reset+0xfff8e248>

0002e26c <_isatty_r>:
   2e26c:	defffd04 	addi	sp,sp,-12
   2e270:	dc000015 	stw	r16,0(sp)
   2e274:	040000f4 	movhi	r16,3
   2e278:	dc400115 	stw	r17,4(sp)
   2e27c:	84134704 	addi	r16,r16,19740
   2e280:	2023883a 	mov	r17,r4
   2e284:	2809883a 	mov	r4,r5
   2e288:	dfc00215 	stw	ra,8(sp)
   2e28c:	80000015 	stw	zero,0(r16)
   2e290:	002e5200 	call	2e520 <isatty>
   2e294:	00ffffc4 	movi	r3,-1
   2e298:	10c00526 	beq	r2,r3,2e2b0 <_isatty_r+0x44>
   2e29c:	dfc00217 	ldw	ra,8(sp)
   2e2a0:	dc400117 	ldw	r17,4(sp)
   2e2a4:	dc000017 	ldw	r16,0(sp)
   2e2a8:	dec00304 	addi	sp,sp,12
   2e2ac:	f800283a 	ret
   2e2b0:	80c00017 	ldw	r3,0(r16)
   2e2b4:	183ff926 	beq	r3,zero,2e29c <__reset+0xfff8e29c>
   2e2b8:	88c00015 	stw	r3,0(r17)
   2e2bc:	003ff706 	br	2e29c <__reset+0xfff8e29c>

0002e2c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e2c0:	defffe04 	addi	sp,sp,-8
   2e2c4:	dfc00115 	stw	ra,4(sp)
   2e2c8:	df000015 	stw	fp,0(sp)
   2e2cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e2d0:	d0a00f17 	ldw	r2,-32708(gp)
   2e2d4:	10000326 	beq	r2,zero,2e2e4 <alt_get_errno+0x24>
   2e2d8:	d0a00f17 	ldw	r2,-32708(gp)
   2e2dc:	103ee83a 	callr	r2
   2e2e0:	00000106 	br	2e2e8 <alt_get_errno+0x28>
   2e2e4:	d0a03604 	addi	r2,gp,-32552
}
   2e2e8:	e037883a 	mov	sp,fp
   2e2ec:	dfc00117 	ldw	ra,4(sp)
   2e2f0:	df000017 	ldw	fp,0(sp)
   2e2f4:	dec00204 	addi	sp,sp,8
   2e2f8:	f800283a 	ret

0002e2fc <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   2e2fc:	defffb04 	addi	sp,sp,-20
   2e300:	dfc00415 	stw	ra,16(sp)
   2e304:	df000315 	stw	fp,12(sp)
   2e308:	df000304 	addi	fp,sp,12
   2e30c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   2e310:	e0bfff17 	ldw	r2,-4(fp)
   2e314:	10000616 	blt	r2,zero,2e330 <close+0x34>
   2e318:	e0bfff17 	ldw	r2,-4(fp)
   2e31c:	10c00324 	muli	r3,r2,12
   2e320:	008000f4 	movhi	r2,3
   2e324:	108e3a04 	addi	r2,r2,14568
   2e328:	1885883a 	add	r2,r3,r2
   2e32c:	00000106 	br	2e334 <close+0x38>
   2e330:	0005883a 	mov	r2,zero
   2e334:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   2e338:	e0bffd17 	ldw	r2,-12(fp)
   2e33c:	10001926 	beq	r2,zero,2e3a4 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   2e340:	e0bffd17 	ldw	r2,-12(fp)
   2e344:	10800017 	ldw	r2,0(r2)
   2e348:	10800417 	ldw	r2,16(r2)
   2e34c:	10000626 	beq	r2,zero,2e368 <close+0x6c>
   2e350:	e0bffd17 	ldw	r2,-12(fp)
   2e354:	10800017 	ldw	r2,0(r2)
   2e358:	10800417 	ldw	r2,16(r2)
   2e35c:	e13ffd17 	ldw	r4,-12(fp)
   2e360:	103ee83a 	callr	r2
   2e364:	00000106 	br	2e36c <close+0x70>
   2e368:	0005883a 	mov	r2,zero
   2e36c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   2e370:	e13fff17 	ldw	r4,-4(fp)
   2e374:	002e8d00 	call	2e8d0 <alt_release_fd>
    if (rval < 0)
   2e378:	e0bffe17 	ldw	r2,-8(fp)
   2e37c:	1000070e 	bge	r2,zero,2e39c <close+0xa0>
    {
      ALT_ERRNO = -rval;
   2e380:	002e2c00 	call	2e2c0 <alt_get_errno>
   2e384:	1007883a 	mov	r3,r2
   2e388:	e0bffe17 	ldw	r2,-8(fp)
   2e38c:	0085c83a 	sub	r2,zero,r2
   2e390:	18800015 	stw	r2,0(r3)
      return -1;
   2e394:	00bfffc4 	movi	r2,-1
   2e398:	00000706 	br	2e3b8 <close+0xbc>
    }
    return 0;
   2e39c:	0005883a 	mov	r2,zero
   2e3a0:	00000506 	br	2e3b8 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   2e3a4:	002e2c00 	call	2e2c0 <alt_get_errno>
   2e3a8:	1007883a 	mov	r3,r2
   2e3ac:	00801444 	movi	r2,81
   2e3b0:	18800015 	stw	r2,0(r3)
    return -1;
   2e3b4:	00bfffc4 	movi	r2,-1
  }
}
   2e3b8:	e037883a 	mov	sp,fp
   2e3bc:	dfc00117 	ldw	ra,4(sp)
   2e3c0:	df000017 	ldw	fp,0(sp)
   2e3c4:	dec00204 	addi	sp,sp,8
   2e3c8:	f800283a 	ret

0002e3cc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   2e3cc:	defffc04 	addi	sp,sp,-16
   2e3d0:	df000315 	stw	fp,12(sp)
   2e3d4:	df000304 	addi	fp,sp,12
   2e3d8:	e13ffd15 	stw	r4,-12(fp)
   2e3dc:	e17ffe15 	stw	r5,-8(fp)
   2e3e0:	e1bfff15 	stw	r6,-4(fp)
  return len;
   2e3e4:	e0bfff17 	ldw	r2,-4(fp)
}
   2e3e8:	e037883a 	mov	sp,fp
   2e3ec:	df000017 	ldw	fp,0(sp)
   2e3f0:	dec00104 	addi	sp,sp,4
   2e3f4:	f800283a 	ret

0002e3f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e3f8:	defffe04 	addi	sp,sp,-8
   2e3fc:	dfc00115 	stw	ra,4(sp)
   2e400:	df000015 	stw	fp,0(sp)
   2e404:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e408:	d0a00f17 	ldw	r2,-32708(gp)
   2e40c:	10000326 	beq	r2,zero,2e41c <alt_get_errno+0x24>
   2e410:	d0a00f17 	ldw	r2,-32708(gp)
   2e414:	103ee83a 	callr	r2
   2e418:	00000106 	br	2e420 <alt_get_errno+0x28>
   2e41c:	d0a03604 	addi	r2,gp,-32552
}
   2e420:	e037883a 	mov	sp,fp
   2e424:	dfc00117 	ldw	ra,4(sp)
   2e428:	df000017 	ldw	fp,0(sp)
   2e42c:	dec00204 	addi	sp,sp,8
   2e430:	f800283a 	ret

0002e434 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   2e434:	defffb04 	addi	sp,sp,-20
   2e438:	dfc00415 	stw	ra,16(sp)
   2e43c:	df000315 	stw	fp,12(sp)
   2e440:	df000304 	addi	fp,sp,12
   2e444:	e13ffe15 	stw	r4,-8(fp)
   2e448:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2e44c:	e0bffe17 	ldw	r2,-8(fp)
   2e450:	10000616 	blt	r2,zero,2e46c <fstat+0x38>
   2e454:	e0bffe17 	ldw	r2,-8(fp)
   2e458:	10c00324 	muli	r3,r2,12
   2e45c:	008000f4 	movhi	r2,3
   2e460:	108e3a04 	addi	r2,r2,14568
   2e464:	1885883a 	add	r2,r3,r2
   2e468:	00000106 	br	2e470 <fstat+0x3c>
   2e46c:	0005883a 	mov	r2,zero
   2e470:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   2e474:	e0bffd17 	ldw	r2,-12(fp)
   2e478:	10001026 	beq	r2,zero,2e4bc <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   2e47c:	e0bffd17 	ldw	r2,-12(fp)
   2e480:	10800017 	ldw	r2,0(r2)
   2e484:	10800817 	ldw	r2,32(r2)
   2e488:	10000726 	beq	r2,zero,2e4a8 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   2e48c:	e0bffd17 	ldw	r2,-12(fp)
   2e490:	10800017 	ldw	r2,0(r2)
   2e494:	10800817 	ldw	r2,32(r2)
   2e498:	e17fff17 	ldw	r5,-4(fp)
   2e49c:	e13ffd17 	ldw	r4,-12(fp)
   2e4a0:	103ee83a 	callr	r2
   2e4a4:	00000a06 	br	2e4d0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   2e4a8:	e0bfff17 	ldw	r2,-4(fp)
   2e4ac:	00c80004 	movi	r3,8192
   2e4b0:	10c00115 	stw	r3,4(r2)
      return 0;
   2e4b4:	0005883a 	mov	r2,zero
   2e4b8:	00000506 	br	2e4d0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   2e4bc:	002e3f80 	call	2e3f8 <alt_get_errno>
   2e4c0:	1007883a 	mov	r3,r2
   2e4c4:	00801444 	movi	r2,81
   2e4c8:	18800015 	stw	r2,0(r3)
    return -1;
   2e4cc:	00bfffc4 	movi	r2,-1
  }
}
   2e4d0:	e037883a 	mov	sp,fp
   2e4d4:	dfc00117 	ldw	ra,4(sp)
   2e4d8:	df000017 	ldw	fp,0(sp)
   2e4dc:	dec00204 	addi	sp,sp,8
   2e4e0:	f800283a 	ret

0002e4e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e4e4:	defffe04 	addi	sp,sp,-8
   2e4e8:	dfc00115 	stw	ra,4(sp)
   2e4ec:	df000015 	stw	fp,0(sp)
   2e4f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e4f4:	d0a00f17 	ldw	r2,-32708(gp)
   2e4f8:	10000326 	beq	r2,zero,2e508 <alt_get_errno+0x24>
   2e4fc:	d0a00f17 	ldw	r2,-32708(gp)
   2e500:	103ee83a 	callr	r2
   2e504:	00000106 	br	2e50c <alt_get_errno+0x28>
   2e508:	d0a03604 	addi	r2,gp,-32552
}
   2e50c:	e037883a 	mov	sp,fp
   2e510:	dfc00117 	ldw	ra,4(sp)
   2e514:	df000017 	ldw	fp,0(sp)
   2e518:	dec00204 	addi	sp,sp,8
   2e51c:	f800283a 	ret

0002e520 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   2e520:	deffed04 	addi	sp,sp,-76
   2e524:	dfc01215 	stw	ra,72(sp)
   2e528:	df001115 	stw	fp,68(sp)
   2e52c:	df001104 	addi	fp,sp,68
   2e530:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2e534:	e0bfff17 	ldw	r2,-4(fp)
   2e538:	10000616 	blt	r2,zero,2e554 <isatty+0x34>
   2e53c:	e0bfff17 	ldw	r2,-4(fp)
   2e540:	10c00324 	muli	r3,r2,12
   2e544:	008000f4 	movhi	r2,3
   2e548:	108e3a04 	addi	r2,r2,14568
   2e54c:	1885883a 	add	r2,r3,r2
   2e550:	00000106 	br	2e558 <isatty+0x38>
   2e554:	0005883a 	mov	r2,zero
   2e558:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   2e55c:	e0bfef17 	ldw	r2,-68(fp)
   2e560:	10000e26 	beq	r2,zero,2e59c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   2e564:	e0bfef17 	ldw	r2,-68(fp)
   2e568:	10800017 	ldw	r2,0(r2)
   2e56c:	10800817 	ldw	r2,32(r2)
   2e570:	1000021e 	bne	r2,zero,2e57c <isatty+0x5c>
    {
      return 1;
   2e574:	00800044 	movi	r2,1
   2e578:	00000d06 	br	2e5b0 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   2e57c:	e0bff004 	addi	r2,fp,-64
   2e580:	100b883a 	mov	r5,r2
   2e584:	e13fff17 	ldw	r4,-4(fp)
   2e588:	002e4340 	call	2e434 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   2e58c:	e0bff117 	ldw	r2,-60(fp)
   2e590:	10880020 	cmpeqi	r2,r2,8192
   2e594:	10803fcc 	andi	r2,r2,255
   2e598:	00000506 	br	2e5b0 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   2e59c:	002e4e40 	call	2e4e4 <alt_get_errno>
   2e5a0:	1007883a 	mov	r3,r2
   2e5a4:	00801444 	movi	r2,81
   2e5a8:	18800015 	stw	r2,0(r3)
    return 0;
   2e5ac:	0005883a 	mov	r2,zero
  }
}
   2e5b0:	e037883a 	mov	sp,fp
   2e5b4:	dfc00117 	ldw	ra,4(sp)
   2e5b8:	df000017 	ldw	fp,0(sp)
   2e5bc:	dec00204 	addi	sp,sp,8
   2e5c0:	f800283a 	ret

0002e5c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e5c4:	defffe04 	addi	sp,sp,-8
   2e5c8:	dfc00115 	stw	ra,4(sp)
   2e5cc:	df000015 	stw	fp,0(sp)
   2e5d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e5d4:	d0a00f17 	ldw	r2,-32708(gp)
   2e5d8:	10000326 	beq	r2,zero,2e5e8 <alt_get_errno+0x24>
   2e5dc:	d0a00f17 	ldw	r2,-32708(gp)
   2e5e0:	103ee83a 	callr	r2
   2e5e4:	00000106 	br	2e5ec <alt_get_errno+0x28>
   2e5e8:	d0a03604 	addi	r2,gp,-32552
}
   2e5ec:	e037883a 	mov	sp,fp
   2e5f0:	dfc00117 	ldw	ra,4(sp)
   2e5f4:	df000017 	ldw	fp,0(sp)
   2e5f8:	dec00204 	addi	sp,sp,8
   2e5fc:	f800283a 	ret

0002e600 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   2e600:	defff904 	addi	sp,sp,-28
   2e604:	dfc00615 	stw	ra,24(sp)
   2e608:	df000515 	stw	fp,20(sp)
   2e60c:	df000504 	addi	fp,sp,20
   2e610:	e13ffd15 	stw	r4,-12(fp)
   2e614:	e17ffe15 	stw	r5,-8(fp)
   2e618:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   2e61c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2e620:	e0bffd17 	ldw	r2,-12(fp)
   2e624:	10000616 	blt	r2,zero,2e640 <lseek+0x40>
   2e628:	e0bffd17 	ldw	r2,-12(fp)
   2e62c:	10c00324 	muli	r3,r2,12
   2e630:	008000f4 	movhi	r2,3
   2e634:	108e3a04 	addi	r2,r2,14568
   2e638:	1885883a 	add	r2,r3,r2
   2e63c:	00000106 	br	2e644 <lseek+0x44>
   2e640:	0005883a 	mov	r2,zero
   2e644:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   2e648:	e0bffc17 	ldw	r2,-16(fp)
   2e64c:	10001026 	beq	r2,zero,2e690 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   2e650:	e0bffc17 	ldw	r2,-16(fp)
   2e654:	10800017 	ldw	r2,0(r2)
   2e658:	10800717 	ldw	r2,28(r2)
   2e65c:	10000926 	beq	r2,zero,2e684 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   2e660:	e0bffc17 	ldw	r2,-16(fp)
   2e664:	10800017 	ldw	r2,0(r2)
   2e668:	10800717 	ldw	r2,28(r2)
   2e66c:	e1bfff17 	ldw	r6,-4(fp)
   2e670:	e17ffe17 	ldw	r5,-8(fp)
   2e674:	e13ffc17 	ldw	r4,-16(fp)
   2e678:	103ee83a 	callr	r2
   2e67c:	e0bffb15 	stw	r2,-20(fp)
   2e680:	00000506 	br	2e698 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   2e684:	00bfde84 	movi	r2,-134
   2e688:	e0bffb15 	stw	r2,-20(fp)
   2e68c:	00000206 	br	2e698 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   2e690:	00bfebc4 	movi	r2,-81
   2e694:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   2e698:	e0bffb17 	ldw	r2,-20(fp)
   2e69c:	1000070e 	bge	r2,zero,2e6bc <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
   2e6a0:	002e5c40 	call	2e5c4 <alt_get_errno>
   2e6a4:	1007883a 	mov	r3,r2
   2e6a8:	e0bffb17 	ldw	r2,-20(fp)
   2e6ac:	0085c83a 	sub	r2,zero,r2
   2e6b0:	18800015 	stw	r2,0(r3)
    rc = -1;
   2e6b4:	00bfffc4 	movi	r2,-1
   2e6b8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   2e6bc:	e0bffb17 	ldw	r2,-20(fp)
}
   2e6c0:	e037883a 	mov	sp,fp
   2e6c4:	dfc00117 	ldw	ra,4(sp)
   2e6c8:	df000017 	ldw	fp,0(sp)
   2e6cc:	dec00204 	addi	sp,sp,8
   2e6d0:	f800283a 	ret

0002e6d4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   2e6d4:	defffd04 	addi	sp,sp,-12
   2e6d8:	dfc00215 	stw	ra,8(sp)
   2e6dc:	df000115 	stw	fp,4(sp)
   2e6e0:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   2e6e4:	0009883a 	mov	r4,zero
   2e6e8:	002ebf00 	call	2ebf0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   2e6ec:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   2e6f0:	002ec280 	call	2ec28 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   2e6f4:	018000f4 	movhi	r6,3
   2e6f8:	318bf104 	addi	r6,r6,12228
   2e6fc:	014000f4 	movhi	r5,3
   2e700:	294bf104 	addi	r5,r5,12228
   2e704:	010000f4 	movhi	r4,3
   2e708:	210bf104 	addi	r4,r4,12228
   2e70c:	0031f900 	call	31f90 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   2e710:	0031cc00 	call	31cc0 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   2e714:	010000f4 	movhi	r4,3
   2e718:	21074804 	addi	r4,r4,7456
   2e71c:	00325d40 	call	325d4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   2e720:	d0a03817 	ldw	r2,-32544(gp)
   2e724:	d0e03917 	ldw	r3,-32540(gp)
   2e728:	d1203a17 	ldw	r4,-32536(gp)
   2e72c:	200d883a 	mov	r6,r4
   2e730:	180b883a 	mov	r5,r3
   2e734:	1009883a 	mov	r4,r2
   2e738:	002724c0 	call	2724c <main>
   2e73c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   2e740:	01000044 	movi	r4,1
   2e744:	002e2fc0 	call	2e2fc <close>
  exit (result);
   2e748:	e13fff17 	ldw	r4,-4(fp)
   2e74c:	00325e80 	call	325e8 <exit>

0002e750 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
   2e750:	defffe04 	addi	sp,sp,-8
   2e754:	df000115 	stw	fp,4(sp)
   2e758:	df000104 	addi	fp,sp,4
   2e75c:	e13fff15 	stw	r4,-4(fp)
}
   2e760:	0001883a 	nop
   2e764:	e037883a 	mov	sp,fp
   2e768:	df000017 	ldw	fp,0(sp)
   2e76c:	dec00104 	addi	sp,sp,4
   2e770:	f800283a 	ret

0002e774 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
   2e774:	defffe04 	addi	sp,sp,-8
   2e778:	df000115 	stw	fp,4(sp)
   2e77c:	df000104 	addi	fp,sp,4
   2e780:	e13fff15 	stw	r4,-4(fp)
}
   2e784:	0001883a 	nop
   2e788:	e037883a 	mov	sp,fp
   2e78c:	df000017 	ldw	fp,0(sp)
   2e790:	dec00104 	addi	sp,sp,4
   2e794:	f800283a 	ret

0002e798 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e798:	defffe04 	addi	sp,sp,-8
   2e79c:	dfc00115 	stw	ra,4(sp)
   2e7a0:	df000015 	stw	fp,0(sp)
   2e7a4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e7a8:	d0a00f17 	ldw	r2,-32708(gp)
   2e7ac:	10000326 	beq	r2,zero,2e7bc <alt_get_errno+0x24>
   2e7b0:	d0a00f17 	ldw	r2,-32708(gp)
   2e7b4:	103ee83a 	callr	r2
   2e7b8:	00000106 	br	2e7c0 <alt_get_errno+0x28>
   2e7bc:	d0a03604 	addi	r2,gp,-32552
}
   2e7c0:	e037883a 	mov	sp,fp
   2e7c4:	dfc00117 	ldw	ra,4(sp)
   2e7c8:	df000017 	ldw	fp,0(sp)
   2e7cc:	dec00204 	addi	sp,sp,8
   2e7d0:	f800283a 	ret

0002e7d4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   2e7d4:	defff904 	addi	sp,sp,-28
   2e7d8:	dfc00615 	stw	ra,24(sp)
   2e7dc:	df000515 	stw	fp,20(sp)
   2e7e0:	df000504 	addi	fp,sp,20
   2e7e4:	e13ffd15 	stw	r4,-12(fp)
   2e7e8:	e17ffe15 	stw	r5,-8(fp)
   2e7ec:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2e7f0:	e0bffd17 	ldw	r2,-12(fp)
   2e7f4:	10000616 	blt	r2,zero,2e810 <read+0x3c>
   2e7f8:	e0bffd17 	ldw	r2,-12(fp)
   2e7fc:	10c00324 	muli	r3,r2,12
   2e800:	008000f4 	movhi	r2,3
   2e804:	108e3a04 	addi	r2,r2,14568
   2e808:	1885883a 	add	r2,r3,r2
   2e80c:	00000106 	br	2e814 <read+0x40>
   2e810:	0005883a 	mov	r2,zero
   2e814:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   2e818:	e0bffb17 	ldw	r2,-20(fp)
   2e81c:	10002226 	beq	r2,zero,2e8a8 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   2e820:	e0bffb17 	ldw	r2,-20(fp)
   2e824:	10800217 	ldw	r2,8(r2)
   2e828:	108000cc 	andi	r2,r2,3
   2e82c:	10800060 	cmpeqi	r2,r2,1
   2e830:	1000181e 	bne	r2,zero,2e894 <read+0xc0>
        (fd->dev->read))
   2e834:	e0bffb17 	ldw	r2,-20(fp)
   2e838:	10800017 	ldw	r2,0(r2)
   2e83c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   2e840:	10001426 	beq	r2,zero,2e894 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   2e844:	e0bffb17 	ldw	r2,-20(fp)
   2e848:	10800017 	ldw	r2,0(r2)
   2e84c:	10800517 	ldw	r2,20(r2)
   2e850:	e0ffff17 	ldw	r3,-4(fp)
   2e854:	180d883a 	mov	r6,r3
   2e858:	e17ffe17 	ldw	r5,-8(fp)
   2e85c:	e13ffb17 	ldw	r4,-20(fp)
   2e860:	103ee83a 	callr	r2
   2e864:	e0bffc15 	stw	r2,-16(fp)
   2e868:	e0bffc17 	ldw	r2,-16(fp)
   2e86c:	1000070e 	bge	r2,zero,2e88c <read+0xb8>
        {
          ALT_ERRNO = -rval;
   2e870:	002e7980 	call	2e798 <alt_get_errno>
   2e874:	1007883a 	mov	r3,r2
   2e878:	e0bffc17 	ldw	r2,-16(fp)
   2e87c:	0085c83a 	sub	r2,zero,r2
   2e880:	18800015 	stw	r2,0(r3)
          return -1;
   2e884:	00bfffc4 	movi	r2,-1
   2e888:	00000c06 	br	2e8bc <read+0xe8>
        }
        return rval;
   2e88c:	e0bffc17 	ldw	r2,-16(fp)
   2e890:	00000a06 	br	2e8bc <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
   2e894:	002e7980 	call	2e798 <alt_get_errno>
   2e898:	1007883a 	mov	r3,r2
   2e89c:	00800344 	movi	r2,13
   2e8a0:	18800015 	stw	r2,0(r3)
   2e8a4:	00000406 	br	2e8b8 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   2e8a8:	002e7980 	call	2e798 <alt_get_errno>
   2e8ac:	1007883a 	mov	r3,r2
   2e8b0:	00801444 	movi	r2,81
   2e8b4:	18800015 	stw	r2,0(r3)
  }
  return -1;
   2e8b8:	00bfffc4 	movi	r2,-1
}
   2e8bc:	e037883a 	mov	sp,fp
   2e8c0:	dfc00117 	ldw	ra,4(sp)
   2e8c4:	df000017 	ldw	fp,0(sp)
   2e8c8:	dec00204 	addi	sp,sp,8
   2e8cc:	f800283a 	ret

0002e8d0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   2e8d0:	defffe04 	addi	sp,sp,-8
   2e8d4:	df000115 	stw	fp,4(sp)
   2e8d8:	df000104 	addi	fp,sp,4
   2e8dc:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   2e8e0:	e0bfff17 	ldw	r2,-4(fp)
   2e8e4:	108000d0 	cmplti	r2,r2,3
   2e8e8:	10000d1e 	bne	r2,zero,2e920 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   2e8ec:	008000f4 	movhi	r2,3
   2e8f0:	108e3a04 	addi	r2,r2,14568
   2e8f4:	e0ffff17 	ldw	r3,-4(fp)
   2e8f8:	18c00324 	muli	r3,r3,12
   2e8fc:	10c5883a 	add	r2,r2,r3
   2e900:	10800204 	addi	r2,r2,8
   2e904:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   2e908:	008000f4 	movhi	r2,3
   2e90c:	108e3a04 	addi	r2,r2,14568
   2e910:	e0ffff17 	ldw	r3,-4(fp)
   2e914:	18c00324 	muli	r3,r3,12
   2e918:	10c5883a 	add	r2,r2,r3
   2e91c:	10000015 	stw	zero,0(r2)
  }
}
   2e920:	0001883a 	nop
   2e924:	e037883a 	mov	sp,fp
   2e928:	df000017 	ldw	fp,0(sp)
   2e92c:	dec00104 	addi	sp,sp,4
   2e930:	f800283a 	ret

0002e934 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   2e934:	defff904 	addi	sp,sp,-28
   2e938:	df000615 	stw	fp,24(sp)
   2e93c:	df000604 	addi	fp,sp,24
   2e940:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2e944:	0005303a 	rdctl	r2,status
   2e948:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2e94c:	e0fffe17 	ldw	r3,-8(fp)
   2e950:	00bfff84 	movi	r2,-2
   2e954:	1884703a 	and	r2,r3,r2
   2e958:	1001703a 	wrctl	status,r2
  
  return context;
   2e95c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   2e960:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   2e964:	d0a01117 	ldw	r2,-32700(gp)
   2e968:	10c000c4 	addi	r3,r2,3
   2e96c:	00bfff04 	movi	r2,-4
   2e970:	1884703a 	and	r2,r3,r2
   2e974:	d0a01115 	stw	r2,-32700(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   2e978:	d0e01117 	ldw	r3,-32700(gp)
   2e97c:	e0bfff17 	ldw	r2,-4(fp)
   2e980:	1887883a 	add	r3,r3,r2
   2e984:	00800134 	movhi	r2,4
   2e988:	10800004 	addi	r2,r2,0
   2e98c:	10c0062e 	bgeu	r2,r3,2e9a8 <sbrk+0x74>
   2e990:	e0bffb17 	ldw	r2,-20(fp)
   2e994:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   2e998:	e0bffa17 	ldw	r2,-24(fp)
   2e99c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   2e9a0:	00bfffc4 	movi	r2,-1
   2e9a4:	00000b06 	br	2e9d4 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
   2e9a8:	d0a01117 	ldw	r2,-32700(gp)
   2e9ac:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
   2e9b0:	d0e01117 	ldw	r3,-32700(gp)
   2e9b4:	e0bfff17 	ldw	r2,-4(fp)
   2e9b8:	1885883a 	add	r2,r3,r2
   2e9bc:	d0a01115 	stw	r2,-32700(gp)
   2e9c0:	e0bffb17 	ldw	r2,-20(fp)
   2e9c4:	e0bffc15 	stw	r2,-16(fp)
   2e9c8:	e0bffc17 	ldw	r2,-16(fp)
   2e9cc:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   2e9d0:	e0bffd17 	ldw	r2,-12(fp)
} 
   2e9d4:	e037883a 	mov	sp,fp
   2e9d8:	df000017 	ldw	fp,0(sp)
   2e9dc:	dec00104 	addi	sp,sp,4
   2e9e0:	f800283a 	ret

0002e9e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2e9e4:	defffe04 	addi	sp,sp,-8
   2e9e8:	dfc00115 	stw	ra,4(sp)
   2e9ec:	df000015 	stw	fp,0(sp)
   2e9f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2e9f4:	d0a00f17 	ldw	r2,-32708(gp)
   2e9f8:	10000326 	beq	r2,zero,2ea08 <alt_get_errno+0x24>
   2e9fc:	d0a00f17 	ldw	r2,-32708(gp)
   2ea00:	103ee83a 	callr	r2
   2ea04:	00000106 	br	2ea0c <alt_get_errno+0x28>
   2ea08:	d0a03604 	addi	r2,gp,-32552
}
   2ea0c:	e037883a 	mov	sp,fp
   2ea10:	dfc00117 	ldw	ra,4(sp)
   2ea14:	df000017 	ldw	fp,0(sp)
   2ea18:	dec00204 	addi	sp,sp,8
   2ea1c:	f800283a 	ret

0002ea20 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   2ea20:	defff904 	addi	sp,sp,-28
   2ea24:	dfc00615 	stw	ra,24(sp)
   2ea28:	df000515 	stw	fp,20(sp)
   2ea2c:	df000504 	addi	fp,sp,20
   2ea30:	e13ffd15 	stw	r4,-12(fp)
   2ea34:	e17ffe15 	stw	r5,-8(fp)
   2ea38:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2ea3c:	e0bffd17 	ldw	r2,-12(fp)
   2ea40:	10000616 	blt	r2,zero,2ea5c <write+0x3c>
   2ea44:	e0bffd17 	ldw	r2,-12(fp)
   2ea48:	10c00324 	muli	r3,r2,12
   2ea4c:	008000f4 	movhi	r2,3
   2ea50:	108e3a04 	addi	r2,r2,14568
   2ea54:	1885883a 	add	r2,r3,r2
   2ea58:	00000106 	br	2ea60 <write+0x40>
   2ea5c:	0005883a 	mov	r2,zero
   2ea60:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   2ea64:	e0bffb17 	ldw	r2,-20(fp)
   2ea68:	10002126 	beq	r2,zero,2eaf0 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   2ea6c:	e0bffb17 	ldw	r2,-20(fp)
   2ea70:	10800217 	ldw	r2,8(r2)
   2ea74:	108000cc 	andi	r2,r2,3
   2ea78:	10001826 	beq	r2,zero,2eadc <write+0xbc>
   2ea7c:	e0bffb17 	ldw	r2,-20(fp)
   2ea80:	10800017 	ldw	r2,0(r2)
   2ea84:	10800617 	ldw	r2,24(r2)
   2ea88:	10001426 	beq	r2,zero,2eadc <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   2ea8c:	e0bffb17 	ldw	r2,-20(fp)
   2ea90:	10800017 	ldw	r2,0(r2)
   2ea94:	10800617 	ldw	r2,24(r2)
   2ea98:	e0ffff17 	ldw	r3,-4(fp)
   2ea9c:	180d883a 	mov	r6,r3
   2eaa0:	e17ffe17 	ldw	r5,-8(fp)
   2eaa4:	e13ffb17 	ldw	r4,-20(fp)
   2eaa8:	103ee83a 	callr	r2
   2eaac:	e0bffc15 	stw	r2,-16(fp)
   2eab0:	e0bffc17 	ldw	r2,-16(fp)
   2eab4:	1000070e 	bge	r2,zero,2ead4 <write+0xb4>
      {
        ALT_ERRNO = -rval;
   2eab8:	002e9e40 	call	2e9e4 <alt_get_errno>
   2eabc:	1007883a 	mov	r3,r2
   2eac0:	e0bffc17 	ldw	r2,-16(fp)
   2eac4:	0085c83a 	sub	r2,zero,r2
   2eac8:	18800015 	stw	r2,0(r3)
        return -1;
   2eacc:	00bfffc4 	movi	r2,-1
   2ead0:	00000c06 	br	2eb04 <write+0xe4>
      }
      return rval;
   2ead4:	e0bffc17 	ldw	r2,-16(fp)
   2ead8:	00000a06 	br	2eb04 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
   2eadc:	002e9e40 	call	2e9e4 <alt_get_errno>
   2eae0:	1007883a 	mov	r3,r2
   2eae4:	00800344 	movi	r2,13
   2eae8:	18800015 	stw	r2,0(r3)
   2eaec:	00000406 	br	2eb00 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   2eaf0:	002e9e40 	call	2e9e4 <alt_get_errno>
   2eaf4:	1007883a 	mov	r3,r2
   2eaf8:	00801444 	movi	r2,81
   2eafc:	18800015 	stw	r2,0(r3)
  }
  return -1;
   2eb00:	00bfffc4 	movi	r2,-1
}
   2eb04:	e037883a 	mov	sp,fp
   2eb08:	dfc00117 	ldw	ra,4(sp)
   2eb0c:	df000017 	ldw	fp,0(sp)
   2eb10:	dec00204 	addi	sp,sp,8
   2eb14:	f800283a 	ret

0002eb18 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   2eb18:	defffd04 	addi	sp,sp,-12
   2eb1c:	dfc00215 	stw	ra,8(sp)
   2eb20:	df000115 	stw	fp,4(sp)
   2eb24:	df000104 	addi	fp,sp,4
   2eb28:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   2eb2c:	d1600c04 	addi	r5,gp,-32720
   2eb30:	e13fff17 	ldw	r4,-4(fp)
   2eb34:	0031c1c0 	call	31c1c <alt_dev_llist_insert>
}
   2eb38:	e037883a 	mov	sp,fp
   2eb3c:	dfc00117 	ldw	ra,4(sp)
   2eb40:	df000017 	ldw	fp,0(sp)
   2eb44:	dec00204 	addi	sp,sp,8
   2eb48:	f800283a 	ret

0002eb4c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2eb4c:	defffe04 	addi	sp,sp,-8
   2eb50:	dfc00115 	stw	ra,4(sp)
   2eb54:	df000015 	stw	fp,0(sp)
   2eb58:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2eb5c:	d0a00f17 	ldw	r2,-32708(gp)
   2eb60:	10000326 	beq	r2,zero,2eb70 <alt_get_errno+0x24>
   2eb64:	d0a00f17 	ldw	r2,-32708(gp)
   2eb68:	103ee83a 	callr	r2
   2eb6c:	00000106 	br	2eb74 <alt_get_errno+0x28>
   2eb70:	d0a03604 	addi	r2,gp,-32552
}
   2eb74:	e037883a 	mov	sp,fp
   2eb78:	dfc00117 	ldw	ra,4(sp)
   2eb7c:	df000017 	ldw	fp,0(sp)
   2eb80:	dec00204 	addi	sp,sp,8
   2eb84:	f800283a 	ret

0002eb88 <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
   2eb88:	defffc04 	addi	sp,sp,-16
   2eb8c:	dfc00315 	stw	ra,12(sp)
   2eb90:	df000215 	stw	fp,8(sp)
   2eb94:	df000204 	addi	fp,sp,8
   2eb98:	e13fff15 	stw	r4,-4(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   2eb9c:	0005883a 	mov	r2,zero
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
   2eba0:	e0bffe15 	stw	r2,-8(fp)
  if (!ret_code)
   2eba4:	e0bffe17 	ldw	r2,-8(fp)
   2eba8:	1000051e 	bne	r2,zero,2ebc0 <alt_avalon_mutex_reg+0x38>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
   2ebac:	d1601404 	addi	r5,gp,-32688
   2ebb0:	e13fff17 	ldw	r4,-4(fp)
   2ebb4:	0031c1c0 	call	31c1c <alt_dev_llist_insert>
   2ebb8:	e0bffe15 	stw	r2,-8(fp)
   2ebbc:	00000606 	br	2ebd8 <alt_avalon_mutex_reg+0x50>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
   2ebc0:	002eb4c0 	call	2eb4c <alt_get_errno>
   2ebc4:	1007883a 	mov	r3,r2
   2ebc8:	00800304 	movi	r2,12
   2ebcc:	18800015 	stw	r2,0(r3)
    ret_code = -ENOMEM;
   2ebd0:	00bffd04 	movi	r2,-12
   2ebd4:	e0bffe15 	stw	r2,-8(fp)
  }

  return ret_code;
   2ebd8:	e0bffe17 	ldw	r2,-8(fp)
}
   2ebdc:	e037883a 	mov	sp,fp
   2ebe0:	dfc00117 	ldw	ra,4(sp)
   2ebe4:	df000017 	ldw	fp,0(sp)
   2ebe8:	dec00204 	addi	sp,sp,8
   2ebec:	f800283a 	ret

0002ebf0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   2ebf0:	defffd04 	addi	sp,sp,-12
   2ebf4:	dfc00215 	stw	ra,8(sp)
   2ebf8:	df000115 	stw	fp,4(sp)
   2ebfc:	df000104 	addi	fp,sp,4
   2ec00:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
   2ec04:	00324040 	call	32404 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   2ec08:	00800044 	movi	r2,1
   2ec0c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   2ec10:	0001883a 	nop
   2ec14:	e037883a 	mov	sp,fp
   2ec18:	dfc00117 	ldw	ra,4(sp)
   2ec1c:	df000017 	ldw	fp,0(sp)
   2ec20:	dec00204 	addi	sp,sp,8
   2ec24:	f800283a 	ret

0002ec28 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   2ec28:	defffe04 	addi	sp,sp,-8
   2ec2c:	dfc00115 	stw	ra,4(sp)
   2ec30:	df000015 	stw	fp,0(sp)
   2ec34:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0_NIOS2, timer_0_nios2);
   2ec38:	01c0fa04 	movi	r7,1000
   2ec3c:	01800084 	movi	r6,2
   2ec40:	000b883a 	mov	r5,zero
   2ec44:	0009883a 	mov	r4,zero
   2ec48:	00311940 	call	31194 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH_CONTROLLER_0, epcs_flash_controller_0);
   2ec4c:	010000f4 	movhi	r4,3
   2ec50:	210e9a04 	addi	r4,r4,14952
   2ec54:	002edf00 	call	2edf0 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_NIOS2, jtag_uart_nios2);
   2ec58:	000d883a 	mov	r6,zero
   2ec5c:	000b883a 	mov	r5,zero
   2ec60:	010000f4 	movhi	r4,3
   2ec64:	210ed704 	addi	r4,r4,15196
   2ec68:	002fa1c0 	call	2fa1c <altera_avalon_jtag_uart_init>
   2ec6c:	010000f4 	movhi	r4,3
   2ec70:	210ecd04 	addi	r4,r4,15156
   2ec74:	002eb180 	call	2eb18 <alt_dev_reg>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_ARM2NIOS_0, mailbox_arm2nios_0);
   2ec78:	018000c4 	movi	r6,3
   2ec7c:	000b883a 	mov	r5,zero
   2ec80:	010000f4 	movhi	r4,3
   2ec84:	2112e504 	addi	r4,r4,19348
   2ec88:	00306080 	call	30608 <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_NIOS2ARM_0, mailbox_nios2arm_0);
   2ec8c:	01bfffc4 	movi	r6,-1
   2ec90:	000b883a 	mov	r5,zero
   2ec94:	010000f4 	movhi	r4,3
   2ec98:	2112f704 	addi	r4,r4,19420
   2ec9c:	00306080 	call	30608 <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_MUTEX_INIT ( SHARED_MEMORY_MUTEX_MASTER_HPS_0, shared_memory_mutex_master_hps_0);
   2eca0:	010000f4 	movhi	r4,3
   2eca4:	21130904 	addi	r4,r4,19492
   2eca8:	002eb880 	call	2eb88 <alt_avalon_mutex_reg>
    ALTERA_AVALON_MUTEX_INIT ( SHARED_MEMORY_MUTEX_MASTER_NIOS_0, shared_memory_mutex_master_nios_0);
   2ecac:	010000f4 	movhi	r4,3
   2ecb0:	21130d04 	addi	r4,r4,19508
   2ecb4:	002eb880 	call	2eb88 <alt_avalon_mutex_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
   2ecb8:	0001883a 	nop
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_FPGA, sysid_fpga);
   2ecbc:	0001883a 	nop
    I2C_OPENCORES_INIT ( I2C_OPENCORES_0, i2c_opencores_0);
   2ecc0:	0001883a 	nop
}
   2ecc4:	0001883a 	nop
   2ecc8:	e037883a 	mov	sp,fp
   2eccc:	dfc00117 	ldw	ra,4(sp)
   2ecd0:	df000017 	ldw	fp,0(sp)
   2ecd4:	dec00204 	addi	sp,sp,8
   2ecd8:	f800283a 	ret

0002ecdc <PWMGen_Set_DutyCycle>:
#include "PWM_Generator.h"
#include "PWM_Generator_regs.h"

void PWMGen_Set_DutyCycle(alt_u32 base, PWMGen_DutyCycle_Width dutycycle){
   2ecdc:	defffd04 	addi	sp,sp,-12
   2ece0:	df000215 	stw	fp,8(sp)
   2ece4:	df000204 	addi	fp,sp,8
   2ece8:	e13ffe15 	stw	r4,-8(fp)
   2ecec:	e17fff15 	stw	r5,-4(fp)
    IOWR_PWMGen_Control(base, dutycycle);
   2ecf0:	e0bffe17 	ldw	r2,-8(fp)
   2ecf4:	e0ffff17 	ldw	r3,-4(fp)
   2ecf8:	10c00035 	stwio	r3,0(r2)
}
   2ecfc:	0001883a 	nop
   2ed00:	e037883a 	mov	sp,fp
   2ed04:	df000017 	ldw	fp,0(sp)
   2ed08:	dec00104 	addi	sp,sp,4
   2ed0c:	f800283a 	ret

0002ed10 <ROT_ENC_GetRotations>:
 * @file
 */

#include "Rotary_Encoder.h"

uint32_t ROT_ENC_GetRotations(uint32_t base){
   2ed10:	defffe04 	addi	sp,sp,-8
   2ed14:	df000115 	stw	fp,4(sp)
   2ed18:	df000104 	addi	fp,sp,4
   2ed1c:	e13fff15 	stw	r4,-4(fp)
    return Read_ROTARY_ENCODER_RESULT(base);
   2ed20:	e0bfff17 	ldw	r2,-4(fp)
   2ed24:	10800104 	addi	r2,r2,4
   2ed28:	10800037 	ldwio	r2,0(r2)
}
   2ed2c:	e037883a 	mov	sp,fp
   2ed30:	df000017 	ldw	fp,0(sp)
   2ed34:	dec00104 	addi	sp,sp,4
   2ed38:	f800283a 	ret

0002ed3c <ROT_ENC_SetNewStatus>:

void ROT_ENC_SetNewStatus(uint32_t base, uint8_t status){
   2ed3c:	defffd04 	addi	sp,sp,-12
   2ed40:	df000215 	stw	fp,8(sp)
   2ed44:	df000204 	addi	fp,sp,8
   2ed48:	e13ffe15 	stw	r4,-8(fp)
   2ed4c:	2805883a 	mov	r2,r5
   2ed50:	e0bfff05 	stb	r2,-4(fp)
	Write_ROTARY_ENCODER_CONTROL(base, status << ROTARY_ENCODER_BIT_ENABLE);
   2ed54:	e0bffe17 	ldw	r2,-8(fp)
   2ed58:	e0ffff03 	ldbu	r3,-4(fp)
   2ed5c:	10c00035 	stwio	r3,0(r2)
}
   2ed60:	0001883a 	nop
   2ed64:	e037883a 	mov	sp,fp
   2ed68:	df000017 	ldw	fp,0(sp)
   2ed6c:	dec00104 	addi	sp,sp,4
   2ed70:	f800283a 	ret

0002ed74 <ROT_ENC_ClearCounter>:

void ROT_ENC_ClearCounter(uint32_t base){
   2ed74:	defffd04 	addi	sp,sp,-12
   2ed78:	df000215 	stw	fp,8(sp)
   2ed7c:	df000204 	addi	fp,sp,8
   2ed80:	e13fff15 	stw	r4,-4(fp)
    volatile uint32_t reg = Read_ROTARY_ENCODER_CONTROL(base);
   2ed84:	e0bfff17 	ldw	r2,-4(fp)
   2ed88:	10800037 	ldwio	r2,0(r2)
   2ed8c:	e0bffe15 	stw	r2,-8(fp)
    reg |= (1 << ROTARY_ENCODER_BIT_CLEARCOUNTER);
   2ed90:	e0bffe17 	ldw	r2,-8(fp)
   2ed94:	10800094 	ori	r2,r2,2
   2ed98:	e0bffe15 	stw	r2,-8(fp)
    Write_ROTARY_ENCODER_CONTROL(base,reg);
   2ed9c:	e0bfff17 	ldw	r2,-4(fp)
   2eda0:	e0fffe17 	ldw	r3,-8(fp)
   2eda4:	10c00035 	stwio	r3,0(r2)
}
   2eda8:	0001883a 	nop
   2edac:	e037883a 	mov	sp,fp
   2edb0:	df000017 	ldw	fp,0(sp)
   2edb4:	dec00104 	addi	sp,sp,4
   2edb8:	f800283a 	ret

0002edbc <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
   2edbc:	defffd04 	addi	sp,sp,-12
   2edc0:	dfc00215 	stw	ra,8(sp)
   2edc4:	df000115 	stw	fp,4(sp)
   2edc8:	df000104 	addi	fp,sp,4
   2edcc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
   2edd0:	d1601604 	addi	r5,gp,-32680
   2edd4:	e13fff17 	ldw	r4,-4(fp)
   2edd8:	0031c1c0 	call	31c1c <alt_dev_llist_insert>
}
   2eddc:	e037883a 	mov	sp,fp
   2ede0:	dfc00117 	ldw	ra,4(sp)
   2ede4:	df000017 	ldw	fp,0(sp)
   2ede8:	dec00204 	addi	sp,sp,8
   2edec:	f800283a 	ret

0002edf0 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
   2edf0:	defffc04 	addi	sp,sp,-16
   2edf4:	dfc00315 	stw	ra,12(sp)
   2edf8:	df000215 	stw	fp,8(sp)
   2edfc:	df000204 	addi	fp,sp,8
   2ee00:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   2ee04:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
   2ee08:	e13fff17 	ldw	r4,-4(fp)
   2ee0c:	002ee440 	call	2ee44 <alt_epcs_flash_query>
   2ee10:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
   2ee14:	e0bffe17 	ldw	r2,-8(fp)
   2ee18:	1000041e 	bne	r2,zero,2ee2c <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
   2ee1c:	e0bfff17 	ldw	r2,-4(fp)
   2ee20:	1009883a 	mov	r4,r2
   2ee24:	002edbc0 	call	2edbc <alt_flash_device_register>
   2ee28:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
   2ee2c:	e0bffe17 	ldw	r2,-8(fp)
}
   2ee30:	e037883a 	mov	sp,fp
   2ee34:	dfc00117 	ldw	ra,4(sp)
   2ee38:	df000017 	ldw	fp,0(sp)
   2ee3c:	dec00204 	addi	sp,sp,8
   2ee40:	f800283a 	ret

0002ee44 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
   2ee44:	defffc04 	addi	sp,sp,-16
   2ee48:	dfc00315 	stw	ra,12(sp)
   2ee4c:	df000215 	stw	fp,8(sp)
   2ee50:	df000204 	addi	fp,sp,8
   2ee54:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   2ee58:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
   2ee5c:	e0bfff17 	ldw	r2,-4(fp)
   2ee60:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
   2ee64:	e0bfff17 	ldw	r2,-4(fp)
   2ee68:	10802e17 	ldw	r2,184(r2)
   2ee6c:	1009883a 	mov	r4,r2
   2ee70:	00316a40 	call	316a4 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
   2ee74:	10c03fcc 	andi	r3,r2,255
   2ee78:	e0bfff17 	ldw	r2,-4(fp)
   2ee7c:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
   2ee80:	e0bfff17 	ldw	r2,-4(fp)
   2ee84:	10803017 	ldw	r2,192(r2)
   2ee88:	10800598 	cmpnei	r2,r2,22
   2ee8c:	10000a1e 	bne	r2,zero,2eeb8 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
   2ee90:	e0bfff17 	ldw	r2,-4(fp)
   2ee94:	00c02034 	movhi	r3,128
   2ee98:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
   2ee9c:	e0bfff17 	ldw	r2,-4(fp)
   2eea0:	00c02004 	movi	r3,128
   2eea4:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   2eea8:	e0bfff17 	ldw	r2,-4(fp)
   2eeac:	00c00074 	movhi	r3,1
   2eeb0:	10c01015 	stw	r3,64(r2)
   2eeb4:	0000ce06 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
   2eeb8:	e0bfff17 	ldw	r2,-4(fp)
   2eebc:	10803017 	ldw	r2,192(r2)
   2eec0:	10800518 	cmpnei	r2,r2,20
   2eec4:	10000a1e 	bne	r2,zero,2eef0 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
   2eec8:	e0bfff17 	ldw	r2,-4(fp)
   2eecc:	00c00834 	movhi	r3,32
   2eed0:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
   2eed4:	e0bfff17 	ldw	r2,-4(fp)
   2eed8:	00c00804 	movi	r3,32
   2eedc:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   2eee0:	e0bfff17 	ldw	r2,-4(fp)
   2eee4:	00c00074 	movhi	r3,1
   2eee8:	10c01015 	stw	r3,64(r2)
   2eeec:	0000c006 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
   2eef0:	e0bfff17 	ldw	r2,-4(fp)
   2eef4:	10803017 	ldw	r2,192(r2)
   2eef8:	108004d8 	cmpnei	r2,r2,19
   2eefc:	10000a1e 	bne	r2,zero,2ef28 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
   2ef00:	e0bfff17 	ldw	r2,-4(fp)
   2ef04:	00c00434 	movhi	r3,16
   2ef08:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
   2ef0c:	e0bfff17 	ldw	r2,-4(fp)
   2ef10:	00c00404 	movi	r3,16
   2ef14:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   2ef18:	e0bfff17 	ldw	r2,-4(fp)
   2ef1c:	00c00074 	movhi	r3,1
   2ef20:	10c01015 	stw	r3,64(r2)
   2ef24:	0000b206 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
   2ef28:	e0bfff17 	ldw	r2,-4(fp)
   2ef2c:	10803017 	ldw	r2,192(r2)
   2ef30:	10800498 	cmpnei	r2,r2,18
   2ef34:	10000a1e 	bne	r2,zero,2ef60 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
   2ef38:	e0bfff17 	ldw	r2,-4(fp)
   2ef3c:	00c00234 	movhi	r3,8
   2ef40:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
   2ef44:	e0bfff17 	ldw	r2,-4(fp)
   2ef48:	00c00204 	movi	r3,8
   2ef4c:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
   2ef50:	e0bfff17 	ldw	r2,-4(fp)
   2ef54:	00c00074 	movhi	r3,1
   2ef58:	10c01015 	stw	r3,64(r2)
   2ef5c:	0000a406 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
   2ef60:	e0bfff17 	ldw	r2,-4(fp)
   2ef64:	10803017 	ldw	r2,192(r2)
   2ef68:	10800418 	cmpnei	r2,r2,16
   2ef6c:	10000a1e 	bne	r2,zero,2ef98 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
   2ef70:	e0bfff17 	ldw	r2,-4(fp)
   2ef74:	00c000b4 	movhi	r3,2
   2ef78:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
   2ef7c:	e0bfff17 	ldw	r2,-4(fp)
   2ef80:	00c00104 	movi	r3,4
   2ef84:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
   2ef88:	e0bfff17 	ldw	r2,-4(fp)
   2ef8c:	00e00014 	movui	r3,32768
   2ef90:	10c01015 	stw	r3,64(r2)
   2ef94:	00009606 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
   2ef98:	e0bfff17 	ldw	r2,-4(fp)
   2ef9c:	10802e17 	ldw	r2,184(r2)
   2efa0:	1009883a 	mov	r4,r2
   2efa4:	003170c0 	call	3170c <epcs_read_device_id>
   2efa8:	1007883a 	mov	r3,r2
   2efac:	e0bfff17 	ldw	r2,-4(fp)
   2efb0:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
   2efb4:	e0bfff17 	ldw	r2,-4(fp)
   2efb8:	10c03017 	ldw	r3,192(r2)
   2efbc:	00804034 	movhi	r2,256
   2efc0:	10bfffc4 	addi	r2,r2,-1
   2efc4:	1886703a 	and	r3,r3,r2
   2efc8:	00800874 	movhi	r2,33
   2efcc:	10ae8544 	addi	r2,r2,-17899
   2efd0:	18800a1e 	bne	r3,r2,2effc <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
   2efd4:	e0bfff17 	ldw	r2,-4(fp)
   2efd8:	00c00834 	movhi	r3,32
   2efdc:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
   2efe0:	e0bfff17 	ldw	r2,-4(fp)
   2efe4:	00c00804 	movi	r3,32
   2efe8:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2efec:	e0bfff17 	ldw	r2,-4(fp)
   2eff0:	00c00074 	movhi	r3,1
   2eff4:	10c01015 	stw	r3,64(r2)
   2eff8:	00007d06 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
   2effc:	e0bfff17 	ldw	r2,-4(fp)
   2f000:	10c03017 	ldw	r3,192(r2)
   2f004:	00804034 	movhi	r2,256
   2f008:	10bfffc4 	addi	r2,r2,-1
   2f00c:	1886703a 	and	r3,r3,r2
   2f010:	00800874 	movhi	r2,33
   2f014:	10ae8584 	addi	r2,r2,-17898
   2f018:	18800a1e 	bne	r3,r2,2f044 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
   2f01c:	e0bfff17 	ldw	r2,-4(fp)
   2f020:	00c01034 	movhi	r3,64
   2f024:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
   2f028:	e0bfff17 	ldw	r2,-4(fp)
   2f02c:	00c01004 	movi	r3,64
   2f030:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f034:	e0bfff17 	ldw	r2,-4(fp)
   2f038:	00c00074 	movhi	r3,1
   2f03c:	10c01015 	stw	r3,64(r2)
   2f040:	00006b06 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
   2f044:	e0bfff17 	ldw	r2,-4(fp)
   2f048:	10c03017 	ldw	r3,192(r2)
   2f04c:	00804034 	movhi	r2,256
   2f050:	10bfffc4 	addi	r2,r2,-1
   2f054:	1886703a 	and	r3,r3,r2
   2f058:	00800874 	movhi	r2,33
   2f05c:	10ae85c4 	addi	r2,r2,-17897
   2f060:	18800a1e 	bne	r3,r2,2f08c <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
   2f064:	e0bfff17 	ldw	r2,-4(fp)
   2f068:	00c02034 	movhi	r3,128
   2f06c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
   2f070:	e0bfff17 	ldw	r2,-4(fp)
   2f074:	00c02004 	movi	r3,128
   2f078:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f07c:	e0bfff17 	ldw	r2,-4(fp)
   2f080:	00c00074 	movhi	r3,1
   2f084:	10c01015 	stw	r3,64(r2)
   2f088:	00005906 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
   2f08c:	e0bfff17 	ldw	r2,-4(fp)
   2f090:	10c03017 	ldw	r3,192(r2)
   2f094:	00804034 	movhi	r2,256
   2f098:	10bfffc4 	addi	r2,r2,-1
   2f09c:	1886703a 	and	r3,r3,r2
   2f0a0:	00800874 	movhi	r2,33
   2f0a4:	10ae8604 	addi	r2,r2,-17896
   2f0a8:	18800a1e 	bne	r3,r2,2f0d4 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   2f0ac:	e0bfff17 	ldw	r2,-4(fp)
   2f0b0:	00c04034 	movhi	r3,256
   2f0b4:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
   2f0b8:	e0bfff17 	ldw	r2,-4(fp)
   2f0bc:	00c04004 	movi	r3,256
   2f0c0:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f0c4:	e0bfff17 	ldw	r2,-4(fp)
   2f0c8:	00c00074 	movhi	r3,1
   2f0cc:	10c01015 	stw	r3,64(r2)
   2f0d0:	00004706 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
   2f0d4:	e0bfff17 	ldw	r2,-4(fp)
   2f0d8:	10803017 	ldw	r2,192(r2)
   2f0dc:	10803fcc 	andi	r2,r2,255
   2f0e0:	10800618 	cmpnei	r2,r2,24
   2f0e4:	10000a1e 	bne	r2,zero,2f110 <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   2f0e8:	e0bfff17 	ldw	r2,-4(fp)
   2f0ec:	00c04034 	movhi	r3,256
   2f0f0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
   2f0f4:	e0bfff17 	ldw	r2,-4(fp)
   2f0f8:	00c01004 	movi	r3,64
   2f0fc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
   2f100:	e0bfff17 	ldw	r2,-4(fp)
   2f104:	00c00134 	movhi	r3,4
   2f108:	10c01015 	stw	r3,64(r2)
   2f10c:	00003806 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
   2f110:	e0bfff17 	ldw	r2,-4(fp)
   2f114:	10803017 	ldw	r2,192(r2)
   2f118:	10803fcc 	andi	r2,r2,255
   2f11c:	10800658 	cmpnei	r2,r2,25
   2f120:	10000d1e 	bne	r2,zero,2f158 <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
   2f124:	e0bfff17 	ldw	r2,-4(fp)
   2f128:	00c08034 	movhi	r3,512
   2f12c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
   2f130:	e0bfff17 	ldw	r2,-4(fp)
   2f134:	00c08004 	movi	r3,512
   2f138:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f13c:	e0bfff17 	ldw	r2,-4(fp)
   2f140:	00c00074 	movhi	r3,1
   2f144:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
   2f148:	e0bfff17 	ldw	r2,-4(fp)
   2f14c:	00c00044 	movi	r3,1
   2f150:	10c03215 	stw	r3,200(r2)
   2f154:	00002606 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
   2f158:	e0bfff17 	ldw	r2,-4(fp)
   2f15c:	10803017 	ldw	r2,192(r2)
   2f160:	10803fcc 	andi	r2,r2,255
   2f164:	10800818 	cmpnei	r2,r2,32
   2f168:	10000d1e 	bne	r2,zero,2f1a0 <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
   2f16c:	e0bfff17 	ldw	r2,-4(fp)
   2f170:	00c10034 	movhi	r3,1024
   2f174:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
   2f178:	e0bfff17 	ldw	r2,-4(fp)
   2f17c:	00c10004 	movi	r3,1024
   2f180:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f184:	e0bfff17 	ldw	r2,-4(fp)
   2f188:	00c00074 	movhi	r3,1
   2f18c:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
   2f190:	e0bfff17 	ldw	r2,-4(fp)
   2f194:	00c00044 	movi	r3,1
   2f198:	10c03215 	stw	r3,200(r2)
   2f19c:	00001406 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
   2f1a0:	e0bfff17 	ldw	r2,-4(fp)
   2f1a4:	10803017 	ldw	r2,192(r2)
   2f1a8:	10803fcc 	andi	r2,r2,255
   2f1ac:	10800858 	cmpnei	r2,r2,33
   2f1b0:	10000d1e 	bne	r2,zero,2f1e8 <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
   2f1b4:	e0bfff17 	ldw	r2,-4(fp)
   2f1b8:	00c20034 	movhi	r3,2048
   2f1bc:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
   2f1c0:	e0bfff17 	ldw	r2,-4(fp)
   2f1c4:	00c20004 	movi	r3,2048
   2f1c8:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   2f1cc:	e0bfff17 	ldw	r2,-4(fp)
   2f1d0:	00c00074 	movhi	r3,1
   2f1d4:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
   2f1d8:	e0bfff17 	ldw	r2,-4(fp)
   2f1dc:	00c00044 	movi	r3,1
   2f1e0:	10c03215 	stw	r3,200(r2)
   2f1e4:	00000206 	br	2f1f0 <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
   2f1e8:	00bffb44 	movi	r2,-19
   2f1ec:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
   2f1f0:	e0bfff17 	ldw	r2,-4(fp)
   2f1f4:	10800e17 	ldw	r2,56(r2)
   2f1f8:	1007883a 	mov	r3,r2
   2f1fc:	e0bfff17 	ldw	r2,-4(fp)
   2f200:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
   2f204:	e0bfff17 	ldw	r2,-4(fp)
   2f208:	00c00044 	movi	r3,1
   2f20c:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
   2f210:	e0bfff17 	ldw	r2,-4(fp)
   2f214:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
   2f218:	e0bfff17 	ldw	r2,-4(fp)
   2f21c:	00c04004 	movi	r3,256
   2f220:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
   2f224:	e0bffe17 	ldw	r2,-8(fp)
}
   2f228:	e037883a 	mov	sp,fp
   2f22c:	dfc00117 	ldw	ra,4(sp)
   2f230:	df000017 	ldw	fp,0(sp)
   2f234:	dec00204 	addi	sp,sp,8
   2f238:	f800283a 	ret

0002f23c <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
   2f23c:	deffee04 	addi	sp,sp,-72
   2f240:	dfc01115 	stw	ra,68(sp)
   2f244:	df001015 	stw	fp,64(sp)
   2f248:	df001004 	addi	fp,sp,64
   2f24c:	e13ffc15 	stw	r4,-16(fp)
   2f250:	e17ffd15 	stw	r5,-12(fp)
   2f254:	e1bffe15 	stw	r6,-8(fp)
   2f258:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
   2f25c:	00800804 	movi	r2,32
   2f260:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
   2f264:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
   2f268:	00002706 	br	2f308 <alt_epcs_flash_memcmp+0xcc>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
   2f26c:	e0fff117 	ldw	r3,-60(fp)
   2f270:	e0bfff17 	ldw	r2,-4(fp)
   2f274:	1880012e 	bgeu	r3,r2,2f27c <alt_epcs_flash_memcmp+0x40>
   2f278:	1805883a 	mov	r2,r3
   2f27c:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
   2f280:	e0fffe17 	ldw	r3,-8(fp)
   2f284:	e0bff017 	ldw	r2,-64(fp)
   2f288:	1885883a 	add	r2,r3,r2
   2f28c:	e0fff404 	addi	r3,fp,-48
   2f290:	e1fff217 	ldw	r7,-56(fp)
   2f294:	180d883a 	mov	r6,r3
   2f298:	100b883a 	mov	r5,r2
   2f29c:	e13ffc17 	ldw	r4,-16(fp)
   2f2a0:	002f8200 	call	2f820 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
   2f2a4:	1000020e 	bge	r2,zero,2f2b0 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
   2f2a8:	00bfffc4 	movi	r2,-1
   2f2ac:	00001906 	br	2f314 <alt_epcs_flash_memcmp+0xd8>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
   2f2b0:	e0bff017 	ldw	r2,-64(fp)
   2f2b4:	e0fffd17 	ldw	r3,-12(fp)
   2f2b8:	1885883a 	add	r2,r3,r2
   2f2bc:	e13ff217 	ldw	r4,-56(fp)
   2f2c0:	e0fff404 	addi	r3,fp,-48
   2f2c4:	200d883a 	mov	r6,r4
   2f2c8:	180b883a 	mov	r5,r3
   2f2cc:	1009883a 	mov	r4,r2
   2f2d0:	00326200 	call	32620 <memcmp>
   2f2d4:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
   2f2d8:	e0bff317 	ldw	r2,-52(fp)
   2f2dc:	10000226 	beq	r2,zero,2f2e8 <alt_epcs_flash_memcmp+0xac>
    {
      return this_chunk_cmp;
   2f2e0:	e0bff317 	ldw	r2,-52(fp)
   2f2e4:	00000b06 	br	2f314 <alt_epcs_flash_memcmp+0xd8>
    }

    n -= this_chunk_size;
   2f2e8:	e0bff217 	ldw	r2,-56(fp)
   2f2ec:	e0ffff17 	ldw	r3,-4(fp)
   2f2f0:	1885c83a 	sub	r2,r3,r2
   2f2f4:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
   2f2f8:	e0fff017 	ldw	r3,-64(fp)
   2f2fc:	e0bff217 	ldw	r2,-56(fp)
   2f300:	1885883a 	add	r2,r3,r2
   2f304:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
   2f308:	e0bfff17 	ldw	r2,-4(fp)
   2f30c:	103fd71e 	bne	r2,zero,2f26c <__reset+0xfff8f26c>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
   2f310:	0005883a 	mov	r2,zero
}
   2f314:	e037883a 	mov	sp,fp
   2f318:	dfc00117 	ldw	ra,4(sp)
   2f31c:	df000017 	ldw	fp,0(sp)
   2f320:	dec00204 	addi	sp,sp,8
   2f324:	f800283a 	ret

0002f328 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
   2f328:	defff404 	addi	sp,sp,-48
   2f32c:	dfc00b15 	stw	ra,44(sp)
   2f330:	df000a15 	stw	fp,40(sp)
   2f334:	df000a04 	addi	fp,sp,40
   2f338:	e13ffc15 	stw	r4,-16(fp)
   2f33c:	e17ffd15 	stw	r5,-12(fp)
   2f340:	e1bffe15 	stw	r6,-8(fp)
   2f344:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
   2f348:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   2f34c:	e03ff815 	stw	zero,-32(fp)
   2f350:	00008306 	br	2f560 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
   2f354:	e0fffc17 	ldw	r3,-16(fp)
   2f358:	e0bff817 	ldw	r2,-32(fp)
   2f35c:	1004913a 	slli	r2,r2,4
   2f360:	1885883a 	add	r2,r3,r2
   2f364:	10800d04 	addi	r2,r2,52
   2f368:	10800017 	ldw	r2,0(r2)
   2f36c:	e0fffd17 	ldw	r3,-12(fp)
   2f370:	18807816 	blt	r3,r2,2f554 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
   2f374:	e0fffc17 	ldw	r3,-16(fp)
   2f378:	e0bff817 	ldw	r2,-32(fp)
   2f37c:	1004913a 	slli	r2,r2,4
   2f380:	1885883a 	add	r2,r3,r2
   2f384:	10800d04 	addi	r2,r2,52
   2f388:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
   2f38c:	e13ffc17 	ldw	r4,-16(fp)
   2f390:	e0bff817 	ldw	r2,-32(fp)
   2f394:	1004913a 	slli	r2,r2,4
   2f398:	2085883a 	add	r2,r4,r2
   2f39c:	10800e04 	addi	r2,r2,56
   2f3a0:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
   2f3a4:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
   2f3a8:	e0fffd17 	ldw	r3,-12(fp)
   2f3ac:	1880690e 	bge	r3,r2,2f554 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
   2f3b0:	e0fffc17 	ldw	r3,-16(fp)
   2f3b4:	e0bff817 	ldw	r2,-32(fp)
   2f3b8:	1004913a 	slli	r2,r2,4
   2f3bc:	1885883a 	add	r2,r3,r2
   2f3c0:	10800d04 	addi	r2,r2,52
   2f3c4:	10800017 	ldw	r2,0(r2)
   2f3c8:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   2f3cc:	e03ff915 	stw	zero,-28(fp)
   2f3d0:	00005806 	br	2f534 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
   2f3d4:	e0fffd17 	ldw	r3,-12(fp)
   2f3d8:	e0bffa17 	ldw	r2,-24(fp)
   2f3dc:	18804916 	blt	r3,r2,2f504 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
   2f3e0:	e0fffc17 	ldw	r3,-16(fp)
   2f3e4:	e0bff817 	ldw	r2,-32(fp)
   2f3e8:	10800104 	addi	r2,r2,4
   2f3ec:	1004913a 	slli	r2,r2,4
   2f3f0:	1885883a 	add	r2,r3,r2
   2f3f4:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
   2f3f8:	e0bffa17 	ldw	r2,-24(fp)
   2f3fc:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
   2f400:	e0fffd17 	ldw	r3,-12(fp)
   2f404:	18803f0e 	bge	r3,r2,2f504 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
   2f408:	e0fffc17 	ldw	r3,-16(fp)
   2f40c:	e0bff817 	ldw	r2,-32(fp)
   2f410:	10800104 	addi	r2,r2,4
   2f414:	1004913a 	slli	r2,r2,4
   2f418:	1885883a 	add	r2,r3,r2
   2f41c:	10c00017 	ldw	r3,0(r2)
   2f420:	e0bffa17 	ldw	r2,-24(fp)
   2f424:	1887883a 	add	r3,r3,r2
   2f428:	e0bffd17 	ldw	r2,-12(fp)
   2f42c:	1885c83a 	sub	r2,r3,r2
   2f430:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
   2f434:	e0fffb17 	ldw	r3,-20(fp)
   2f438:	e0bfff17 	ldw	r2,-4(fp)
   2f43c:	1880010e 	bge	r3,r2,2f444 <alt_epcs_flash_write+0x11c>
   2f440:	1805883a 	mov	r2,r3
   2f444:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
   2f448:	e0bffb17 	ldw	r2,-20(fp)
   2f44c:	100f883a 	mov	r7,r2
   2f450:	e1bffd17 	ldw	r6,-12(fp)
   2f454:	e17ffe17 	ldw	r5,-8(fp)
   2f458:	e13ffc17 	ldw	r4,-16(fp)
   2f45c:	002f23c0 	call	2f23c <alt_epcs_flash_memcmp>
   2f460:	10001226 	beq	r2,zero,2f4ac <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
   2f464:	e0bffc17 	ldw	r2,-16(fp)
   2f468:	10800817 	ldw	r2,32(r2)
   2f46c:	e17ffa17 	ldw	r5,-24(fp)
   2f470:	e13ffc17 	ldw	r4,-16(fp)
   2f474:	103ee83a 	callr	r2
   2f478:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
   2f47c:	e0bff717 	ldw	r2,-36(fp)
   2f480:	10000a1e 	bne	r2,zero,2f4ac <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
   2f484:	e0bffc17 	ldw	r2,-16(fp)
   2f488:	10800917 	ldw	r2,36(r2)
   2f48c:	e0fffb17 	ldw	r3,-20(fp)
   2f490:	d8c00015 	stw	r3,0(sp)
   2f494:	e1fffe17 	ldw	r7,-8(fp)
   2f498:	e1bffd17 	ldw	r6,-12(fp)
   2f49c:	e17ffa17 	ldw	r5,-24(fp)
   2f4a0:	e13ffc17 	ldw	r4,-16(fp)
   2f4a4:	103ee83a 	callr	r2
   2f4a8:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
   2f4ac:	e0ffff17 	ldw	r3,-4(fp)
   2f4b0:	e0bffb17 	ldw	r2,-20(fp)
   2f4b4:	18802e26 	beq	r3,r2,2f570 <alt_epcs_flash_write+0x248>
   2f4b8:	e0bff717 	ldw	r2,-36(fp)
   2f4bc:	10002c1e 	bne	r2,zero,2f570 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
   2f4c0:	e0ffff17 	ldw	r3,-4(fp)
   2f4c4:	e0bffb17 	ldw	r2,-20(fp)
   2f4c8:	1885c83a 	sub	r2,r3,r2
   2f4cc:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
   2f4d0:	e0fffc17 	ldw	r3,-16(fp)
   2f4d4:	e0bff817 	ldw	r2,-32(fp)
   2f4d8:	10800104 	addi	r2,r2,4
   2f4dc:	1004913a 	slli	r2,r2,4
   2f4e0:	1885883a 	add	r2,r3,r2
   2f4e4:	10c00017 	ldw	r3,0(r2)
   2f4e8:	e0bffa17 	ldw	r2,-24(fp)
   2f4ec:	1885883a 	add	r2,r3,r2
   2f4f0:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
   2f4f4:	e0bffb17 	ldw	r2,-20(fp)
   2f4f8:	e0fffe17 	ldw	r3,-8(fp)
   2f4fc:	1885883a 	add	r2,r3,r2
   2f500:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
   2f504:	e0fffc17 	ldw	r3,-16(fp)
   2f508:	e0bff817 	ldw	r2,-32(fp)
   2f50c:	10800104 	addi	r2,r2,4
   2f510:	1004913a 	slli	r2,r2,4
   2f514:	1885883a 	add	r2,r3,r2
   2f518:	10800017 	ldw	r2,0(r2)
   2f51c:	e0fffa17 	ldw	r3,-24(fp)
   2f520:	1885883a 	add	r2,r3,r2
   2f524:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   2f528:	e0bff917 	ldw	r2,-28(fp)
   2f52c:	10800044 	addi	r2,r2,1
   2f530:	e0bff915 	stw	r2,-28(fp)
   2f534:	e0fffc17 	ldw	r3,-16(fp)
   2f538:	e0bff817 	ldw	r2,-32(fp)
   2f53c:	1004913a 	slli	r2,r2,4
   2f540:	1885883a 	add	r2,r3,r2
   2f544:	10800f04 	addi	r2,r2,60
   2f548:	10800017 	ldw	r2,0(r2)
   2f54c:	e0fff917 	ldw	r3,-28(fp)
   2f550:	18bfa016 	blt	r3,r2,2f3d4 <__reset+0xfff8f3d4>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   2f554:	e0bff817 	ldw	r2,-32(fp)
   2f558:	10800044 	addi	r2,r2,1
   2f55c:	e0bff815 	stw	r2,-32(fp)
   2f560:	e0bffc17 	ldw	r2,-16(fp)
   2f564:	10800c17 	ldw	r2,48(r2)
   2f568:	e0fff817 	ldw	r3,-32(fp)
   2f56c:	18bf7916 	blt	r3,r2,2f354 <__reset+0xfff8f354>
      }
    }
  }

finished:
  return ret_code;
   2f570:	e0bff717 	ldw	r2,-36(fp)
}
   2f574:	e037883a 	mov	sp,fp
   2f578:	dfc00117 	ldw	ra,4(sp)
   2f57c:	df000017 	ldw	fp,0(sp)
   2f580:	dec00204 	addi	sp,sp,8
   2f584:	f800283a 	ret

0002f588 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
   2f588:	defffa04 	addi	sp,sp,-24
   2f58c:	df000515 	stw	fp,20(sp)
   2f590:	df000504 	addi	fp,sp,20
   2f594:	e13ffd15 	stw	r4,-12(fp)
   2f598:	e17ffe15 	stw	r5,-8(fp)
   2f59c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
   2f5a0:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
   2f5a4:	e0bffd17 	ldw	r2,-12(fp)
   2f5a8:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
   2f5ac:	e0bffc17 	ldw	r2,-16(fp)
   2f5b0:	10c00c17 	ldw	r3,48(r2)
   2f5b4:	e0bfff17 	ldw	r2,-4(fp)
   2f5b8:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
   2f5bc:	e0bffc17 	ldw	r2,-16(fp)
   2f5c0:	10800c17 	ldw	r2,48(r2)
   2f5c4:	1000031e 	bne	r2,zero,2f5d4 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
   2f5c8:	00bffec4 	movi	r2,-5
   2f5cc:	e0bffb15 	stw	r2,-20(fp)
   2f5d0:	00000b06 	br	2f600 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   2f5d4:	e0bffc17 	ldw	r2,-16(fp)
   2f5d8:	10800c17 	ldw	r2,48(r2)
   2f5dc:	10800250 	cmplti	r2,r2,9
   2f5e0:	1000031e 	bne	r2,zero,2f5f0 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
   2f5e4:	00bffd04 	movi	r2,-12
   2f5e8:	e0bffb15 	stw	r2,-20(fp)
   2f5ec:	00000406 	br	2f600 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
   2f5f0:	e0bffc17 	ldw	r2,-16(fp)
   2f5f4:	10c00d04 	addi	r3,r2,52
   2f5f8:	e0bffe17 	ldw	r2,-8(fp)
   2f5fc:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
   2f600:	e0bffb17 	ldw	r2,-20(fp)
}
   2f604:	e037883a 	mov	sp,fp
   2f608:	df000017 	ldw	fp,0(sp)
   2f60c:	dec00104 	addi	sp,sp,4
   2f610:	f800283a 	ret

0002f614 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
   2f614:	defff904 	addi	sp,sp,-28
   2f618:	df000615 	stw	fp,24(sp)
   2f61c:	df000604 	addi	fp,sp,24
   2f620:	e13ffe15 	stw	r4,-8(fp)
   2f624:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
   2f628:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   2f62c:	e0bffe17 	ldw	r2,-8(fp)
   2f630:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
   2f634:	e0bffb17 	ldw	r2,-20(fp)
   2f638:	10800c17 	ldw	r2,48(r2)
   2f63c:	10bfffc4 	addi	r2,r2,-1
   2f640:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
   2f644:	e0fffb17 	ldw	r3,-20(fp)
   2f648:	e0bffc17 	ldw	r2,-16(fp)
   2f64c:	1004913a 	slli	r2,r2,4
   2f650:	1885883a 	add	r2,r3,r2
   2f654:	10800d04 	addi	r2,r2,52
   2f658:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
   2f65c:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
   2f660:	e13ffb17 	ldw	r4,-20(fp)
   2f664:	e0bffc17 	ldw	r2,-16(fp)
   2f668:	1004913a 	slli	r2,r2,4
   2f66c:	2085883a 	add	r2,r4,r2
   2f670:	10800e04 	addi	r2,r2,56
   2f674:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
   2f678:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
   2f67c:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
   2f680:	e0bfff17 	ldw	r2,-4(fp)
   2f684:	e0fffd17 	ldw	r3,-12(fp)
   2f688:	1880022e 	bgeu	r3,r2,2f694 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
   2f68c:	00bffec4 	movi	r2,-5
   2f690:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
   2f694:	e0bffa17 	ldw	r2,-24(fp)
}
   2f698:	e037883a 	mov	sp,fp
   2f69c:	df000017 	ldw	fp,0(sp)
   2f6a0:	dec00104 	addi	sp,sp,4
   2f6a4:	f800283a 	ret

0002f6a8 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
   2f6a8:	defffa04 	addi	sp,sp,-24
   2f6ac:	dfc00515 	stw	ra,20(sp)
   2f6b0:	df000415 	stw	fp,16(sp)
   2f6b4:	df000404 	addi	fp,sp,16
   2f6b8:	e13ffe15 	stw	r4,-8(fp)
   2f6bc:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
   2f6c0:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   2f6c4:	e0bffe17 	ldw	r2,-8(fp)
   2f6c8:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
   2f6cc:	e17fff17 	ldw	r5,-4(fp)
   2f6d0:	e13ffe17 	ldw	r4,-8(fp)
   2f6d4:	002f6140 	call	2f614 <alt_epcs_test_address>
   2f6d8:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
   2f6dc:	e0bffc17 	ldw	r2,-16(fp)
   2f6e0:	10000916 	blt	r2,zero,2f708 <alt_epcs_flash_erase_block+0x60>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
   2f6e4:	e0bffd17 	ldw	r2,-12(fp)
   2f6e8:	10c02e17 	ldw	r3,184(r2)
   2f6ec:	e13fff17 	ldw	r4,-4(fp)
   2f6f0:	e0bffd17 	ldw	r2,-12(fp)
   2f6f4:	10803217 	ldw	r2,200(r2)
   2f6f8:	100d883a 	mov	r6,r2
   2f6fc:	200b883a 	mov	r5,r4
   2f700:	1809883a 	mov	r4,r3
   2f704:	00312d80 	call	312d8 <epcs_sector_erase>
  }
  return ret_code;
   2f708:	e0bffc17 	ldw	r2,-16(fp)
}
   2f70c:	e037883a 	mov	sp,fp
   2f710:	dfc00117 	ldw	ra,4(sp)
   2f714:	df000017 	ldw	fp,0(sp)
   2f718:	dec00204 	addi	sp,sp,8
   2f71c:	f800283a 	ret

0002f720 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
   2f720:	defff404 	addi	sp,sp,-48
   2f724:	dfc00b15 	stw	ra,44(sp)
   2f728:	df000a15 	stw	fp,40(sp)
   2f72c:	df000a04 	addi	fp,sp,40
   2f730:	e13ffc15 	stw	r4,-16(fp)
   2f734:	e17ffd15 	stw	r5,-12(fp)
   2f738:	e1bffe15 	stw	r6,-8(fp)
   2f73c:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   2f740:	e0bffc17 	ldw	r2,-16(fp)
   2f744:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
   2f748:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
   2f74c:	e17ffe17 	ldw	r5,-8(fp)
   2f750:	e13ffc17 	ldw	r4,-16(fp)
   2f754:	002f6140 	call	2f614 <alt_epcs_test_address>
   2f758:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
   2f75c:	e0bff917 	ldw	r2,-28(fp)
   2f760:	10002916 	blt	r2,zero,2f808 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   2f764:	00002606 	br	2f800 <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
   2f768:	e0bff817 	ldw	r2,-32(fp)
   2f76c:	10c03117 	ldw	r3,196(r2)
   2f770:	e0bffe17 	ldw	r2,-8(fp)
   2f774:	1887883a 	add	r3,r3,r2
   2f778:	e0bff817 	ldw	r2,-32(fp)
   2f77c:	10803117 	ldw	r2,196(r2)
   2f780:	0085c83a 	sub	r2,zero,r2
   2f784:	1884703a 	and	r2,r3,r2
   2f788:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
   2f78c:	e0fffa17 	ldw	r3,-24(fp)
   2f790:	e0bffe17 	ldw	r2,-8(fp)
   2f794:	1885c83a 	sub	r2,r3,r2
   2f798:	e0c00217 	ldw	r3,8(fp)
   2f79c:	1880010e 	bge	r3,r2,2f7a4 <alt_epcs_flash_write_block+0x84>
   2f7a0:	1805883a 	mov	r2,r3
   2f7a4:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
   2f7a8:	e0bff817 	ldw	r2,-32(fp)
   2f7ac:	11002e17 	ldw	r4,184(r2)
   2f7b0:	e0bff717 	ldw	r2,-36(fp)
   2f7b4:	e0ffff17 	ldw	r3,-4(fp)
   2f7b8:	1887883a 	add	r3,r3,r2
   2f7bc:	e0bff817 	ldw	r2,-32(fp)
   2f7c0:	10803217 	ldw	r2,200(r2)
   2f7c4:	d8800015 	stw	r2,0(sp)
   2f7c8:	e1fffb17 	ldw	r7,-20(fp)
   2f7cc:	180d883a 	mov	r6,r3
   2f7d0:	e17ffe17 	ldw	r5,-8(fp)
   2f7d4:	00315880 	call	31588 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
   2f7d8:	e0c00217 	ldw	r3,8(fp)
   2f7dc:	e0bffb17 	ldw	r2,-20(fp)
   2f7e0:	1885c83a 	sub	r2,r3,r2
   2f7e4:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
   2f7e8:	e0fff717 	ldw	r3,-36(fp)
   2f7ec:	e0bffb17 	ldw	r2,-20(fp)
   2f7f0:	1885883a 	add	r2,r3,r2
   2f7f4:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
   2f7f8:	e0bffa17 	ldw	r2,-24(fp)
   2f7fc:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   2f800:	e0800217 	ldw	r2,8(fp)
   2f804:	103fd81e 	bne	r2,zero,2f768 <__reset+0xfff8f768>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
   2f808:	e0bff917 	ldw	r2,-28(fp)
}
   2f80c:	e037883a 	mov	sp,fp
   2f810:	dfc00117 	ldw	ra,4(sp)
   2f814:	df000017 	ldw	fp,0(sp)
   2f818:	dec00204 	addi	sp,sp,8
   2f81c:	f800283a 	ret

0002f820 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
   2f820:	defff704 	addi	sp,sp,-36
   2f824:	dfc00815 	stw	ra,32(sp)
   2f828:	df000715 	stw	fp,28(sp)
   2f82c:	df000704 	addi	fp,sp,28
   2f830:	e13ffc15 	stw	r4,-16(fp)
   2f834:	e17ffd15 	stw	r5,-12(fp)
   2f838:	e1bffe15 	stw	r6,-8(fp)
   2f83c:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
   2f840:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   2f844:	e0bffc17 	ldw	r2,-16(fp)
   2f848:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
   2f84c:	e17ffd17 	ldw	r5,-12(fp)
   2f850:	e13ffc17 	ldw	r4,-16(fp)
   2f854:	002f6140 	call	2f614 <alt_epcs_test_address>
   2f858:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
   2f85c:	e0bffa17 	ldw	r2,-24(fp)
   2f860:	10000f16 	blt	r2,zero,2f8a0 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
   2f864:	e0bffb17 	ldw	r2,-20(fp)
   2f868:	10c02e17 	ldw	r3,184(r2)
   2f86c:	e0bffb17 	ldw	r2,-20(fp)
   2f870:	10803217 	ldw	r2,200(r2)
   2f874:	d8800015 	stw	r2,0(sp)
   2f878:	e1ffff17 	ldw	r7,-4(fp)
   2f87c:	e1bffe17 	ldw	r6,-8(fp)
   2f880:	e17ffd17 	ldw	r5,-12(fp)
   2f884:	1809883a 	mov	r4,r3
   2f888:	00313d40 	call	313d4 <epcs_read_buffer>
   2f88c:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
   2f890:	e0fffa17 	ldw	r3,-24(fp)
   2f894:	e0bfff17 	ldw	r2,-4(fp)
   2f898:	1880011e 	bne	r3,r2,2f8a0 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
   2f89c:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
   2f8a0:	e0bffa17 	ldw	r2,-24(fp)
}
   2f8a4:	e037883a 	mov	sp,fp
   2f8a8:	dfc00117 	ldw	ra,4(sp)
   2f8ac:	df000017 	ldw	fp,0(sp)
   2f8b0:	dec00204 	addi	sp,sp,8
   2f8b4:	f800283a 	ret

0002f8b8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   2f8b8:	defffa04 	addi	sp,sp,-24
   2f8bc:	dfc00515 	stw	ra,20(sp)
   2f8c0:	df000415 	stw	fp,16(sp)
   2f8c4:	df000404 	addi	fp,sp,16
   2f8c8:	e13ffd15 	stw	r4,-12(fp)
   2f8cc:	e17ffe15 	stw	r5,-8(fp)
   2f8d0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   2f8d4:	e0bffd17 	ldw	r2,-12(fp)
   2f8d8:	10800017 	ldw	r2,0(r2)
   2f8dc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   2f8e0:	e0bffc17 	ldw	r2,-16(fp)
   2f8e4:	10c00a04 	addi	r3,r2,40
   2f8e8:	e0bffd17 	ldw	r2,-12(fp)
   2f8ec:	10800217 	ldw	r2,8(r2)
   2f8f0:	100f883a 	mov	r7,r2
   2f8f4:	e1bfff17 	ldw	r6,-4(fp)
   2f8f8:	e17ffe17 	ldw	r5,-8(fp)
   2f8fc:	1809883a 	mov	r4,r3
   2f900:	002fed80 	call	2fed8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   2f904:	e037883a 	mov	sp,fp
   2f908:	dfc00117 	ldw	ra,4(sp)
   2f90c:	df000017 	ldw	fp,0(sp)
   2f910:	dec00204 	addi	sp,sp,8
   2f914:	f800283a 	ret

0002f918 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   2f918:	defffa04 	addi	sp,sp,-24
   2f91c:	dfc00515 	stw	ra,20(sp)
   2f920:	df000415 	stw	fp,16(sp)
   2f924:	df000404 	addi	fp,sp,16
   2f928:	e13ffd15 	stw	r4,-12(fp)
   2f92c:	e17ffe15 	stw	r5,-8(fp)
   2f930:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   2f934:	e0bffd17 	ldw	r2,-12(fp)
   2f938:	10800017 	ldw	r2,0(r2)
   2f93c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   2f940:	e0bffc17 	ldw	r2,-16(fp)
   2f944:	10c00a04 	addi	r3,r2,40
   2f948:	e0bffd17 	ldw	r2,-12(fp)
   2f94c:	10800217 	ldw	r2,8(r2)
   2f950:	100f883a 	mov	r7,r2
   2f954:	e1bfff17 	ldw	r6,-4(fp)
   2f958:	e17ffe17 	ldw	r5,-8(fp)
   2f95c:	1809883a 	mov	r4,r3
   2f960:	00300f40 	call	300f4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   2f964:	e037883a 	mov	sp,fp
   2f968:	dfc00117 	ldw	ra,4(sp)
   2f96c:	df000017 	ldw	fp,0(sp)
   2f970:	dec00204 	addi	sp,sp,8
   2f974:	f800283a 	ret

0002f978 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   2f978:	defffc04 	addi	sp,sp,-16
   2f97c:	dfc00315 	stw	ra,12(sp)
   2f980:	df000215 	stw	fp,8(sp)
   2f984:	df000204 	addi	fp,sp,8
   2f988:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   2f98c:	e0bfff17 	ldw	r2,-4(fp)
   2f990:	10800017 	ldw	r2,0(r2)
   2f994:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   2f998:	e0bffe17 	ldw	r2,-8(fp)
   2f99c:	10c00a04 	addi	r3,r2,40
   2f9a0:	e0bfff17 	ldw	r2,-4(fp)
   2f9a4:	10800217 	ldw	r2,8(r2)
   2f9a8:	100b883a 	mov	r5,r2
   2f9ac:	1809883a 	mov	r4,r3
   2f9b0:	002fd800 	call	2fd80 <altera_avalon_jtag_uart_close>
}
   2f9b4:	e037883a 	mov	sp,fp
   2f9b8:	dfc00117 	ldw	ra,4(sp)
   2f9bc:	df000017 	ldw	fp,0(sp)
   2f9c0:	dec00204 	addi	sp,sp,8
   2f9c4:	f800283a 	ret

0002f9c8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   2f9c8:	defffa04 	addi	sp,sp,-24
   2f9cc:	dfc00515 	stw	ra,20(sp)
   2f9d0:	df000415 	stw	fp,16(sp)
   2f9d4:	df000404 	addi	fp,sp,16
   2f9d8:	e13ffd15 	stw	r4,-12(fp)
   2f9dc:	e17ffe15 	stw	r5,-8(fp)
   2f9e0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   2f9e4:	e0bffd17 	ldw	r2,-12(fp)
   2f9e8:	10800017 	ldw	r2,0(r2)
   2f9ec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   2f9f0:	e0bffc17 	ldw	r2,-16(fp)
   2f9f4:	10800a04 	addi	r2,r2,40
   2f9f8:	e1bfff17 	ldw	r6,-4(fp)
   2f9fc:	e17ffe17 	ldw	r5,-8(fp)
   2fa00:	1009883a 	mov	r4,r2
   2fa04:	002fde80 	call	2fde8 <altera_avalon_jtag_uart_ioctl>
}
   2fa08:	e037883a 	mov	sp,fp
   2fa0c:	dfc00117 	ldw	ra,4(sp)
   2fa10:	df000017 	ldw	fp,0(sp)
   2fa14:	dec00204 	addi	sp,sp,8
   2fa18:	f800283a 	ret

0002fa1c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   2fa1c:	defffb04 	addi	sp,sp,-20
   2fa20:	dfc00415 	stw	ra,16(sp)
   2fa24:	df000315 	stw	fp,12(sp)
   2fa28:	df000304 	addi	fp,sp,12
   2fa2c:	e13ffd15 	stw	r4,-12(fp)
   2fa30:	e17ffe15 	stw	r5,-8(fp)
   2fa34:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   2fa38:	e0bffd17 	ldw	r2,-12(fp)
   2fa3c:	00c00044 	movi	r3,1
   2fa40:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   2fa44:	e0bffd17 	ldw	r2,-12(fp)
   2fa48:	10800017 	ldw	r2,0(r2)
   2fa4c:	10800104 	addi	r2,r2,4
   2fa50:	1007883a 	mov	r3,r2
   2fa54:	e0bffd17 	ldw	r2,-12(fp)
   2fa58:	10800817 	ldw	r2,32(r2)
   2fa5c:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
   2fa60:	e0bfff17 	ldw	r2,-4(fp)
   2fa64:	018000f4 	movhi	r6,3
   2fa68:	31beb404 	addi	r6,r6,-1328
   2fa6c:	e17ffd17 	ldw	r5,-12(fp)
   2fa70:	1009883a 	mov	r4,r2
   2fa74:	0020f9c0 	call	20f9c <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   2fa78:	e0bffd17 	ldw	r2,-12(fp)
   2fa7c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   2fa80:	e0bffd17 	ldw	r2,-12(fp)
   2fa84:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   2fa88:	d0e03b17 	ldw	r3,-32532(gp)
   2fa8c:	e1fffd17 	ldw	r7,-12(fp)
   2fa90:	018000f4 	movhi	r6,3
   2fa94:	31bf3804 	addi	r6,r6,-800
   2fa98:	180b883a 	mov	r5,r3
   2fa9c:	1009883a 	mov	r4,r2
   2faa0:	0031ab40 	call	31ab4 <alt_alarm_start>
   2faa4:	1000040e 	bge	r2,zero,2fab8 <altera_avalon_jtag_uart_init+0x9c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   2faa8:	e0fffd17 	ldw	r3,-12(fp)
   2faac:	00a00034 	movhi	r2,32768
   2fab0:	10bfffc4 	addi	r2,r2,-1
   2fab4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   2fab8:	0001883a 	nop
   2fabc:	e037883a 	mov	sp,fp
   2fac0:	dfc00117 	ldw	ra,4(sp)
   2fac4:	df000017 	ldw	fp,0(sp)
   2fac8:	dec00204 	addi	sp,sp,8
   2facc:	f800283a 	ret

0002fad0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   2fad0:	defff704 	addi	sp,sp,-36
   2fad4:	df000815 	stw	fp,32(sp)
   2fad8:	df000804 	addi	fp,sp,32
   2fadc:	e13ffe15 	stw	r4,-8(fp)
   2fae0:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   2fae4:	e0bffe17 	ldw	r2,-8(fp)
   2fae8:	e0bffa15 	stw	r2,-24(fp)
  unsigned int base = sp->base;
   2faec:	e0bffa17 	ldw	r2,-24(fp)
   2faf0:	10800017 	ldw	r2,0(r2)
   2faf4:	e0bffb15 	stw	r2,-20(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   2faf8:	e0bffb17 	ldw	r2,-20(fp)
   2fafc:	10800104 	addi	r2,r2,4
   2fb00:	10800037 	ldwio	r2,0(r2)
   2fb04:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   2fb08:	e0bffc17 	ldw	r2,-16(fp)
   2fb0c:	1080c00c 	andi	r2,r2,768
   2fb10:	10006d26 	beq	r2,zero,2fcc8 <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   2fb14:	e0bffc17 	ldw	r2,-16(fp)
   2fb18:	1080400c 	andi	r2,r2,256
   2fb1c:	10003526 	beq	r2,zero,2fbf4 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   2fb20:	00800074 	movhi	r2,1
   2fb24:	e0bff815 	stw	r2,-32(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   2fb28:	e0bffa17 	ldw	r2,-24(fp)
   2fb2c:	10800a17 	ldw	r2,40(r2)
   2fb30:	10800044 	addi	r2,r2,1
   2fb34:	1081ffcc 	andi	r2,r2,2047
   2fb38:	e0bffd15 	stw	r2,-12(fp)
        if (next == sp->rx_out)
   2fb3c:	e0bffa17 	ldw	r2,-24(fp)
   2fb40:	10c00b17 	ldw	r3,44(r2)
   2fb44:	e0bffd17 	ldw	r2,-12(fp)
   2fb48:	18801526 	beq	r3,r2,2fba0 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   2fb4c:	e0bffb17 	ldw	r2,-20(fp)
   2fb50:	10800037 	ldwio	r2,0(r2)
   2fb54:	e0bff815 	stw	r2,-32(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   2fb58:	e0bff817 	ldw	r2,-32(fp)
   2fb5c:	10a0000c 	andi	r2,r2,32768
   2fb60:	10001126 	beq	r2,zero,2fba8 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   2fb64:	e0bffa17 	ldw	r2,-24(fp)
   2fb68:	10800a17 	ldw	r2,40(r2)
   2fb6c:	e0fff817 	ldw	r3,-32(fp)
   2fb70:	1809883a 	mov	r4,r3
   2fb74:	e0fffa17 	ldw	r3,-24(fp)
   2fb78:	1885883a 	add	r2,r3,r2
   2fb7c:	10800e04 	addi	r2,r2,56
   2fb80:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   2fb84:	e0bffa17 	ldw	r2,-24(fp)
   2fb88:	10800a17 	ldw	r2,40(r2)
   2fb8c:	10800044 	addi	r2,r2,1
   2fb90:	10c1ffcc 	andi	r3,r2,2047
   2fb94:	e0bffa17 	ldw	r2,-24(fp)
   2fb98:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   2fb9c:	003fe206 	br	2fb28 <__reset+0xfff8fb28>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   2fba0:	0001883a 	nop
   2fba4:	00000106 	br	2fbac <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   2fba8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   2fbac:	e0bff817 	ldw	r2,-32(fp)
   2fbb0:	10bfffec 	andhi	r2,r2,65535
   2fbb4:	10000f26 	beq	r2,zero,2fbf4 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   2fbb8:	e0bffa17 	ldw	r2,-24(fp)
   2fbbc:	10c00817 	ldw	r3,32(r2)
   2fbc0:	00bfff84 	movi	r2,-2
   2fbc4:	1886703a 	and	r3,r3,r2
   2fbc8:	e0bffa17 	ldw	r2,-24(fp)
   2fbcc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   2fbd0:	e0bffb17 	ldw	r2,-20(fp)
   2fbd4:	10800104 	addi	r2,r2,4
   2fbd8:	1007883a 	mov	r3,r2
   2fbdc:	e0bffa17 	ldw	r2,-24(fp)
   2fbe0:	10800817 	ldw	r2,32(r2)
   2fbe4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   2fbe8:	e0bffb17 	ldw	r2,-20(fp)
   2fbec:	10800104 	addi	r2,r2,4
   2fbf0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   2fbf4:	e0bffc17 	ldw	r2,-16(fp)
   2fbf8:	1080800c 	andi	r2,r2,512
   2fbfc:	103fbe26 	beq	r2,zero,2faf8 <__reset+0xfff8faf8>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   2fc00:	e0bffc17 	ldw	r2,-16(fp)
   2fc04:	1004d43a 	srli	r2,r2,16
   2fc08:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   2fc0c:	00001406 	br	2fc60 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   2fc10:	e0bffb17 	ldw	r2,-20(fp)
   2fc14:	e0fffa17 	ldw	r3,-24(fp)
   2fc18:	18c00d17 	ldw	r3,52(r3)
   2fc1c:	e13ffa17 	ldw	r4,-24(fp)
   2fc20:	20c7883a 	add	r3,r4,r3
   2fc24:	18c20e04 	addi	r3,r3,2104
   2fc28:	18c00003 	ldbu	r3,0(r3)
   2fc2c:	18c03fcc 	andi	r3,r3,255
   2fc30:	18c0201c 	xori	r3,r3,128
   2fc34:	18ffe004 	addi	r3,r3,-128
   2fc38:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   2fc3c:	e0bffa17 	ldw	r2,-24(fp)
   2fc40:	10800d17 	ldw	r2,52(r2)
   2fc44:	10800044 	addi	r2,r2,1
   2fc48:	10c1ffcc 	andi	r3,r2,2047
   2fc4c:	e0bffa17 	ldw	r2,-24(fp)
   2fc50:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   2fc54:	e0bff917 	ldw	r2,-28(fp)
   2fc58:	10bfffc4 	addi	r2,r2,-1
   2fc5c:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   2fc60:	e0bff917 	ldw	r2,-28(fp)
   2fc64:	10000526 	beq	r2,zero,2fc7c <altera_avalon_jtag_uart_irq+0x1ac>
   2fc68:	e0bffa17 	ldw	r2,-24(fp)
   2fc6c:	10c00d17 	ldw	r3,52(r2)
   2fc70:	e0bffa17 	ldw	r2,-24(fp)
   2fc74:	10800c17 	ldw	r2,48(r2)
   2fc78:	18bfe51e 	bne	r3,r2,2fc10 <__reset+0xfff8fc10>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   2fc7c:	e0bff917 	ldw	r2,-28(fp)
   2fc80:	103f9d26 	beq	r2,zero,2faf8 <__reset+0xfff8faf8>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   2fc84:	e0bffa17 	ldw	r2,-24(fp)
   2fc88:	10c00817 	ldw	r3,32(r2)
   2fc8c:	00bfff44 	movi	r2,-3
   2fc90:	1886703a 	and	r3,r3,r2
   2fc94:	e0bffa17 	ldw	r2,-24(fp)
   2fc98:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   2fc9c:	e0bffa17 	ldw	r2,-24(fp)
   2fca0:	10800017 	ldw	r2,0(r2)
   2fca4:	10800104 	addi	r2,r2,4
   2fca8:	1007883a 	mov	r3,r2
   2fcac:	e0bffa17 	ldw	r2,-24(fp)
   2fcb0:	10800817 	ldw	r2,32(r2)
   2fcb4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   2fcb8:	e0bffb17 	ldw	r2,-20(fp)
   2fcbc:	10800104 	addi	r2,r2,4
   2fcc0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   2fcc4:	003f8c06 	br	2faf8 <__reset+0xfff8faf8>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   2fcc8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   2fccc:	0001883a 	nop
   2fcd0:	e037883a 	mov	sp,fp
   2fcd4:	df000017 	ldw	fp,0(sp)
   2fcd8:	dec00104 	addi	sp,sp,4
   2fcdc:	f800283a 	ret

0002fce0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   2fce0:	defff804 	addi	sp,sp,-32
   2fce4:	df000715 	stw	fp,28(sp)
   2fce8:	df000704 	addi	fp,sp,28
   2fcec:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   2fcf0:	e0bffb17 	ldw	r2,-20(fp)
   2fcf4:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   2fcf8:	e0bff917 	ldw	r2,-28(fp)
   2fcfc:	10800017 	ldw	r2,0(r2)
   2fd00:	10800104 	addi	r2,r2,4
   2fd04:	10800037 	ldwio	r2,0(r2)
   2fd08:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   2fd0c:	e0bffa17 	ldw	r2,-24(fp)
   2fd10:	1081000c 	andi	r2,r2,1024
   2fd14:	10000b26 	beq	r2,zero,2fd44 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   2fd18:	e0bff917 	ldw	r2,-28(fp)
   2fd1c:	10800017 	ldw	r2,0(r2)
   2fd20:	10800104 	addi	r2,r2,4
   2fd24:	1007883a 	mov	r3,r2
   2fd28:	e0bff917 	ldw	r2,-28(fp)
   2fd2c:	10800817 	ldw	r2,32(r2)
   2fd30:	10810014 	ori	r2,r2,1024
   2fd34:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
   2fd38:	e0bff917 	ldw	r2,-28(fp)
   2fd3c:	10000915 	stw	zero,36(r2)
   2fd40:	00000a06 	br	2fd6c <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   2fd44:	e0bff917 	ldw	r2,-28(fp)
   2fd48:	10c00917 	ldw	r3,36(r2)
   2fd4c:	00a00034 	movhi	r2,32768
   2fd50:	10bfff04 	addi	r2,r2,-4
   2fd54:	10c00536 	bltu	r2,r3,2fd6c <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
   2fd58:	e0bff917 	ldw	r2,-28(fp)
   2fd5c:	10800917 	ldw	r2,36(r2)
   2fd60:	10c00044 	addi	r3,r2,1
   2fd64:	e0bff917 	ldw	r2,-28(fp)
   2fd68:	10c00915 	stw	r3,36(r2)
   2fd6c:	d0a03b17 	ldw	r2,-32532(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   2fd70:	e037883a 	mov	sp,fp
   2fd74:	df000017 	ldw	fp,0(sp)
   2fd78:	dec00104 	addi	sp,sp,4
   2fd7c:	f800283a 	ret

0002fd80 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   2fd80:	defffd04 	addi	sp,sp,-12
   2fd84:	df000215 	stw	fp,8(sp)
   2fd88:	df000204 	addi	fp,sp,8
   2fd8c:	e13ffe15 	stw	r4,-8(fp)
   2fd90:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   2fd94:	00000506 	br	2fdac <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   2fd98:	e0bfff17 	ldw	r2,-4(fp)
   2fd9c:	1090000c 	andi	r2,r2,16384
   2fda0:	10000226 	beq	r2,zero,2fdac <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   2fda4:	00bffd44 	movi	r2,-11
   2fda8:	00000b06 	br	2fdd8 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   2fdac:	e0bffe17 	ldw	r2,-8(fp)
   2fdb0:	10c00d17 	ldw	r3,52(r2)
   2fdb4:	e0bffe17 	ldw	r2,-8(fp)
   2fdb8:	10800c17 	ldw	r2,48(r2)
   2fdbc:	18800526 	beq	r3,r2,2fdd4 <altera_avalon_jtag_uart_close+0x54>
   2fdc0:	e0bffe17 	ldw	r2,-8(fp)
   2fdc4:	10c00917 	ldw	r3,36(r2)
   2fdc8:	e0bffe17 	ldw	r2,-8(fp)
   2fdcc:	10800117 	ldw	r2,4(r2)
   2fdd0:	18bff136 	bltu	r3,r2,2fd98 <__reset+0xfff8fd98>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   2fdd4:	0005883a 	mov	r2,zero
}
   2fdd8:	e037883a 	mov	sp,fp
   2fddc:	df000017 	ldw	fp,0(sp)
   2fde0:	dec00104 	addi	sp,sp,4
   2fde4:	f800283a 	ret

0002fde8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   2fde8:	defffa04 	addi	sp,sp,-24
   2fdec:	df000515 	stw	fp,20(sp)
   2fdf0:	df000504 	addi	fp,sp,20
   2fdf4:	e13ffd15 	stw	r4,-12(fp)
   2fdf8:	e17ffe15 	stw	r5,-8(fp)
   2fdfc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   2fe00:	00bff9c4 	movi	r2,-25
   2fe04:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   2fe08:	e0bffe17 	ldw	r2,-8(fp)
   2fe0c:	10da8060 	cmpeqi	r3,r2,27137
   2fe10:	1800031e 	bne	r3,zero,2fe20 <altera_avalon_jtag_uart_ioctl+0x38>
   2fe14:	109a80a0 	cmpeqi	r2,r2,27138
   2fe18:	1000181e 	bne	r2,zero,2fe7c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
   2fe1c:	00002906 	br	2fec4 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   2fe20:	e0bffd17 	ldw	r2,-12(fp)
   2fe24:	10c00117 	ldw	r3,4(r2)
   2fe28:	00a00034 	movhi	r2,32768
   2fe2c:	10bfffc4 	addi	r2,r2,-1
   2fe30:	18802126 	beq	r3,r2,2feb8 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
   2fe34:	e0bfff17 	ldw	r2,-4(fp)
   2fe38:	10800017 	ldw	r2,0(r2)
   2fe3c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   2fe40:	e0bffc17 	ldw	r2,-16(fp)
   2fe44:	10800090 	cmplti	r2,r2,2
   2fe48:	1000061e 	bne	r2,zero,2fe64 <altera_avalon_jtag_uart_ioctl+0x7c>
   2fe4c:	e0fffc17 	ldw	r3,-16(fp)
   2fe50:	00a00034 	movhi	r2,32768
   2fe54:	10bfffc4 	addi	r2,r2,-1
   2fe58:	18800226 	beq	r3,r2,2fe64 <altera_avalon_jtag_uart_ioctl+0x7c>
   2fe5c:	e0bffc17 	ldw	r2,-16(fp)
   2fe60:	00000206 	br	2fe6c <altera_avalon_jtag_uart_ioctl+0x84>
   2fe64:	00a00034 	movhi	r2,32768
   2fe68:	10bfff84 	addi	r2,r2,-2
   2fe6c:	e0fffd17 	ldw	r3,-12(fp)
   2fe70:	18800115 	stw	r2,4(r3)
      rc = 0;
   2fe74:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   2fe78:	00000f06 	br	2feb8 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   2fe7c:	e0bffd17 	ldw	r2,-12(fp)
   2fe80:	10c00117 	ldw	r3,4(r2)
   2fe84:	00a00034 	movhi	r2,32768
   2fe88:	10bfffc4 	addi	r2,r2,-1
   2fe8c:	18800c26 	beq	r3,r2,2fec0 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   2fe90:	e0bffd17 	ldw	r2,-12(fp)
   2fe94:	10c00917 	ldw	r3,36(r2)
   2fe98:	e0bffd17 	ldw	r2,-12(fp)
   2fe9c:	10800117 	ldw	r2,4(r2)
   2fea0:	1885803a 	cmpltu	r2,r3,r2
   2fea4:	10c03fcc 	andi	r3,r2,255
   2fea8:	e0bfff17 	ldw	r2,-4(fp)
   2feac:	10c00015 	stw	r3,0(r2)
      rc = 0;
   2feb0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   2feb4:	00000206 	br	2fec0 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   2feb8:	0001883a 	nop
   2febc:	00000106 	br	2fec4 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   2fec0:	0001883a 	nop

  default:
    break;
  }

  return rc;
   2fec4:	e0bffb17 	ldw	r2,-20(fp)
}
   2fec8:	e037883a 	mov	sp,fp
   2fecc:	df000017 	ldw	fp,0(sp)
   2fed0:	dec00104 	addi	sp,sp,4
   2fed4:	f800283a 	ret

0002fed8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   2fed8:	defff304 	addi	sp,sp,-52
   2fedc:	dfc00c15 	stw	ra,48(sp)
   2fee0:	df000b15 	stw	fp,44(sp)
   2fee4:	df000b04 	addi	fp,sp,44
   2fee8:	e13ffc15 	stw	r4,-16(fp)
   2feec:	e17ffd15 	stw	r5,-12(fp)
   2fef0:	e1bffe15 	stw	r6,-8(fp)
   2fef4:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   2fef8:	e0bffd17 	ldw	r2,-12(fp)
   2fefc:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   2ff00:	00004706 	br	30020 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   2ff04:	e0bffc17 	ldw	r2,-16(fp)
   2ff08:	10800a17 	ldw	r2,40(r2)
   2ff0c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
   2ff10:	e0bffc17 	ldw	r2,-16(fp)
   2ff14:	10800b17 	ldw	r2,44(r2)
   2ff18:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
   2ff1c:	e0fff717 	ldw	r3,-36(fp)
   2ff20:	e0bff817 	ldw	r2,-32(fp)
   2ff24:	18800536 	bltu	r3,r2,2ff3c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   2ff28:	e0fff717 	ldw	r3,-36(fp)
   2ff2c:	e0bff817 	ldw	r2,-32(fp)
   2ff30:	1885c83a 	sub	r2,r3,r2
   2ff34:	e0bff615 	stw	r2,-40(fp)
   2ff38:	00000406 	br	2ff4c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   2ff3c:	00c20004 	movi	r3,2048
   2ff40:	e0bff817 	ldw	r2,-32(fp)
   2ff44:	1885c83a 	sub	r2,r3,r2
   2ff48:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   2ff4c:	e0bff617 	ldw	r2,-40(fp)
   2ff50:	10001e26 	beq	r2,zero,2ffcc <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   2ff54:	e0fffe17 	ldw	r3,-8(fp)
   2ff58:	e0bff617 	ldw	r2,-40(fp)
   2ff5c:	1880022e 	bgeu	r3,r2,2ff68 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   2ff60:	e0bffe17 	ldw	r2,-8(fp)
   2ff64:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   2ff68:	e0bffc17 	ldw	r2,-16(fp)
   2ff6c:	10c00e04 	addi	r3,r2,56
   2ff70:	e0bff817 	ldw	r2,-32(fp)
   2ff74:	1885883a 	add	r2,r3,r2
   2ff78:	e1bff617 	ldw	r6,-40(fp)
   2ff7c:	100b883a 	mov	r5,r2
   2ff80:	e13ff517 	ldw	r4,-44(fp)
   2ff84:	002b6ac0 	call	2b6ac <memcpy>
      ptr   += n;
   2ff88:	e0fff517 	ldw	r3,-44(fp)
   2ff8c:	e0bff617 	ldw	r2,-40(fp)
   2ff90:	1885883a 	add	r2,r3,r2
   2ff94:	e0bff515 	stw	r2,-44(fp)
      space -= n;
   2ff98:	e0fffe17 	ldw	r3,-8(fp)
   2ff9c:	e0bff617 	ldw	r2,-40(fp)
   2ffa0:	1885c83a 	sub	r2,r3,r2
   2ffa4:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   2ffa8:	e0fff817 	ldw	r3,-32(fp)
   2ffac:	e0bff617 	ldw	r2,-40(fp)
   2ffb0:	1885883a 	add	r2,r3,r2
   2ffb4:	10c1ffcc 	andi	r3,r2,2047
   2ffb8:	e0bffc17 	ldw	r2,-16(fp)
   2ffbc:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   2ffc0:	e0bffe17 	ldw	r2,-8(fp)
   2ffc4:	00bfcf16 	blt	zero,r2,2ff04 <__reset+0xfff8ff04>
   2ffc8:	00000106 	br	2ffd0 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   2ffcc:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   2ffd0:	e0fff517 	ldw	r3,-44(fp)
   2ffd4:	e0bffd17 	ldw	r2,-12(fp)
   2ffd8:	1880141e 	bne	r3,r2,3002c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   2ffdc:	e0bfff17 	ldw	r2,-4(fp)
   2ffe0:	1090000c 	andi	r2,r2,16384
   2ffe4:	1000131e 	bne	r2,zero,30034 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   2ffe8:	0001883a 	nop
   2ffec:	e0bffc17 	ldw	r2,-16(fp)
   2fff0:	10c00a17 	ldw	r3,40(r2)
   2fff4:	e0bff717 	ldw	r2,-36(fp)
   2fff8:	1880051e 	bne	r3,r2,30010 <altera_avalon_jtag_uart_read+0x138>
   2fffc:	e0bffc17 	ldw	r2,-16(fp)
   30000:	10c00917 	ldw	r3,36(r2)
   30004:	e0bffc17 	ldw	r2,-16(fp)
   30008:	10800117 	ldw	r2,4(r2)
   3000c:	18bff736 	bltu	r3,r2,2ffec <__reset+0xfff8ffec>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   30010:	e0bffc17 	ldw	r2,-16(fp)
   30014:	10c00a17 	ldw	r3,40(r2)
   30018:	e0bff717 	ldw	r2,-36(fp)
   3001c:	18800726 	beq	r3,r2,3003c <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   30020:	e0bffe17 	ldw	r2,-8(fp)
   30024:	00bfb716 	blt	zero,r2,2ff04 <__reset+0xfff8ff04>
   30028:	00000506 	br	30040 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   3002c:	0001883a 	nop
   30030:	00000306 	br	30040 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   30034:	0001883a 	nop
   30038:	00000106 	br	30040 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   3003c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   30040:	e0fff517 	ldw	r3,-44(fp)
   30044:	e0bffd17 	ldw	r2,-12(fp)
   30048:	18801826 	beq	r3,r2,300ac <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3004c:	0005303a 	rdctl	r2,status
   30050:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   30054:	e0fffb17 	ldw	r3,-20(fp)
   30058:	00bfff84 	movi	r2,-2
   3005c:	1884703a 	and	r2,r3,r2
   30060:	1001703a 	wrctl	status,r2
  
  return context;
   30064:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   30068:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   3006c:	e0bffc17 	ldw	r2,-16(fp)
   30070:	10800817 	ldw	r2,32(r2)
   30074:	10c00054 	ori	r3,r2,1
   30078:	e0bffc17 	ldw	r2,-16(fp)
   3007c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   30080:	e0bffc17 	ldw	r2,-16(fp)
   30084:	10800017 	ldw	r2,0(r2)
   30088:	10800104 	addi	r2,r2,4
   3008c:	1007883a 	mov	r3,r2
   30090:	e0bffc17 	ldw	r2,-16(fp)
   30094:	10800817 	ldw	r2,32(r2)
   30098:	18800035 	stwio	r2,0(r3)
   3009c:	e0bffa17 	ldw	r2,-24(fp)
   300a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   300a4:	e0bff917 	ldw	r2,-28(fp)
   300a8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   300ac:	e0fff517 	ldw	r3,-44(fp)
   300b0:	e0bffd17 	ldw	r2,-12(fp)
   300b4:	18800426 	beq	r3,r2,300c8 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
   300b8:	e0fff517 	ldw	r3,-44(fp)
   300bc:	e0bffd17 	ldw	r2,-12(fp)
   300c0:	1885c83a 	sub	r2,r3,r2
   300c4:	00000606 	br	300e0 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
   300c8:	e0bfff17 	ldw	r2,-4(fp)
   300cc:	1090000c 	andi	r2,r2,16384
   300d0:	10000226 	beq	r2,zero,300dc <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
   300d4:	00bffd44 	movi	r2,-11
   300d8:	00000106 	br	300e0 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
   300dc:	00bffec4 	movi	r2,-5
}
   300e0:	e037883a 	mov	sp,fp
   300e4:	dfc00117 	ldw	ra,4(sp)
   300e8:	df000017 	ldw	fp,0(sp)
   300ec:	dec00204 	addi	sp,sp,8
   300f0:	f800283a 	ret

000300f4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   300f4:	defff304 	addi	sp,sp,-52
   300f8:	dfc00c15 	stw	ra,48(sp)
   300fc:	df000b15 	stw	fp,44(sp)
   30100:	df000b04 	addi	fp,sp,44
   30104:	e13ffc15 	stw	r4,-16(fp)
   30108:	e17ffd15 	stw	r5,-12(fp)
   3010c:	e1bffe15 	stw	r6,-8(fp)
   30110:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   30114:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   30118:	e0bffd17 	ldw	r2,-12(fp)
   3011c:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   30120:	00003706 	br	30200 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   30124:	e0bffc17 	ldw	r2,-16(fp)
   30128:	10800c17 	ldw	r2,48(r2)
   3012c:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
   30130:	e0bffc17 	ldw	r2,-16(fp)
   30134:	10800d17 	ldw	r2,52(r2)
   30138:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
   3013c:	e0fff917 	ldw	r3,-28(fp)
   30140:	e0bff517 	ldw	r2,-44(fp)
   30144:	1880062e 	bgeu	r3,r2,30160 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   30148:	e0fff517 	ldw	r3,-44(fp)
   3014c:	e0bff917 	ldw	r2,-28(fp)
   30150:	1885c83a 	sub	r2,r3,r2
   30154:	10bfffc4 	addi	r2,r2,-1
   30158:	e0bff615 	stw	r2,-40(fp)
   3015c:	00000b06 	br	3018c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   30160:	e0bff517 	ldw	r2,-44(fp)
   30164:	10000526 	beq	r2,zero,3017c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   30168:	00c20004 	movi	r3,2048
   3016c:	e0bff917 	ldw	r2,-28(fp)
   30170:	1885c83a 	sub	r2,r3,r2
   30174:	e0bff615 	stw	r2,-40(fp)
   30178:	00000406 	br	3018c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   3017c:	00c1ffc4 	movi	r3,2047
   30180:	e0bff917 	ldw	r2,-28(fp)
   30184:	1885c83a 	sub	r2,r3,r2
   30188:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   3018c:	e0bff617 	ldw	r2,-40(fp)
   30190:	10001e26 	beq	r2,zero,3020c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   30194:	e0fffe17 	ldw	r3,-8(fp)
   30198:	e0bff617 	ldw	r2,-40(fp)
   3019c:	1880022e 	bgeu	r3,r2,301a8 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   301a0:	e0bffe17 	ldw	r2,-8(fp)
   301a4:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   301a8:	e0bffc17 	ldw	r2,-16(fp)
   301ac:	10c20e04 	addi	r3,r2,2104
   301b0:	e0bff917 	ldw	r2,-28(fp)
   301b4:	1885883a 	add	r2,r3,r2
   301b8:	e1bff617 	ldw	r6,-40(fp)
   301bc:	e17ffd17 	ldw	r5,-12(fp)
   301c0:	1009883a 	mov	r4,r2
   301c4:	002b6ac0 	call	2b6ac <memcpy>
      ptr   += n;
   301c8:	e0fffd17 	ldw	r3,-12(fp)
   301cc:	e0bff617 	ldw	r2,-40(fp)
   301d0:	1885883a 	add	r2,r3,r2
   301d4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   301d8:	e0fffe17 	ldw	r3,-8(fp)
   301dc:	e0bff617 	ldw	r2,-40(fp)
   301e0:	1885c83a 	sub	r2,r3,r2
   301e4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   301e8:	e0fff917 	ldw	r3,-28(fp)
   301ec:	e0bff617 	ldw	r2,-40(fp)
   301f0:	1885883a 	add	r2,r3,r2
   301f4:	10c1ffcc 	andi	r3,r2,2047
   301f8:	e0bffc17 	ldw	r2,-16(fp)
   301fc:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   30200:	e0bffe17 	ldw	r2,-8(fp)
   30204:	00bfc716 	blt	zero,r2,30124 <__reset+0xfff90124>
   30208:	00000106 	br	30210 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   3020c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   30210:	0005303a 	rdctl	r2,status
   30214:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   30218:	e0fffb17 	ldw	r3,-20(fp)
   3021c:	00bfff84 	movi	r2,-2
   30220:	1884703a 	and	r2,r3,r2
   30224:	1001703a 	wrctl	status,r2
  
  return context;
   30228:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   3022c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   30230:	e0bffc17 	ldw	r2,-16(fp)
   30234:	10800817 	ldw	r2,32(r2)
   30238:	10c00094 	ori	r3,r2,2
   3023c:	e0bffc17 	ldw	r2,-16(fp)
   30240:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   30244:	e0bffc17 	ldw	r2,-16(fp)
   30248:	10800017 	ldw	r2,0(r2)
   3024c:	10800104 	addi	r2,r2,4
   30250:	1007883a 	mov	r3,r2
   30254:	e0bffc17 	ldw	r2,-16(fp)
   30258:	10800817 	ldw	r2,32(r2)
   3025c:	18800035 	stwio	r2,0(r3)
   30260:	e0bffa17 	ldw	r2,-24(fp)
   30264:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   30268:	e0bff817 	ldw	r2,-32(fp)
   3026c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   30270:	e0bffe17 	ldw	r2,-8(fp)
   30274:	0080100e 	bge	zero,r2,302b8 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
   30278:	e0bfff17 	ldw	r2,-4(fp)
   3027c:	1090000c 	andi	r2,r2,16384
   30280:	1000101e 	bne	r2,zero,302c4 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   30284:	0001883a 	nop
   30288:	e0bffc17 	ldw	r2,-16(fp)
   3028c:	10c00d17 	ldw	r3,52(r2)
   30290:	e0bff517 	ldw	r2,-44(fp)
   30294:	1880051e 	bne	r3,r2,302ac <altera_avalon_jtag_uart_write+0x1b8>
   30298:	e0bffc17 	ldw	r2,-16(fp)
   3029c:	10c00917 	ldw	r3,36(r2)
   302a0:	e0bffc17 	ldw	r2,-16(fp)
   302a4:	10800117 	ldw	r2,4(r2)
   302a8:	18bff736 	bltu	r3,r2,30288 <__reset+0xfff90288>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
   302ac:	e0bffc17 	ldw	r2,-16(fp)
   302b0:	10800917 	ldw	r2,36(r2)
   302b4:	1000051e 	bne	r2,zero,302cc <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
   302b8:	e0bffe17 	ldw	r2,-8(fp)
   302bc:	00bfd016 	blt	zero,r2,30200 <__reset+0xfff90200>
   302c0:	00000306 	br	302d0 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   302c4:	0001883a 	nop
   302c8:	00000106 	br	302d0 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
   302cc:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   302d0:	e0fffd17 	ldw	r3,-12(fp)
   302d4:	e0bff717 	ldw	r2,-36(fp)
   302d8:	18800426 	beq	r3,r2,302ec <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
   302dc:	e0fffd17 	ldw	r3,-12(fp)
   302e0:	e0bff717 	ldw	r2,-36(fp)
   302e4:	1885c83a 	sub	r2,r3,r2
   302e8:	00000606 	br	30304 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
   302ec:	e0bfff17 	ldw	r2,-4(fp)
   302f0:	1090000c 	andi	r2,r2,16384
   302f4:	10000226 	beq	r2,zero,30300 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
   302f8:	00bffd44 	movi	r2,-11
   302fc:	00000106 	br	30304 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   30300:	00bffec4 	movi	r2,-5
}
   30304:	e037883a 	mov	sp,fp
   30308:	dfc00117 	ldw	ra,4(sp)
   3030c:	df000017 	ldw	fp,0(sp)
   30310:	dec00204 	addi	sp,sp,8
   30314:	f800283a 	ret

00030318 <altera_avalon_mailbox_identify>:
 * Check an instance open match
 * with the callback register
 */

static void altera_avalon_mailbox_identify (altera_avalon_mailbox_dev *dev)
{
   30318:	defffd04 	addi	sp,sp,-12
   3031c:	df000215 	stw	fp,8(sp)
   30320:	df000204 	addi	fp,sp,8
   30324:	e13fff15 	stw	r4,-4(fp)
    /* Random signature to test mailbox ownership */
    alt_u32 magic_num = 0x3A11B045;
   30328:	008e84b4 	movhi	r2,14866
   3032c:	10ac1144 	addi	r2,r2,-20411
   30330:	e0bffe15 	stw	r2,-8(fp)

    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, magic_num);
   30334:	e0bfff17 	ldw	r2,-4(fp)
   30338:	10800a17 	ldw	r2,40(r2)
   3033c:	10800104 	addi	r2,r2,4
   30340:	1007883a 	mov	r3,r2
   30344:	e0bffe17 	ldw	r2,-8(fp)
   30348:	18800035 	stwio	r2,0(r3)
    if((IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST)) == magic_num)
   3034c:	e0bfff17 	ldw	r2,-4(fp)
   30350:	10800a17 	ldw	r2,40(r2)
   30354:	10800104 	addi	r2,r2,4
   30358:	10800037 	ldwio	r2,0(r2)
   3035c:	1007883a 	mov	r3,r2
   30360:	e0bffe17 	ldw	r2,-8(fp)
   30364:	1880081e 	bne	r3,r2,30388 <altera_avalon_mailbox_identify+0x70>
    {
        dev-> mbox_type = MBOX_TX;
   30368:	e0bfff17 	ldw	r2,-4(fp)
   3036c:	10000f15 	stw	zero,60(r2)
        /* Clear message_ptr to default */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, 0x0);
   30370:	e0bfff17 	ldw	r2,-4(fp)
   30374:	10800a17 	ldw	r2,40(r2)
   30378:	10800104 	addi	r2,r2,4
   3037c:	0007883a 	mov	r3,zero
   30380:	10c00035 	stwio	r3,0(r2)
    } else
    {
	    dev->mbox_type = MBOX_RX;
    }
}
   30384:	00000306 	br	30394 <altera_avalon_mailbox_identify+0x7c>
        dev-> mbox_type = MBOX_TX;
        /* Clear message_ptr to default */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, 0x0);
    } else
    {
	    dev->mbox_type = MBOX_RX;
   30388:	e0bfff17 	ldw	r2,-4(fp)
   3038c:	00c00044 	movi	r3,1
   30390:	10c00f15 	stw	r3,60(r2)
    }
}
   30394:	0001883a 	nop
   30398:	e037883a 	mov	sp,fp
   3039c:	df000017 	ldw	fp,0(sp)
   303a0:	dec00104 	addi	sp,sp,4
   303a4:	f800283a 	ret

000303a8 <altera_avalon_mailbox_post>:
/*
 *   altera_avalon_mailbox_post
 *   This function post message out through sender mailbox
 */
static alt_32 altera_avalon_mailbox_post (altera_avalon_mailbox_dev *dev,  void *message)
{
   303a8:	defffc04 	addi	sp,sp,-16
   303ac:	df000315 	stw	fp,12(sp)
   303b0:	df000304 	addi	fp,sp,12
   303b4:	e13ffe15 	stw	r4,-8(fp)
   303b8:	e17fff15 	stw	r5,-4(fp)
    alt_u32 *mbox_msg = (alt_u32*) message ;
   303bc:	e0bfff17 	ldw	r2,-4(fp)
   303c0:	e0bffd15 	stw	r2,-12(fp)

    if (mbox_msg != NULL) {
   303c4:	e0bffd17 	ldw	r2,-12(fp)
   303c8:	10001026 	beq	r2,zero,3040c <altera_avalon_mailbox_post+0x64>
        /* When message space available, post the message out */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, mbox_msg[1]);
   303cc:	e0bffe17 	ldw	r2,-8(fp)
   303d0:	10800a17 	ldw	r2,40(r2)
   303d4:	10800104 	addi	r2,r2,4
   303d8:	1007883a 	mov	r3,r2
   303dc:	e0bffd17 	ldw	r2,-12(fp)
   303e0:	10800104 	addi	r2,r2,4
   303e4:	10800017 	ldw	r2,0(r2)
   303e8:	18800035 	stwio	r2,0(r3)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, mbox_msg[0]);
   303ec:	e0bffe17 	ldw	r2,-8(fp)
   303f0:	10800a17 	ldw	r2,40(r2)
   303f4:	1007883a 	mov	r3,r2
   303f8:	e0bffd17 	ldw	r2,-12(fp)
   303fc:	10800017 	ldw	r2,0(r2)
   30400:	18800035 	stwio	r2,0(r3)
        return 0;
   30404:	0005883a 	mov	r2,zero
   30408:	00000106 	br	30410 <altera_avalon_mailbox_post+0x68>
    }
    /* Invalid NULL message received */
    return -EINVAL;
   3040c:	00bffa84 	movi	r2,-22
}
   30410:	e037883a 	mov	sp,fp
   30414:	df000017 	ldw	fp,0(sp)
   30418:	dec00104 	addi	sp,sp,4
   3041c:	f800283a 	ret

00030420 <altera_avalon_mailbox_simple_tx_isr>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_tx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_tx_isr(void *context, alt_u32 id)
#endif
{
   30420:	defff504 	addi	sp,sp,-44
   30424:	dfc00a15 	stw	ra,40(sp)
   30428:	df000915 	stw	fp,36(sp)
   3042c:	df000904 	addi	fp,sp,36
   30430:	e13ffe15 	stw	r4,-8(fp)
   30434:	e17fff15 	stw	r5,-4(fp)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
   30438:	e0bffe17 	ldw	r2,-8(fp)
   3043c:	e0bff715 	stw	r2,-36(fp)
    int status = 0;
   30440:	e03ff815 	stw	zero,-32(fp)
    alt_u32 data;
    alt_irq_context cpu_sr;
    alt_u32 *message = dev->mbox_msg;
   30444:	e0bff717 	ldw	r2,-36(fp)
   30448:	10801017 	ldw	r2,64(r2)
   3044c:	e0bff915 	stw	r2,-28(fp)

    /* Mask mailbox interrupt */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
   30450:	e0bff717 	ldw	r2,-36(fp)
   30454:	10800a17 	ldw	r2,40(r2)
   30458:	10800304 	addi	r2,r2,12
   3045c:	10800037 	ldwio	r2,0(r2)
   30460:	1007883a 	mov	r3,r2
   30464:	00bfff44 	movi	r2,-3
   30468:	1884703a 	and	r2,r3,r2
   3046c:	e0bffa15 	stw	r2,-24(fp)
               (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   30470:	e0bff717 	ldw	r2,-36(fp)
   30474:	10800a17 	ldw	r2,40(r2)
   30478:	10800304 	addi	r2,r2,12
   3047c:	1007883a 	mov	r3,r2
   30480:	e0bffa17 	ldw	r2,-24(fp)
   30484:	18800035 	stwio	r2,0(r3)

    if (message != NULL)
   30488:	e0bff917 	ldw	r2,-28(fp)
   3048c:	10002d26 	beq	r2,zero,30544 <altera_avalon_mailbox_simple_tx_isr+0x124>
    {
        /* Post out message requested */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, message[1]);
   30490:	e0bff717 	ldw	r2,-36(fp)
   30494:	10800a17 	ldw	r2,40(r2)
   30498:	10800104 	addi	r2,r2,4
   3049c:	1007883a 	mov	r3,r2
   304a0:	e0bff917 	ldw	r2,-28(fp)
   304a4:	10800104 	addi	r2,r2,4
   304a8:	10800017 	ldw	r2,0(r2)
   304ac:	18800035 	stwio	r2,0(r3)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, message[0]);
   304b0:	e0bff717 	ldw	r2,-36(fp)
   304b4:	10800a17 	ldw	r2,40(r2)
   304b8:	1007883a 	mov	r3,r2
   304bc:	e0bff917 	ldw	r2,-28(fp)
   304c0:	10800017 	ldw	r2,0(r2)
   304c4:	18800035 	stwio	r2,0(r3)
    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
   304c8:	e0bff717 	ldw	r2,-36(fp)
   304cc:	10800a17 	ldw	r2,40(r2)
   304d0:	10800204 	addi	r2,r2,8
   304d4:	10800037 	ldwio	r2,0(r2)
        		  & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
   304d8:	1080008c 	andi	r2,r2,2
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, message[0]);
    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
   304dc:	1005d07a 	srai	r2,r2,1
   304e0:	e0bff815 	stw	r2,-32(fp)
        		  & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
        if (dev->tx_cb)
   304e4:	e0bff717 	ldw	r2,-36(fp)
   304e8:	10800d17 	ldw	r2,52(r2)
   304ec:	10001126 	beq	r2,zero,30534 <altera_avalon_mailbox_simple_tx_isr+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   304f0:	0005303a 	rdctl	r2,status
   304f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   304f8:	e0fffc17 	ldw	r3,-16(fp)
   304fc:	00bfff84 	movi	r2,-2
   30500:	1884703a 	and	r2,r3,r2
   30504:	1001703a 	wrctl	status,r2
  
  return context;
   30508:	e0bffc17 	ldw	r2,-16(fp)
        {
            cpu_sr = alt_irq_disable_all();
   3050c:	e0bffb15 	stw	r2,-20(fp)
  	        (dev->tx_cb)(message, status);
   30510:	e0bff717 	ldw	r2,-36(fp)
   30514:	10800d17 	ldw	r2,52(r2)
   30518:	e17ff817 	ldw	r5,-32(fp)
   3051c:	e13ff917 	ldw	r4,-28(fp)
   30520:	103ee83a 	callr	r2
   30524:	e0bffb17 	ldw	r2,-20(fp)
   30528:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   3052c:	e0bffd17 	ldw	r2,-12(fp)
   30530:	1001703a 	wrctl	status,r2
            alt_irq_enable_all(cpu_sr);
        }
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
   30534:	e0bff717 	ldw	r2,-36(fp)
   30538:	10001015 	stw	zero,64(r2)
        dev->lock = 0;
   3053c:	e0bff717 	ldw	r2,-36(fp)
   30540:	10001105 	stb	zero,68(r2)
    }
}
   30544:	0001883a 	nop
   30548:	e037883a 	mov	sp,fp
   3054c:	dfc00117 	ldw	ra,4(sp)
   30550:	df000017 	ldw	fp,0(sp)
   30554:	dec00204 	addi	sp,sp,8
   30558:	f800283a 	ret

0003055c <altera_avalon_mailbox_simple_rx_isr>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_rx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_rx_isr(void *context, alt_u32 id)
#endif
{
   3055c:	defff604 	addi	sp,sp,-40
   30560:	dfc00915 	stw	ra,36(sp)
   30564:	df000815 	stw	fp,32(sp)
   30568:	df000804 	addi	fp,sp,32
   3056c:	e13ffe15 	stw	r4,-8(fp)
   30570:	e17fff15 	stw	r5,-4(fp)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
   30574:	e0bffe17 	ldw	r2,-8(fp)
   30578:	e0bff815 	stw	r2,-32(fp)
    alt_irq_context cpu_sr;
    alt_u32 inbox[2];

    inbox[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
   3057c:	e0bff817 	ldw	r2,-32(fp)
   30580:	10800a17 	ldw	r2,40(r2)
   30584:	10800104 	addi	r2,r2,4
   30588:	10800037 	ldwio	r2,0(r2)
   3058c:	e0bffd15 	stw	r2,-12(fp)
    inbox[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
   30590:	e0bff817 	ldw	r2,-32(fp)
   30594:	10800a17 	ldw	r2,40(r2)
   30598:	10800037 	ldwio	r2,0(r2)
   3059c:	e0bffc15 	stw	r2,-16(fp)

    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
    if (dev->rx_cb)
   305a0:	e0bff817 	ldw	r2,-32(fp)
   305a4:	10800e17 	ldw	r2,56(r2)
   305a8:	10001126 	beq	r2,zero,305f0 <altera_avalon_mailbox_simple_rx_isr+0x94>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   305ac:	0005303a 	rdctl	r2,status
   305b0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   305b4:	e0fffa17 	ldw	r3,-24(fp)
   305b8:	00bfff84 	movi	r2,-2
   305bc:	1884703a 	and	r2,r3,r2
   305c0:	1001703a 	wrctl	status,r2
  
  return context;
   305c4:	e0bffa17 	ldw	r2,-24(fp)
    {
        cpu_sr = alt_irq_disable_all();
   305c8:	e0bff915 	stw	r2,-28(fp)
        (dev->rx_cb)(inbox);
   305cc:	e0bff817 	ldw	r2,-32(fp)
   305d0:	10800e17 	ldw	r2,56(r2)
   305d4:	e0fffc04 	addi	r3,fp,-16
   305d8:	1809883a 	mov	r4,r3
   305dc:	103ee83a 	callr	r2
   305e0:	e0bff917 	ldw	r2,-28(fp)
   305e4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   305e8:	e0bffb17 	ldw	r2,-20(fp)
   305ec:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }
}
   305f0:	0001883a 	nop
   305f4:	e037883a 	mov	sp,fp
   305f8:	dfc00117 	ldw	ra,4(sp)
   305fc:	df000017 	ldw	fp,0(sp)
   30600:	dec00204 	addi	sp,sp,8
   30604:	f800283a 	ret

00030608 <altera_avalon_mailbox_simple_init>:
 * Altera avalon mailbox init
 * Initialize mailbox device and identify sender/receiver mailbox
 */
void altera_avalon_mailbox_simple_init (altera_avalon_mailbox_dev *dev,
		                               int intr_id, int irq)
{
   30608:	defffb04 	addi	sp,sp,-20
   3060c:	dfc00415 	stw	ra,16(sp)
   30610:	df000315 	stw	fp,12(sp)
   30614:	df000304 	addi	fp,sp,12
   30618:	e13ffd15 	stw	r4,-12(fp)
   3061c:	e17ffe15 	stw	r5,-8(fp)
   30620:	e1bfff15 	stw	r6,-4(fp)
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mailbox_simple_list);
   30624:	d1601204 	addi	r5,gp,-32696
   30628:	e13ffd17 	ldw	r4,-12(fp)
   3062c:	0031c1c0 	call	31c1c <alt_dev_llist_insert>
    
    dev->mailbox_irq    = irq;
   30630:	e0ffff17 	ldw	r3,-4(fp)
   30634:	e0bffd17 	ldw	r2,-12(fp)
   30638:	10c00b15 	stw	r3,44(r2)
    dev->mailbox_intr_ctrl_id = intr_id;
   3063c:	e0fffe17 	ldw	r3,-8(fp)
   30640:	e0bffd17 	ldw	r2,-12(fp)
   30644:	10c00c15 	stw	r3,48(r2)
    dev->rx_cb = NULL;
   30648:	e0bffd17 	ldw	r2,-12(fp)
   3064c:	10000e15 	stw	zero,56(r2)
    dev->tx_cb = NULL;
   30650:	e0bffd17 	ldw	r2,-12(fp)
   30654:	10000d15 	stw	zero,52(r2)
    dev->mbox_msg = NULL;
   30658:	e0bffd17 	ldw	r2,-12(fp)
   3065c:	10001015 	stw	zero,64(r2)
    
    ALT_SEM_CREATE (&dev->write_lock, 1);

    altera_avalon_mailbox_identify(dev);
   30660:	e13ffd17 	ldw	r4,-12(fp)
   30664:	00303180 	call	30318 <altera_avalon_mailbox_identify>
}
   30668:	0001883a 	nop
   3066c:	e037883a 	mov	sp,fp
   30670:	dfc00117 	ldw	ra,4(sp)
   30674:	df000017 	ldw	fp,0(sp)
   30678:	dec00204 	addi	sp,sp,8
   3067c:	f800283a 	ret

00030680 <altera_avalon_mailbox_open>:
 * Search the list of registered mailboxes for one with the supplied name.
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
altera_avalon_mailbox_dev* altera_avalon_mailbox_open (const char *name,
		altera_mailbox_tx_cb tx_callback, altera_mailbox_rx_cb rx_callback)
{
   30680:	defff904 	addi	sp,sp,-28
   30684:	dfc00615 	stw	ra,24(sp)
   30688:	df000515 	stw	fp,20(sp)
   3068c:	df000504 	addi	fp,sp,20
   30690:	e13ffd15 	stw	r4,-12(fp)
   30694:	e17ffe15 	stw	r5,-8(fp)
   30698:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_mailbox_dev *dev;
    alt_u32 data;

    /* Find requested device */
    dev = (altera_avalon_mailbox_dev*) alt_find_dev (name, &alt_mailbox_simple_list);
   3069c:	d1601204 	addi	r5,gp,-32696
   306a0:	e13ffd17 	ldw	r4,-12(fp)
   306a4:	0031d800 	call	31d80 <alt_find_dev>
   306a8:	e0bffb15 	stw	r2,-20(fp)
    if (dev == NULL)
   306ac:	e0bffb17 	ldw	r2,-20(fp)
   306b0:	1000021e 	bne	r2,zero,306bc <altera_avalon_mailbox_open+0x3c>
    {
        return NULL;
   306b4:	0005883a 	mov	r2,zero
   306b8:	00005d06 	br	30830 <altera_avalon_mailbox_open+0x1b0>
    }

    /* Mask mailbox interrupt before ISR is being registered. */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
   306bc:	e0bffb17 	ldw	r2,-20(fp)
   306c0:	10800a17 	ldw	r2,40(r2)
   306c4:	10800304 	addi	r2,r2,12
   306c8:	10800037 	ldwio	r2,0(r2)
   306cc:	e0bffc15 	stw	r2,-16(fp)
    if (dev->mbox_type == MBOX_TX) {
   306d0:	e0bffb17 	ldw	r2,-20(fp)
   306d4:	10800f17 	ldw	r2,60(r2)
   306d8:	1000081e 	bne	r2,zero,306fc <altera_avalon_mailbox_open+0x7c>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
   306dc:	e0bffb17 	ldw	r2,-20(fp)
   306e0:	10800a17 	ldw	r2,40(r2)
   306e4:	10800304 	addi	r2,r2,12
   306e8:	1009883a 	mov	r4,r2
   306ec:	e0fffc17 	ldw	r3,-16(fp)
   306f0:	00bfff44 	movi	r2,-3
   306f4:	1884703a 	and	r2,r3,r2
   306f8:	20800035 	stwio	r2,0(r4)
            (data & ~(ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK)));
    }
    if (dev->mbox_type == MBOX_RX) {
   306fc:	e0bffb17 	ldw	r2,-20(fp)
   30700:	10800f17 	ldw	r2,60(r2)
   30704:	10800058 	cmpnei	r2,r2,1
   30708:	1000081e 	bne	r2,zero,3072c <altera_avalon_mailbox_open+0xac>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
   3070c:	e0bffb17 	ldw	r2,-20(fp)
   30710:	10800a17 	ldw	r2,40(r2)
   30714:	10800304 	addi	r2,r2,12
   30718:	1009883a 	mov	r4,r2
   3071c:	e0fffc17 	ldw	r3,-16(fp)
   30720:	00bfff84 	movi	r2,-2
   30724:	1884703a 	and	r2,r3,r2
   30728:	20800035 	stwio	r2,0(r4)
    }

    /* If IRQ not connected, return device pointer without ISR register,
     * in polling mode.
     */
    if (dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED)
   3072c:	e0bffb17 	ldw	r2,-20(fp)
   30730:	10800b17 	ldw	r2,44(r2)
   30734:	10bfffd8 	cmpnei	r2,r2,-1
   30738:	1000021e 	bne	r2,zero,30744 <altera_avalon_mailbox_open+0xc4>
        return dev;
   3073c:	e0bffb17 	ldw	r2,-20(fp)
   30740:	00003b06 	br	30830 <altera_avalon_mailbox_open+0x1b0>

    /* For IRQ connected case */

    if ((tx_callback == NULL) && (rx_callback == NULL))
   30744:	e0bffe17 	ldw	r2,-8(fp)
   30748:	1000041e 	bne	r2,zero,3075c <altera_avalon_mailbox_open+0xdc>
   3074c:	e0bfff17 	ldw	r2,-4(fp)
   30750:	1000021e 	bne	r2,zero,3075c <altera_avalon_mailbox_open+0xdc>
    {
    /* No callback, polling mode */
        return dev;
   30754:	e0bffb17 	ldw	r2,-20(fp)
   30758:	00003506 	br	30830 <altera_avalon_mailbox_open+0x1b0>
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
   3075c:	e0bffb17 	ldw	r2,-20(fp)
   30760:	10800f17 	ldw	r2,60(r2)
   30764:	1000021e 	bne	r2,zero,30770 <altera_avalon_mailbox_open+0xf0>
   30768:	e0bfff17 	ldw	r2,-4(fp)
   3076c:	1000061e 	bne	r2,zero,30788 <altera_avalon_mailbox_open+0x108>
	    ((dev->mbox_type == MBOX_RX) && (tx_callback != NULL)))
   30770:	e0bffb17 	ldw	r2,-20(fp)
   30774:	10800f17 	ldw	r2,60(r2)
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
   30778:	10800058 	cmpnei	r2,r2,1
   3077c:	1000041e 	bne	r2,zero,30790 <altera_avalon_mailbox_open+0x110>
	    ((dev->mbox_type == MBOX_RX) && (tx_callback != NULL)))
   30780:	e0bffe17 	ldw	r2,-8(fp)
   30784:	10000226 	beq	r2,zero,30790 <altera_avalon_mailbox_open+0x110>
  	  /* Invalid callback  */
        return NULL;
   30788:	0005883a 	mov	r2,zero
   3078c:	00002806 	br	30830 <altera_avalon_mailbox_open+0x1b0>

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
   30790:	e0bffb17 	ldw	r2,-20(fp)
   30794:	e0fffe17 	ldw	r3,-8(fp)
   30798:	10c00d15 	stw	r3,52(r2)
    dev->rx_cb  = rx_callback;
   3079c:	e0bffb17 	ldw	r2,-20(fp)
   307a0:	e0ffff17 	ldw	r3,-4(fp)
   307a4:	10c00e15 	stw	r3,56(r2)

    /* Register Mailbox's ISR */
    if (dev->mbox_type == MBOX_TX)
   307a8:	e0bffb17 	ldw	r2,-20(fp)
   307ac:	10800f17 	ldw	r2,60(r2)
   307b0:	1000071e 	bne	r2,zero,307d0 <altera_avalon_mailbox_open+0x150>
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_tx_isr,
                            dev, NULL);
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_tx_isr);
   307b4:	e0bffb17 	ldw	r2,-20(fp)
   307b8:	10800b17 	ldw	r2,44(r2)
   307bc:	018000f4 	movhi	r6,3
   307c0:	31810804 	addi	r6,r6,1056
   307c4:	e17ffb17 	ldw	r5,-20(fp)
   307c8:	1009883a 	mov	r4,r2
   307cc:	0020f9c0 	call	20f9c <alt_irq_register>
    #endif
    }
  
    if (dev->mbox_type == MBOX_RX)
   307d0:	e0bffb17 	ldw	r2,-20(fp)
   307d4:	10800f17 	ldw	r2,60(r2)
   307d8:	10800058 	cmpnei	r2,r2,1
   307dc:	1000131e 	bne	r2,zero,3082c <altera_avalon_mailbox_open+0x1ac>
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_rx_isr,
                            dev, NULL);
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_rx_isr);
   307e0:	e0bffb17 	ldw	r2,-20(fp)
   307e4:	10800b17 	ldw	r2,44(r2)
   307e8:	018000f4 	movhi	r6,3
   307ec:	31815704 	addi	r6,r6,1372
   307f0:	e17ffb17 	ldw	r5,-20(fp)
   307f4:	1009883a 	mov	r4,r2
   307f8:	0020f9c0 	call	20f9c <alt_irq_register>
    #endif
        /* Enable Receiver interrupt to listen mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
   307fc:	e0bffb17 	ldw	r2,-20(fp)
   30800:	10800a17 	ldw	r2,40(r2)
   30804:	10800304 	addi	r2,r2,12
   30808:	10800037 	ldwio	r2,0(r2)
   3080c:	10800054 	ori	r2,r2,1
   30810:	e0bffc15 	stw	r2,-16(fp)
  	             (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   30814:	e0bffb17 	ldw	r2,-20(fp)
   30818:	10800a17 	ldw	r2,40(r2)
   3081c:	10800304 	addi	r2,r2,12
   30820:	1007883a 	mov	r3,r2
   30824:	e0bffc17 	ldw	r2,-16(fp)
   30828:	18800035 	stwio	r2,0(r3)
    }
    return dev;
   3082c:	e0bffb17 	ldw	r2,-20(fp)
}
   30830:	e037883a 	mov	sp,fp
   30834:	dfc00117 	ldw	ra,4(sp)
   30838:	df000017 	ldw	fp,0(sp)
   3083c:	dec00204 	addi	sp,sp,8
   30840:	f800283a 	ret

00030844 <altera_avalon_mailbox_close>:
/*
 * altera_avalon_mailbox_close
 * Disable mailbox interrupt and irq
 */
void altera_avalon_mailbox_close (altera_avalon_mailbox_dev *dev)
{
   30844:	defffc04 	addi	sp,sp,-16
   30848:	dfc00315 	stw	ra,12(sp)
   3084c:	df000215 	stw	fp,8(sp)
   30850:	df000204 	addi	fp,sp,8
   30854:	e13fff15 	stw	r4,-4(fp)
    alt_u32 data;
    if ((dev != NULL) && (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED))
   30858:	e0bfff17 	ldw	r2,-4(fp)
   3085c:	10003526 	beq	r2,zero,30934 <altera_avalon_mailbox_close+0xf0>
   30860:	e0bfff17 	ldw	r2,-4(fp)
   30864:	10800b17 	ldw	r2,44(r2)
   30868:	10bfffe0 	cmpeqi	r2,r2,-1
   3086c:	1000311e 	bne	r2,zero,30934 <altera_avalon_mailbox_close+0xf0>
    {
        /* Mask interrupt */
        if (dev->mbox_type == MBOX_TX)
   30870:	e0bfff17 	ldw	r2,-4(fp)
   30874:	10800f17 	ldw	r2,60(r2)
   30878:	10000e1e 	bne	r2,zero,308b4 <altera_avalon_mailbox_close+0x70>
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
   3087c:	e0bfff17 	ldw	r2,-4(fp)
   30880:	10800a17 	ldw	r2,40(r2)
   30884:	10800304 	addi	r2,r2,12
   30888:	10800037 	ldwio	r2,0(r2)
   3088c:	1007883a 	mov	r3,r2
   30890:	00bfff44 	movi	r2,-3
   30894:	1884703a 	and	r2,r3,r2
   30898:	e0bffe15 	stw	r2,-8(fp)
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   3089c:	e0bfff17 	ldw	r2,-4(fp)
   308a0:	10800a17 	ldw	r2,40(r2)
   308a4:	10800304 	addi	r2,r2,12
   308a8:	1007883a 	mov	r3,r2
   308ac:	e0bffe17 	ldw	r2,-8(fp)
   308b0:	18800035 	stwio	r2,0(r3)
        }
        if (dev->mbox_type == MBOX_RX)
   308b4:	e0bfff17 	ldw	r2,-4(fp)
   308b8:	10800f17 	ldw	r2,60(r2)
   308bc:	10800058 	cmpnei	r2,r2,1
   308c0:	10000e1e 	bne	r2,zero,308fc <altera_avalon_mailbox_close+0xb8>
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
   308c4:	e0bfff17 	ldw	r2,-4(fp)
   308c8:	10800a17 	ldw	r2,40(r2)
   308cc:	10800304 	addi	r2,r2,12
   308d0:	10800037 	ldwio	r2,0(r2)
   308d4:	1007883a 	mov	r3,r2
   308d8:	00bfff84 	movi	r2,-2
   308dc:	1884703a 	and	r2,r3,r2
   308e0:	e0bffe15 	stw	r2,-8(fp)
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   308e4:	e0bfff17 	ldw	r2,-4(fp)
   308e8:	10800a17 	ldw	r2,40(r2)
   308ec:	10800304 	addi	r2,r2,12
   308f0:	1007883a 	mov	r3,r2
   308f4:	e0bffe17 	ldw	r2,-8(fp)
   308f8:	18800035 	stwio	r2,0(r3)
        }
  
        /* De-register mailbox irq) */
        if (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED)
   308fc:	e0bfff17 	ldw	r2,-4(fp)
   30900:	10800b17 	ldw	r2,44(r2)
   30904:	10bfffe0 	cmpeqi	r2,r2,-1
   30908:	1000061e 	bne	r2,zero,30924 <altera_avalon_mailbox_close+0xe0>
        {
        #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
            alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, NULL,
                              dev, NULL);
        #else
            alt_irq_register(dev->mailbox_irq, dev, NULL);
   3090c:	e0bfff17 	ldw	r2,-4(fp)
   30910:	10800b17 	ldw	r2,44(r2)
   30914:	000d883a 	mov	r6,zero
   30918:	e17fff17 	ldw	r5,-4(fp)
   3091c:	1009883a 	mov	r4,r2
   30920:	0020f9c0 	call	20f9c <alt_irq_register>
        #endif
        }
        /* De-registering callback to mailbox */
        dev->tx_cb  = NULL;
   30924:	e0bfff17 	ldw	r2,-4(fp)
   30928:	10000d15 	stw	zero,52(r2)
        dev->rx_cb  = NULL;
   3092c:	e0bfff17 	ldw	r2,-4(fp)
   30930:	10000e15 	stw	zero,56(r2)
    }
}
   30934:	0001883a 	nop
   30938:	e037883a 	mov	sp,fp
   3093c:	dfc00117 	ldw	ra,4(sp)
   30940:	df000017 	ldw	fp,0(sp)
   30944:	dec00204 	addi	sp,sp,8
   30948:	f800283a 	ret

0003094c <altera_avalon_mailbox_status>:
 *   Return 0 when mailbox is empty or no pending message
 *   Return 1 when mailbox space is full or there is a message pending
 */

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
   3094c:	defffd04 	addi	sp,sp,-12
   30950:	df000215 	stw	fp,8(sp)
   30954:	df000204 	addi	fp,sp,8
   30958:	e13fff15 	stw	r4,-4(fp)
    alt_u32 mailbox_sts = 0;
   3095c:	e03ffe15 	stw	zero,-8(fp)

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
   30960:	e0bfff17 	ldw	r2,-4(fp)
   30964:	10800a17 	ldw	r2,40(r2)
   30968:	10800204 	addi	r2,r2,8
   3096c:	10800037 	ldwio	r2,0(r2)
   30970:	108000cc 	andi	r2,r2,3
   30974:	e0bffe15 	stw	r2,-8(fp)

    if (dev->mbox_type == MBOX_TX)
   30978:	e0bfff17 	ldw	r2,-4(fp)
   3097c:	10800f17 	ldw	r2,60(r2)
   30980:	1000041e 	bne	r2,zero,30994 <altera_avalon_mailbox_status+0x48>
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
   30984:	e0bffe17 	ldw	r2,-8(fp)
   30988:	1080008c 	andi	r2,r2,2
   3098c:	1004d07a 	srli	r2,r2,1
   30990:	e0bffe15 	stw	r2,-8(fp)

    if (dev->mbox_type == MBOX_RX)
   30994:	e0bfff17 	ldw	r2,-4(fp)
   30998:	10800f17 	ldw	r2,60(r2)
   3099c:	10800058 	cmpnei	r2,r2,1
   309a0:	1000031e 	bne	r2,zero,309b0 <altera_avalon_mailbox_status+0x64>
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
   309a4:	e0bffe17 	ldw	r2,-8(fp)
   309a8:	1080004c 	andi	r2,r2,1
   309ac:	e0bffe15 	stw	r2,-8(fp)

    return mailbox_sts;
   309b0:	e0bffe17 	ldw	r2,-8(fp)
}
   309b4:	e037883a 	mov	sp,fp
   309b8:	df000017 	ldw	fp,0(sp)
   309bc:	dec00104 	addi	sp,sp,4
   309c0:	f800283a 	ret

000309c4 <altera_avalon_mailbox_send>:
 * For polling mode, '0' timeout value for infinite polling
 * otherwise timeout when expired
 */
int altera_avalon_mailbox_send
(altera_avalon_mailbox_dev *dev, void *message, int timeout, EventType event)
{
   309c4:	defff704 	addi	sp,sp,-36
   309c8:	dfc00815 	stw	ra,32(sp)
   309cc:	df000715 	stw	fp,28(sp)
   309d0:	df000704 	addi	fp,sp,28
   309d4:	e13ffc15 	stw	r4,-16(fp)
   309d8:	e17ffd15 	stw	r5,-12(fp)
   309dc:	e1bffe15 	stw	r6,-8(fp)
   309e0:	e1ffff15 	stw	r7,-4(fp)
    int status = 0;
   309e4:	e03ff915 	stw	zero,-28(fp)
     * Obtain the "write_lock"semaphore to ensures 
     * that writing to the device is thread-safe in multi-thread enviroment
     */
    ALT_SEM_PEND (dev->write_lock, 0);

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
   309e8:	e0bffc17 	ldw	r2,-16(fp)
   309ec:	10801103 	ldbu	r2,68(r2)
   309f0:	10803fcc 	andi	r2,r2,255
   309f4:	1000061e 	bne	r2,zero,30a10 <altera_avalon_mailbox_send+0x4c>
   309f8:	e0bffc17 	ldw	r2,-16(fp)
   309fc:	10800a17 	ldw	r2,40(r2)
   30a00:	10800204 	addi	r2,r2,8
   30a04:	10800037 	ldwio	r2,0(r2)
    		          & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK))
   30a08:	1080008c 	andi	r2,r2,2
     * Obtain the "write_lock"semaphore to ensures 
     * that writing to the device is thread-safe in multi-thread enviroment
     */
    ALT_SEM_PEND (dev->write_lock, 0);

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
   30a0c:	10000226 	beq	r2,zero,30a18 <altera_avalon_mailbox_send+0x54>
    		          & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK))
    {
    	/* dev is lock or no free space to send */
    	return -1;
   30a10:	00bfffc4 	movi	r2,-1
   30a14:	00003a06 	br	30b00 <altera_avalon_mailbox_send+0x13c>
    }
    else
    {
        dev->mbox_msg = message;
   30a18:	e0bffc17 	ldw	r2,-16(fp)
   30a1c:	e0fffd17 	ldw	r3,-12(fp)
   30a20:	10c01015 	stw	r3,64(r2)
        dev->lock = 1;
   30a24:	e0bffc17 	ldw	r2,-16(fp)
   30a28:	00c00044 	movi	r3,1
   30a2c:	10c01105 	stb	r3,68(r2)
     */
    ALT_SEM_POST (dev->write_lock);



    if ((dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED) || (event==POLL))
   30a30:	e0bffc17 	ldw	r2,-16(fp)
   30a34:	10800b17 	ldw	r2,44(r2)
   30a38:	10bfffe0 	cmpeqi	r2,r2,-1
   30a3c:	1000031e 	bne	r2,zero,30a4c <altera_avalon_mailbox_send+0x88>
   30a40:	e0bfff17 	ldw	r2,-4(fp)
   30a44:	10800058 	cmpnei	r2,r2,1
   30a48:	1000201e 	bne	r2,zero,30acc <altera_avalon_mailbox_send+0x108>
    {
        /* Polling mode */
        if (timeout ==0)
   30a4c:	e0bffe17 	ldw	r2,-8(fp)
   30a50:	1000061e 	bne	r2,zero,30a6c <altera_avalon_mailbox_send+0xa8>
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
   30a54:	e13ffc17 	ldw	r4,-16(fp)
   30a58:	003094c0 	call	3094c <altera_avalon_mailbox_status>
   30a5c:	e0bffb15 	stw	r2,-20(fp)
            } while (mbox_status);
   30a60:	e0bffb17 	ldw	r2,-20(fp)
   30a64:	103ffb1e 	bne	r2,zero,30a54 <__reset+0xfff90a54>
   30a68:	00000e06 	br	30aa4 <altera_avalon_mailbox_send+0xe0>
        } else
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
   30a6c:	e13ffc17 	ldw	r4,-16(fp)
   30a70:	003094c0 	call	3094c <altera_avalon_mailbox_status>
   30a74:	e0bffb15 	stw	r2,-20(fp)
                timeout--;
   30a78:	e0bffe17 	ldw	r2,-8(fp)
   30a7c:	10bfffc4 	addi	r2,r2,-1
   30a80:	e0bffe15 	stw	r2,-8(fp)
            } while (mbox_status && (timeout != 0));
   30a84:	e0bffb17 	ldw	r2,-20(fp)
   30a88:	10000226 	beq	r2,zero,30a94 <altera_avalon_mailbox_send+0xd0>
   30a8c:	e0bffe17 	ldw	r2,-8(fp)
   30a90:	103ff61e 	bne	r2,zero,30a6c <__reset+0xfff90a6c>
            if (timeout == 0)
   30a94:	e0bffe17 	ldw	r2,-8(fp)
   30a98:	1000021e 	bne	r2,zero,30aa4 <altera_avalon_mailbox_send+0xe0>
            {    /* Timeout occur or fail sending */
                return -ETIME;
   30a9c:	00bff084 	movi	r2,-62
   30aa0:	00001706 	br	30b00 <altera_avalon_mailbox_send+0x13c>
            }
        }
        status = altera_avalon_mailbox_post (dev, message);
   30aa4:	e17ffd17 	ldw	r5,-12(fp)
   30aa8:	e13ffc17 	ldw	r4,-16(fp)
   30aac:	00303a80 	call	303a8 <altera_avalon_mailbox_post>
   30ab0:	e0bff915 	stw	r2,-28(fp)
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
   30ab4:	e0bffc17 	ldw	r2,-16(fp)
   30ab8:	10001015 	stw	zero,64(r2)
        /* Release lock when message posted */
        dev->lock =0;
   30abc:	e0bffc17 	ldw	r2,-16(fp)
   30ac0:	10001105 	stb	zero,68(r2)
        return status;
   30ac4:	e0bff917 	ldw	r2,-28(fp)
   30ac8:	00000d06 	br	30b00 <altera_avalon_mailbox_send+0x13c>
    } else
    {
        /* Enable Sender interrupt */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
   30acc:	e0bffc17 	ldw	r2,-16(fp)
   30ad0:	10800a17 	ldw	r2,40(r2)
   30ad4:	10800304 	addi	r2,r2,12
   30ad8:	10800037 	ldwio	r2,0(r2)
   30adc:	10800094 	ori	r2,r2,2
   30ae0:	e0bffa15 	stw	r2,-24(fp)
                   (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   30ae4:	e0bffc17 	ldw	r2,-16(fp)
   30ae8:	10800a17 	ldw	r2,40(r2)
   30aec:	10800304 	addi	r2,r2,12
   30af0:	1007883a 	mov	r3,r2
   30af4:	e0bffa17 	ldw	r2,-24(fp)
   30af8:	18800035 	stwio	r2,0(r3)
    }
  return 0;
   30afc:	0005883a 	mov	r2,zero
}
   30b00:	e037883a 	mov	sp,fp
   30b04:	dfc00117 	ldw	ra,4(sp)
   30b08:	df000017 	ldw	fp,0(sp)
   30b0c:	dec00204 	addi	sp,sp,8
   30b10:	f800283a 	ret

00030b14 <altera_avalon_mailbox_retrieve_poll>:
 * If a message is available in the mailbox return it otherwise return NULL
 * This function is blocking
 *
 */
int altera_avalon_mailbox_retrieve_poll (altera_avalon_mailbox_dev *dev, alt_u32 *message, alt_u32 timeout)
{
   30b14:	defff904 	addi	sp,sp,-28
   30b18:	dfc00615 	stw	ra,24(sp)
   30b1c:	df000515 	stw	fp,20(sp)
   30b20:	df000504 	addi	fp,sp,20
   30b24:	e13ffd15 	stw	r4,-12(fp)
   30b28:	e17ffe15 	stw	r5,-8(fp)
   30b2c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 status = 0;
   30b30:	e03ffb15 	stw	zero,-20(fp)
    alt_u32 data;

    if (dev != NULL && message != NULL)
   30b34:	e0bffd17 	ldw	r2,-12(fp)
   30b38:	10003a26 	beq	r2,zero,30c24 <altera_avalon_mailbox_retrieve_poll+0x110>
   30b3c:	e0bffe17 	ldw	r2,-8(fp)
   30b40:	10003826 	beq	r2,zero,30c24 <altera_avalon_mailbox_retrieve_poll+0x110>
    {
        /* Mask receiver mailbox interrupt when in polling mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
   30b44:	e0bffd17 	ldw	r2,-12(fp)
   30b48:	10800a17 	ldw	r2,40(r2)
   30b4c:	10800304 	addi	r2,r2,12
   30b50:	10800037 	ldwio	r2,0(r2)
   30b54:	e0bffc15 	stw	r2,-16(fp)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST,
   30b58:	e0bffd17 	ldw	r2,-12(fp)
   30b5c:	10800a17 	ldw	r2,40(r2)
   30b60:	10800304 	addi	r2,r2,12
   30b64:	1009883a 	mov	r4,r2
   30b68:	e0fffc17 	ldw	r3,-16(fp)
   30b6c:	00bfff84 	movi	r2,-2
   30b70:	1884703a 	and	r2,r3,r2
   30b74:	20800035 	stwio	r2,0(r4)
            (data & (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK)));


        /* If timeout is '0', poll till message availabe in mailbox */
        if (timeout == 0)
   30b78:	e0bfff17 	ldw	r2,-4(fp)
   30b7c:	1000061e 	bne	r2,zero,30b98 <altera_avalon_mailbox_retrieve_poll+0x84>
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
   30b80:	e13ffd17 	ldw	r4,-12(fp)
   30b84:	003094c0 	call	3094c <altera_avalon_mailbox_status>
   30b88:	e0bffb15 	stw	r2,-20(fp)
            } while (status == 0);
   30b8c:	e0bffb17 	ldw	r2,-20(fp)
   30b90:	103ffb26 	beq	r2,zero,30b80 <__reset+0xfff90b80>
   30b94:	00000a06 	br	30bc0 <altera_avalon_mailbox_retrieve_poll+0xac>
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
   30b98:	e13ffd17 	ldw	r4,-12(fp)
   30b9c:	003094c0 	call	3094c <altera_avalon_mailbox_status>
   30ba0:	e0bffb15 	stw	r2,-20(fp)
                 timeout-- ;
   30ba4:	e0bfff17 	ldw	r2,-4(fp)
   30ba8:	10bfffc4 	addi	r2,r2,-1
   30bac:	e0bfff15 	stw	r2,-4(fp)
            } while ((status == 0) && timeout);
   30bb0:	e0bffb17 	ldw	r2,-20(fp)
   30bb4:	1000021e 	bne	r2,zero,30bc0 <altera_avalon_mailbox_retrieve_poll+0xac>
   30bb8:	e0bfff17 	ldw	r2,-4(fp)
   30bbc:	103ff61e 	bne	r2,zero,30b98 <__reset+0xfff90b98>
        }

        /* if timeout, status remain 0 */
        if (status)
   30bc0:	e0bffb17 	ldw	r2,-20(fp)
   30bc4:	10000d26 	beq	r2,zero,30bfc <altera_avalon_mailbox_retrieve_poll+0xe8>
        {
            message[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
   30bc8:	e0bffe17 	ldw	r2,-8(fp)
   30bcc:	10800104 	addi	r2,r2,4
   30bd0:	e0fffd17 	ldw	r3,-12(fp)
   30bd4:	18c00a17 	ldw	r3,40(r3)
   30bd8:	18c00104 	addi	r3,r3,4
   30bdc:	18c00037 	ldwio	r3,0(r3)
   30be0:	10c00015 	stw	r3,0(r2)
            message[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
   30be4:	e0bffd17 	ldw	r2,-12(fp)
   30be8:	10800a17 	ldw	r2,40(r2)
   30bec:	10800037 	ldwio	r2,0(r2)
   30bf0:	1007883a 	mov	r3,r2
   30bf4:	e0bffe17 	ldw	r2,-8(fp)
   30bf8:	10c00015 	stw	r3,0(r2)
        }
        /* Restore original state of interrupt mask */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
   30bfc:	e0bffd17 	ldw	r2,-12(fp)
   30c00:	10800a17 	ldw	r2,40(r2)
   30c04:	10800304 	addi	r2,r2,12
   30c08:	1007883a 	mov	r3,r2
   30c0c:	e0bffc17 	ldw	r2,-16(fp)
   30c10:	18800035 	stwio	r2,0(r3)

        /* Return success on complete retrieve message
         * otherwise timeout and exit with error
         */
        if (status)
   30c14:	e0bffb17 	ldw	r2,-20(fp)
   30c18:	10000226 	beq	r2,zero,30c24 <altera_avalon_mailbox_retrieve_poll+0x110>
          return 0;
   30c1c:	0005883a 	mov	r2,zero
   30c20:	00000606 	br	30c3c <altera_avalon_mailbox_retrieve_poll+0x128>
      }
      /* Invalid Null dev and message */
      message[1] = 0;
   30c24:	e0bffe17 	ldw	r2,-8(fp)
   30c28:	10800104 	addi	r2,r2,4
   30c2c:	10000015 	stw	zero,0(r2)
      message[0] = 0;
   30c30:	e0bffe17 	ldw	r2,-8(fp)
   30c34:	10000015 	stw	zero,0(r2)
      return -EINVAL;
   30c38:	00bffa84 	movi	r2,-22
}
   30c3c:	e037883a 	mov	sp,fp
   30c40:	dfc00117 	ldw	ra,4(sp)
   30c44:	df000017 	ldw	fp,0(sp)
   30c48:	dec00204 	addi	sp,sp,8
   30c4c:	f800283a 	ret

00030c50 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   30c50:	defffe04 	addi	sp,sp,-8
   30c54:	dfc00115 	stw	ra,4(sp)
   30c58:	df000015 	stw	fp,0(sp)
   30c5c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   30c60:	d0a00f17 	ldw	r2,-32708(gp)
   30c64:	10000326 	beq	r2,zero,30c74 <alt_get_errno+0x24>
   30c68:	d0a00f17 	ldw	r2,-32708(gp)
   30c6c:	103ee83a 	callr	r2
   30c70:	00000106 	br	30c78 <alt_get_errno+0x28>
   30c74:	d0a03604 	addi	r2,gp,-32552
}
   30c78:	e037883a 	mov	sp,fp
   30c7c:	dfc00117 	ldw	ra,4(sp)
   30c80:	df000017 	ldw	fp,0(sp)
   30c84:	dec00204 	addi	sp,sp,8
   30c88:	f800283a 	ret

00030c8c <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
   30c8c:	defff904 	addi	sp,sp,-28
   30c90:	df000615 	stw	fp,24(sp)
   30c94:	df000604 	addi	fp,sp,24
   30c98:	e13ffe15 	stw	r4,-8(fp)
   30c9c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
   30ca0:	00bfffc4 	movi	r2,-1
   30ca4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
   30ca8:	0005317a 	rdctl	r2,cpuid
   30cac:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
   30cb0:	e0bffb17 	ldw	r2,-20(fp)
   30cb4:	1006943a 	slli	r3,r2,16
   30cb8:	e0bfff17 	ldw	r2,-4(fp)
   30cbc:	1884b03a 	or	r2,r3,r2
   30cc0:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
   30cc4:	e0bffe17 	ldw	r2,-8(fp)
   30cc8:	10800317 	ldw	r2,12(r2)
   30ccc:	e0fffc17 	ldw	r3,-16(fp)
   30cd0:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
   30cd4:	e0bffe17 	ldw	r2,-8(fp)
   30cd8:	10800317 	ldw	r2,12(r2)
   30cdc:	10800037 	ldwio	r2,0(r2)
   30ce0:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
   30ce4:	e0fffd17 	ldw	r3,-12(fp)
   30ce8:	e0bffc17 	ldw	r2,-16(fp)
   30cec:	1880011e 	bne	r3,r2,30cf4 <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
   30cf0:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
   30cf4:	e0bffa17 	ldw	r2,-24(fp)
}
   30cf8:	e037883a 	mov	sp,fp
   30cfc:	df000017 	ldw	fp,0(sp)
   30d00:	dec00104 	addi	sp,sp,4
   30d04:	f800283a 	ret

00030d08 <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
   30d08:	defffc04 	addi	sp,sp,-16
   30d0c:	dfc00315 	stw	ra,12(sp)
   30d10:	df000215 	stw	fp,8(sp)
   30d14:	df000204 	addi	fp,sp,8
   30d18:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
   30d1c:	d1601404 	addi	r5,gp,-32688
   30d20:	e13fff17 	ldw	r4,-4(fp)
   30d24:	0031d800 	call	31d80 <alt_find_dev>
   30d28:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
   30d2c:	e0bffe17 	ldw	r2,-8(fp)
   30d30:	1000041e 	bne	r2,zero,30d44 <altera_avalon_mutex_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
   30d34:	0030c500 	call	30c50 <alt_get_errno>
   30d38:	1007883a 	mov	r3,r2
   30d3c:	008004c4 	movi	r2,19
   30d40:	18800015 	stw	r2,0(r3)
  }

  return dev;
   30d44:	e0bffe17 	ldw	r2,-8(fp)
}
   30d48:	e037883a 	mov	sp,fp
   30d4c:	dfc00117 	ldw	ra,4(sp)
   30d50:	df000017 	ldw	fp,0(sp)
   30d54:	dec00204 	addi	sp,sp,8
   30d58:	f800283a 	ret

00030d5c <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
   30d5c:	defffe04 	addi	sp,sp,-8
   30d60:	df000115 	stw	fp,4(sp)
   30d64:	df000104 	addi	fp,sp,4
   30d68:	e13fff15 	stw	r4,-4(fp)
  return;
   30d6c:	0001883a 	nop
}
   30d70:	e037883a 	mov	sp,fp
   30d74:	df000017 	ldw	fp,0(sp)
   30d78:	dec00104 	addi	sp,sp,4
   30d7c:	f800283a 	ret

00030d80 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
   30d80:	defffc04 	addi	sp,sp,-16
   30d84:	dfc00315 	stw	ra,12(sp)
   30d88:	df000215 	stw	fp,8(sp)
   30d8c:	df000204 	addi	fp,sp,8
   30d90:	e13ffe15 	stw	r4,-8(fp)
   30d94:	e17fff15 	stw	r5,-4(fp)
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);

  while ( alt_mutex_trylock( dev, value ) != 0);
   30d98:	0001883a 	nop
   30d9c:	e17fff17 	ldw	r5,-4(fp)
   30da0:	e13ffe17 	ldw	r4,-8(fp)
   30da4:	0030c8c0 	call	30c8c <alt_mutex_trylock>
   30da8:	103ffc1e 	bne	r2,zero,30d9c <__reset+0xfff90d9c>
}
   30dac:	0001883a 	nop
   30db0:	e037883a 	mov	sp,fp
   30db4:	dfc00117 	ldw	ra,4(sp)
   30db8:	df000017 	ldw	fp,0(sp)
   30dbc:	dec00204 	addi	sp,sp,8
   30dc0:	f800283a 	ret

00030dc4 <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
   30dc4:	defffa04 	addi	sp,sp,-24
   30dc8:	dfc00515 	stw	ra,20(sp)
   30dcc:	df000415 	stw	fp,16(sp)
   30dd0:	df000404 	addi	fp,sp,16
   30dd4:	e13ffd15 	stw	r4,-12(fp)
   30dd8:	e17ffe15 	stw	r5,-8(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);

  ret_code = alt_mutex_trylock( dev, value);
   30ddc:	e17ffe17 	ldw	r5,-8(fp)
   30de0:	e13ffd17 	ldw	r4,-12(fp)
   30de4:	0030c8c0 	call	30c8c <alt_mutex_trylock>
   30de8:	e0bffc15 	stw	r2,-16(fp)
  if (ret_code)
  {
    ALT_SEM_POST (dev->lock);
  }

  return ret_code;
   30dec:	e0bffc17 	ldw	r2,-16(fp)
}
   30df0:	e037883a 	mov	sp,fp
   30df4:	dfc00117 	ldw	ra,4(sp)
   30df8:	df000017 	ldw	fp,0(sp)
   30dfc:	dec00204 	addi	sp,sp,8
   30e00:	f800283a 	ret

00030e04 <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
   30e04:	defffd04 	addi	sp,sp,-12
   30e08:	df000215 	stw	fp,8(sp)
   30e0c:	df000204 	addi	fp,sp,8
   30e10:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
   30e14:	0005317a 	rdctl	r2,cpuid
   30e18:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
   30e1c:	e0bfff17 	ldw	r2,-4(fp)
   30e20:	10800317 	ldw	r2,12(r2)
   30e24:	10800104 	addi	r2,r2,4
   30e28:	00c00044 	movi	r3,1
   30e2c:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
   30e30:	e0bfff17 	ldw	r2,-4(fp)
   30e34:	10800317 	ldw	r2,12(r2)
   30e38:	e0fffe17 	ldw	r3,-8(fp)
   30e3c:	1806943a 	slli	r3,r3,16
   30e40:	10c00035 	stwio	r3,0(r2)

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
}
   30e44:	0001883a 	nop
   30e48:	e037883a 	mov	sp,fp
   30e4c:	df000017 	ldw	fp,0(sp)
   30e50:	dec00104 	addi	sp,sp,4
   30e54:	f800283a 	ret

00030e58 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
   30e58:	defff904 	addi	sp,sp,-28
   30e5c:	df000615 	stw	fp,24(sp)
   30e60:	df000604 	addi	fp,sp,24
   30e64:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
   30e68:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
   30e6c:	0005317a 	rdctl	r2,cpuid
   30e70:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
   30e74:	e0bfff17 	ldw	r2,-4(fp)
   30e78:	10800317 	ldw	r2,12(r2)
   30e7c:	10800037 	ldwio	r2,0(r2)
   30e80:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
   30e84:	e0bffc17 	ldw	r2,-16(fp)
   30e88:	1004d43a 	srli	r2,r2,16
   30e8c:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
   30e90:	e0fffd17 	ldw	r3,-12(fp)
   30e94:	e0bffb17 	ldw	r2,-20(fp)
   30e98:	1880071e 	bne	r3,r2,30eb8 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
   30e9c:	e0bffc17 	ldw	r2,-16(fp)
   30ea0:	10bfffcc 	andi	r2,r2,65535
   30ea4:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
   30ea8:	e0bffe17 	ldw	r2,-8(fp)
   30eac:	10000226 	beq	r2,zero,30eb8 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
   30eb0:	00800044 	movi	r2,1
   30eb4:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
   30eb8:	e0bffa17 	ldw	r2,-24(fp)
}
   30ebc:	e037883a 	mov	sp,fp
   30ec0:	df000017 	ldw	fp,0(sp)
   30ec4:	dec00104 	addi	sp,sp,4
   30ec8:	f800283a 	ret

00030ecc <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
   30ecc:	defffc04 	addi	sp,sp,-16
   30ed0:	df000315 	stw	fp,12(sp)
   30ed4:	df000304 	addi	fp,sp,12
   30ed8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
   30edc:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
   30ee0:	e0bfff17 	ldw	r2,-4(fp)
   30ee4:	10800317 	ldw	r2,12(r2)
   30ee8:	10800104 	addi	r2,r2,4
   30eec:	10800037 	ldwio	r2,0(r2)
   30ef0:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
   30ef4:	e0bffe17 	ldw	r2,-8(fp)
   30ef8:	1080004c 	andi	r2,r2,1
   30efc:	10000226 	beq	r2,zero,30f08 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
   30f00:	00800044 	movi	r2,1
   30f04:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
   30f08:	e0bffd17 	ldw	r2,-12(fp)
}
   30f0c:	e037883a 	mov	sp,fp
   30f10:	df000017 	ldw	fp,0(sp)
   30f14:	dec00104 	addi	sp,sp,4
   30f18:	f800283a 	ret

00030f1c <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   30f1c:	defff404 	addi	sp,sp,-48
   30f20:	df000b15 	stw	fp,44(sp)
   30f24:	df000b04 	addi	fp,sp,44
   30f28:	e13ffc15 	stw	r4,-16(fp)
   30f2c:	e17ffd15 	stw	r5,-12(fp)
   30f30:	e1bffe15 	stw	r6,-8(fp)
   30f34:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
   30f38:	e0ffff17 	ldw	r3,-4(fp)
   30f3c:	e0bffe17 	ldw	r2,-8(fp)
   30f40:	1885883a 	add	r2,r3,r2
   30f44:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
   30f48:	e0c00217 	ldw	r3,8(fp)
   30f4c:	e0800117 	ldw	r2,4(fp)
   30f50:	1885883a 	add	r2,r3,r2
   30f54:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
   30f58:	e0800117 	ldw	r2,4(fp)
   30f5c:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
   30f60:	e0bffe17 	ldw	r2,-8(fp)
   30f64:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
   30f68:	00800044 	movi	r2,1
   30f6c:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   30f70:	e0bffc17 	ldw	r2,-16(fp)
   30f74:	10800504 	addi	r2,r2,20
   30f78:	1009883a 	mov	r4,r2
   30f7c:	00c00044 	movi	r3,1
   30f80:	e0bffd17 	ldw	r2,-12(fp)
   30f84:	1884983a 	sll	r2,r3,r2
   30f88:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   30f8c:	e0800317 	ldw	r2,12(fp)
   30f90:	1080008c 	andi	r2,r2,2
   30f94:	1000051e 	bne	r2,zero,30fac <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   30f98:	e0bffc17 	ldw	r2,-16(fp)
   30f9c:	10800304 	addi	r2,r2,12
   30fa0:	1007883a 	mov	r3,r2
   30fa4:	00810004 	movi	r2,1024
   30fa8:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   30fac:	e0bffc17 	ldw	r2,-16(fp)
   30fb0:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   30fb4:	e0bffc17 	ldw	r2,-16(fp)
   30fb8:	10800204 	addi	r2,r2,8
   30fbc:	10800037 	ldwio	r2,0(r2)
   30fc0:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   30fc4:	e0bffa17 	ldw	r2,-24(fp)
   30fc8:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   30fcc:	10000226 	beq	r2,zero,30fd8 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   30fd0:	e0bff717 	ldw	r2,-36(fp)
   30fd4:	1000031e 	bne	r2,zero,30fe4 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   30fd8:	e0bffa17 	ldw	r2,-24(fp)
   30fdc:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   30fe0:	103ff426 	beq	r2,zero,30fb4 <__reset+0xfff90fb4>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   30fe4:	e0bffa17 	ldw	r2,-24(fp)
   30fe8:	1080100c 	andi	r2,r2,64
   30fec:	10001e26 	beq	r2,zero,31068 <alt_avalon_spi_command+0x14c>
   30ff0:	e0bff717 	ldw	r2,-36(fp)
   30ff4:	00801c0e 	bge	zero,r2,31068 <alt_avalon_spi_command+0x14c>
    {
      credits--;
   30ff8:	e0bff717 	ldw	r2,-36(fp)
   30ffc:	10bfffc4 	addi	r2,r2,-1
   31000:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
   31004:	e0ffff17 	ldw	r3,-4(fp)
   31008:	e0bff817 	ldw	r2,-32(fp)
   3100c:	18800a2e 	bgeu	r3,r2,31038 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   31010:	e0bffc17 	ldw	r2,-16(fp)
   31014:	10800104 	addi	r2,r2,4
   31018:	1009883a 	mov	r4,r2
   3101c:	e0bfff17 	ldw	r2,-4(fp)
   31020:	10c00044 	addi	r3,r2,1
   31024:	e0ffff15 	stw	r3,-4(fp)
   31028:	10800003 	ldbu	r2,0(r2)
   3102c:	10803fcc 	andi	r2,r2,255
   31030:	20800035 	stwio	r2,0(r4)
   31034:	00000c06 	br	31068 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
   31038:	e0bff517 	ldw	r2,-44(fp)
   3103c:	10000826 	beq	r2,zero,31060 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
   31040:	e0bff517 	ldw	r2,-44(fp)
   31044:	10bfffc4 	addi	r2,r2,-1
   31048:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   3104c:	e0bffc17 	ldw	r2,-16(fp)
   31050:	10800104 	addi	r2,r2,4
   31054:	0007883a 	mov	r3,zero
   31058:	10c00035 	stwio	r3,0(r2)
   3105c:	00000206 	br	31068 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
   31060:	00bf0004 	movi	r2,-1024
   31064:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   31068:	e0bffa17 	ldw	r2,-24(fp)
   3106c:	1080200c 	andi	r2,r2,128
   31070:	103fd026 	beq	r2,zero,30fb4 <__reset+0xfff90fb4>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   31074:	e0bffc17 	ldw	r2,-16(fp)
   31078:	10800037 	ldwio	r2,0(r2)
   3107c:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
   31080:	e0bff617 	ldw	r2,-40(fp)
   31084:	10000426 	beq	r2,zero,31098 <alt_avalon_spi_command+0x17c>
        read_ignore--;
   31088:	e0bff617 	ldw	r2,-40(fp)
   3108c:	10bfffc4 	addi	r2,r2,-1
   31090:	e0bff615 	stw	r2,-40(fp)
   31094:	00000506 	br	310ac <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
   31098:	e0800217 	ldw	r2,8(fp)
   3109c:	10c00044 	addi	r3,r2,1
   310a0:	e0c00215 	stw	r3,8(fp)
   310a4:	e0fffb17 	ldw	r3,-20(fp)
   310a8:	10c00005 	stb	r3,0(r2)
      credits++;
   310ac:	e0bff717 	ldw	r2,-36(fp)
   310b0:	10800044 	addi	r2,r2,1
   310b4:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
   310b8:	e0bff617 	ldw	r2,-40(fp)
   310bc:	103fbd1e 	bne	r2,zero,30fb4 <__reset+0xfff90fb4>
   310c0:	e0c00217 	ldw	r3,8(fp)
   310c4:	e0bff917 	ldw	r2,-28(fp)
   310c8:	18bfba1e 	bne	r3,r2,30fb4 <__reset+0xfff90fb4>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   310cc:	e0bffc17 	ldw	r2,-16(fp)
   310d0:	10800204 	addi	r2,r2,8
   310d4:	10800037 	ldwio	r2,0(r2)
   310d8:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   310dc:	e0bffa17 	ldw	r2,-24(fp)
   310e0:	1080080c 	andi	r2,r2,32
   310e4:	103ff926 	beq	r2,zero,310cc <__reset+0xfff910cc>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   310e8:	e0800317 	ldw	r2,12(fp)
   310ec:	1080004c 	andi	r2,r2,1
   310f0:	1000041e 	bne	r2,zero,31104 <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   310f4:	e0bffc17 	ldw	r2,-16(fp)
   310f8:	10800304 	addi	r2,r2,12
   310fc:	0007883a 	mov	r3,zero
   31100:	10c00035 	stwio	r3,0(r2)

  return read_length;
   31104:	e0800117 	ldw	r2,4(fp)
}
   31108:	e037883a 	mov	sp,fp
   3110c:	df000017 	ldw	fp,0(sp)
   31110:	dec00104 	addi	sp,sp,4
   31114:	f800283a 	ret

00031118 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   31118:	defff904 	addi	sp,sp,-28
   3111c:	dfc00615 	stw	ra,24(sp)
   31120:	df000515 	stw	fp,20(sp)
   31124:	df000504 	addi	fp,sp,20
   31128:	e13ffe15 	stw	r4,-8(fp)
   3112c:	e17fff15 	stw	r5,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   31130:	0007883a 	mov	r3,zero
   31134:	e0bffe17 	ldw	r2,-8(fp)
   31138:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   3113c:	e0bffe17 	ldw	r2,-8(fp)
   31140:	10800104 	addi	r2,r2,4
   31144:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   31148:	0005303a 	rdctl	r2,status
   3114c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   31150:	e0fffc17 	ldw	r3,-16(fp)
   31154:	00bfff84 	movi	r2,-2
   31158:	1884703a 	and	r2,r3,r2
   3115c:	1001703a 	wrctl	status,r2
  
  return context;
   31160:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   31164:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   31168:	00322fc0 	call	322fc <alt_tick>
   3116c:	e0bffb17 	ldw	r2,-20(fp)
   31170:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   31174:	e0bffd17 	ldw	r2,-12(fp)
   31178:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   3117c:	0001883a 	nop
   31180:	e037883a 	mov	sp,fp
   31184:	dfc00117 	ldw	ra,4(sp)
   31188:	df000017 	ldw	fp,0(sp)
   3118c:	dec00204 	addi	sp,sp,8
   31190:	f800283a 	ret

00031194 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   31194:	defff904 	addi	sp,sp,-28
   31198:	dfc00615 	stw	ra,24(sp)
   3119c:	df000515 	stw	fp,20(sp)
   311a0:	df000504 	addi	fp,sp,20
   311a4:	e13ffc15 	stw	r4,-16(fp)
   311a8:	e17ffd15 	stw	r5,-12(fp)
   311ac:	e1bffe15 	stw	r6,-8(fp)
   311b0:	e1ffff15 	stw	r7,-4(fp)
   311b4:	e0bfff17 	ldw	r2,-4(fp)
   311b8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   311bc:	d0a03b17 	ldw	r2,-32532(gp)
   311c0:	1000021e 	bne	r2,zero,311cc <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
   311c4:	e0bffb17 	ldw	r2,-20(fp)
   311c8:	d0a03b15 	stw	r2,-32532(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   311cc:	e0bffc17 	ldw	r2,-16(fp)
   311d0:	10800104 	addi	r2,r2,4
   311d4:	00c001c4 	movi	r3,7
   311d8:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
   311dc:	018000f4 	movhi	r6,3
   311e0:	31844604 	addi	r6,r6,4376
   311e4:	e17ffc17 	ldw	r5,-16(fp)
   311e8:	e13ffe17 	ldw	r4,-8(fp)
   311ec:	0020f9c0 	call	20f9c <alt_irq_register>
#endif  
}
   311f0:	0001883a 	nop
   311f4:	e037883a 	mov	sp,fp
   311f8:	dfc00117 	ldw	ra,4(sp)
   311fc:	df000017 	ldw	fp,0(sp)
   31200:	dec00204 	addi	sp,sp,8
   31204:	f800283a 	ret

00031208 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
   31208:	defff904 	addi	sp,sp,-28
   3120c:	dfc00615 	stw	ra,24(sp)
   31210:	df000515 	stw	fp,20(sp)
   31214:	df000504 	addi	fp,sp,20
   31218:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
   3121c:	00800144 	movi	r2,5
   31220:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
   31224:	d8000215 	stw	zero,8(sp)
   31228:	e0bffe44 	addi	r2,fp,-7
   3122c:	d8800115 	stw	r2,4(sp)
   31230:	00800044 	movi	r2,1
   31234:	d8800015 	stw	r2,0(sp)
   31238:	e1fffe04 	addi	r7,fp,-8
   3123c:	01800044 	movi	r6,1
   31240:	000b883a 	mov	r5,zero
   31244:	e13fff17 	ldw	r4,-4(fp)
   31248:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
   3124c:	e0bffe43 	ldbu	r2,-7(fp)
}
   31250:	e037883a 	mov	sp,fp
   31254:	dfc00117 	ldw	ra,4(sp)
   31258:	df000017 	ldw	fp,0(sp)
   3125c:	dec00204 	addi	sp,sp,8
   31260:	f800283a 	ret

00031264 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
   31264:	defffd04 	addi	sp,sp,-12
   31268:	dfc00215 	stw	ra,8(sp)
   3126c:	df000115 	stw	fp,4(sp)
   31270:	df000104 	addi	fp,sp,4
   31274:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
   31278:	e13fff17 	ldw	r4,-4(fp)
   3127c:	00312080 	call	31208 <epcs_read_status_register>
   31280:	10803fcc 	andi	r2,r2,255
   31284:	1080004c 	andi	r2,r2,1
}
   31288:	e037883a 	mov	sp,fp
   3128c:	dfc00117 	ldw	ra,4(sp)
   31290:	df000017 	ldw	fp,0(sp)
   31294:	dec00204 	addi	sp,sp,8
   31298:	f800283a 	ret

0003129c <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
   3129c:	defffd04 	addi	sp,sp,-12
   312a0:	dfc00215 	stw	ra,8(sp)
   312a4:	df000115 	stw	fp,4(sp)
   312a8:	df000104 	addi	fp,sp,4
   312ac:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   312b0:	0001883a 	nop
   312b4:	e13fff17 	ldw	r4,-4(fp)
   312b8:	00312640 	call	31264 <epcs_test_wip>
   312bc:	103ffd1e 	bne	r2,zero,312b4 <__reset+0xfff912b4>
  {
  }
}
   312c0:	0001883a 	nop
   312c4:	e037883a 	mov	sp,fp
   312c8:	dfc00117 	ldw	ra,4(sp)
   312cc:	df000017 	ldw	fp,0(sp)
   312d0:	dec00204 	addi	sp,sp,8
   312d4:	f800283a 	ret

000312d8 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
   312d8:	defff604 	addi	sp,sp,-40
   312dc:	dfc00915 	stw	ra,36(sp)
   312e0:	df000815 	stw	fp,32(sp)
   312e4:	df000804 	addi	fp,sp,32
   312e8:	e13ffd15 	stw	r4,-12(fp)
   312ec:	e17ffe15 	stw	r5,-8(fp)
   312f0:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
   312f4:	e0bfff17 	ldw	r2,-4(fp)
   312f8:	10001226 	beq	r2,zero,31344 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
   312fc:	00bff604 	movi	r2,-40
   31300:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
   31304:	e0bffe17 	ldw	r2,-8(fp)
   31308:	1004d63a 	srli	r2,r2,24
   3130c:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
   31310:	e0bffe17 	ldw	r2,-8(fp)
   31314:	1004d43a 	srli	r2,r2,16
   31318:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
   3131c:	e0bffe17 	ldw	r2,-8(fp)
   31320:	1004d23a 	srli	r2,r2,8
   31324:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
   31328:	e0bffe17 	ldw	r2,-8(fp)
   3132c:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
   31330:	00800144 	movi	r2,5
   31334:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
   31338:	e13ffd17 	ldw	r4,-12(fp)
   3133c:	003178c0 	call	3178c <epcs_enter_4_bytes_mode>
   31340:	00000c06 	br	31374 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
   31344:	00bff604 	movi	r2,-40
   31348:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
   3134c:	e0bffe17 	ldw	r2,-8(fp)
   31350:	1004d43a 	srli	r2,r2,16
   31354:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
   31358:	e0bffe17 	ldw	r2,-8(fp)
   3135c:	1004d23a 	srli	r2,r2,8
   31360:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
   31364:	e0bffe17 	ldw	r2,-8(fp)
   31368:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
   3136c:	00800104 	movi	r2,4
   31370:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
   31374:	e13ffd17 	ldw	r4,-12(fp)
   31378:	00314c80 	call	314c8 <epcs_write_enable>

  alt_avalon_spi_command(
   3137c:	e0bffb03 	ldbu	r2,-20(fp)
   31380:	e0fffb44 	addi	r3,fp,-19
   31384:	d8000215 	stw	zero,8(sp)
   31388:	d8000115 	stw	zero,4(sp)
   3138c:	d8000015 	stw	zero,0(sp)
   31390:	180f883a 	mov	r7,r3
   31394:	100d883a 	mov	r6,r2
   31398:	000b883a 	mov	r5,zero
   3139c:	e13ffd17 	ldw	r4,-12(fp)
   313a0:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
   313a4:	e13ffd17 	ldw	r4,-12(fp)
   313a8:	003129c0 	call	3129c <epcs_await_wip_released>

  if(four_bytes_mode)
   313ac:	e0bfff17 	ldw	r2,-4(fp)
   313b0:	10000226 	beq	r2,zero,313bc <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
   313b4:	e13ffd17 	ldw	r4,-12(fp)
   313b8:	00317e80 	call	317e8 <epcs_exit_4_bytes_mode>
  }
}
   313bc:	0001883a 	nop
   313c0:	e037883a 	mov	sp,fp
   313c4:	dfc00117 	ldw	ra,4(sp)
   313c8:	df000017 	ldw	fp,0(sp)
   313cc:	dec00204 	addi	sp,sp,8
   313d0:	f800283a 	ret

000313d4 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
   313d4:	defff404 	addi	sp,sp,-48
   313d8:	dfc00b15 	stw	ra,44(sp)
   313dc:	df000a15 	stw	fp,40(sp)
   313e0:	df000a04 	addi	fp,sp,40
   313e4:	e13ffc15 	stw	r4,-16(fp)
   313e8:	e17ffd15 	stw	r5,-12(fp)
   313ec:	e1bffe15 	stw	r6,-8(fp)
   313f0:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
   313f4:	008000c4 	movi	r2,3
   313f8:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
   313fc:	e0800217 	ldw	r2,8(fp)
   31400:	10001026 	beq	r2,zero,31444 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
   31404:	e0bffd17 	ldw	r2,-12(fp)
   31408:	1004d63a 	srli	r2,r2,24
   3140c:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
   31410:	e0bffd17 	ldw	r2,-12(fp)
   31414:	1005d43a 	srai	r2,r2,16
   31418:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
   3141c:	e0bffd17 	ldw	r2,-12(fp)
   31420:	1005d23a 	srai	r2,r2,8
   31424:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
   31428:	e0bffd17 	ldw	r2,-12(fp)
   3142c:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
   31430:	00800144 	movi	r2,5
   31434:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
   31438:	e13ffc17 	ldw	r4,-16(fp)
   3143c:	003178c0 	call	3178c <epcs_enter_4_bytes_mode>
   31440:	00000a06 	br	3146c <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
   31444:	e0bffd17 	ldw	r2,-12(fp)
   31448:	1005d43a 	srai	r2,r2,16
   3144c:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
   31450:	e0bffd17 	ldw	r2,-12(fp)
   31454:	1005d23a 	srai	r2,r2,8
   31458:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
   3145c:	e0bffd17 	ldw	r2,-12(fp)
   31460:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
   31464:	00800104 	movi	r2,4
   31468:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
   3146c:	e13ffc17 	ldw	r4,-16(fp)
   31470:	003129c0 	call	3129c <epcs_await_wip_released>

  alt_avalon_spi_command(
   31474:	e0bfff17 	ldw	r2,-4(fp)
   31478:	e13ffa04 	addi	r4,fp,-24
   3147c:	d8000215 	stw	zero,8(sp)
   31480:	e0fffe17 	ldw	r3,-8(fp)
   31484:	d8c00115 	stw	r3,4(sp)
   31488:	d8800015 	stw	r2,0(sp)
   3148c:	200f883a 	mov	r7,r4
   31490:	e1bff917 	ldw	r6,-28(fp)
   31494:	000b883a 	mov	r5,zero
   31498:	e13ffc17 	ldw	r4,-16(fp)
   3149c:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
   314a0:	e0800217 	ldw	r2,8(fp)
   314a4:	10000226 	beq	r2,zero,314b0 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
   314a8:	e13ffc17 	ldw	r4,-16(fp)
   314ac:	00317e80 	call	317e8 <epcs_exit_4_bytes_mode>
  }

  return length;
   314b0:	e0bfff17 	ldw	r2,-4(fp)
}
   314b4:	e037883a 	mov	sp,fp
   314b8:	dfc00117 	ldw	ra,4(sp)
   314bc:	df000017 	ldw	fp,0(sp)
   314c0:	dec00204 	addi	sp,sp,8
   314c4:	f800283a 	ret

000314c8 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
   314c8:	defff904 	addi	sp,sp,-28
   314cc:	dfc00615 	stw	ra,24(sp)
   314d0:	df000515 	stw	fp,20(sp)
   314d4:	df000504 	addi	fp,sp,20
   314d8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
   314dc:	00800184 	movi	r2,6
   314e0:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
   314e4:	d8000215 	stw	zero,8(sp)
   314e8:	d8000115 	stw	zero,4(sp)
   314ec:	d8000015 	stw	zero,0(sp)
   314f0:	e1fffe04 	addi	r7,fp,-8
   314f4:	01800044 	movi	r6,1
   314f8:	000b883a 	mov	r5,zero
   314fc:	e13fff17 	ldw	r4,-4(fp)
   31500:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
   31504:	0001883a 	nop
   31508:	e037883a 	mov	sp,fp
   3150c:	dfc00117 	ldw	ra,4(sp)
   31510:	df000017 	ldw	fp,0(sp)
   31514:	dec00204 	addi	sp,sp,8
   31518:	f800283a 	ret

0003151c <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
   3151c:	defff804 	addi	sp,sp,-32
   31520:	dfc00715 	stw	ra,28(sp)
   31524:	df000615 	stw	fp,24(sp)
   31528:	df000604 	addi	fp,sp,24
   3152c:	e13ffe15 	stw	r4,-8(fp)
   31530:	2805883a 	mov	r2,r5
   31534:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
   31538:	00800044 	movi	r2,1
   3153c:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
   31540:	e0bfff03 	ldbu	r2,-4(fp)
   31544:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
   31548:	d8000215 	stw	zero,8(sp)
   3154c:	d8000115 	stw	zero,4(sp)
   31550:	d8000015 	stw	zero,0(sp)
   31554:	e1fffd04 	addi	r7,fp,-12
   31558:	01800084 	movi	r6,2
   3155c:	000b883a 	mov	r5,zero
   31560:	e13ffe17 	ldw	r4,-8(fp)
   31564:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
   31568:	e13ffe17 	ldw	r4,-8(fp)
   3156c:	003129c0 	call	3129c <epcs_await_wip_released>
}
   31570:	0001883a 	nop
   31574:	e037883a 	mov	sp,fp
   31578:	dfc00117 	ldw	ra,4(sp)
   3157c:	df000017 	ldw	fp,0(sp)
   31580:	dec00204 	addi	sp,sp,8
   31584:	f800283a 	ret

00031588 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
   31588:	defff404 	addi	sp,sp,-48
   3158c:	dfc00b15 	stw	ra,44(sp)
   31590:	df000a15 	stw	fp,40(sp)
   31594:	df000a04 	addi	fp,sp,40
   31598:	e13ffc15 	stw	r4,-16(fp)
   3159c:	e17ffd15 	stw	r5,-12(fp)
   315a0:	e1bffe15 	stw	r6,-8(fp)
   315a4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
   315a8:	00800084 	movi	r2,2
   315ac:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
   315b0:	e0800217 	ldw	r2,8(fp)
   315b4:	10001026 	beq	r2,zero,315f8 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
   315b8:	e0bffd17 	ldw	r2,-12(fp)
   315bc:	1004d63a 	srli	r2,r2,24
   315c0:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
   315c4:	e0bffd17 	ldw	r2,-12(fp)
   315c8:	1005d43a 	srai	r2,r2,16
   315cc:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
   315d0:	e0bffd17 	ldw	r2,-12(fp)
   315d4:	1005d23a 	srai	r2,r2,8
   315d8:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
   315dc:	e0bffd17 	ldw	r2,-12(fp)
   315e0:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
   315e4:	00800144 	movi	r2,5
   315e8:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
   315ec:	e13ffc17 	ldw	r4,-16(fp)
   315f0:	003178c0 	call	3178c <epcs_enter_4_bytes_mode>
   315f4:	00000a06 	br	31620 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
   315f8:	e0bffd17 	ldw	r2,-12(fp)
   315fc:	1005d43a 	srai	r2,r2,16
   31600:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
   31604:	e0bffd17 	ldw	r2,-12(fp)
   31608:	1005d23a 	srai	r2,r2,8
   3160c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
   31610:	e0bffd17 	ldw	r2,-12(fp)
   31614:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
   31618:	00800104 	movi	r2,4
   3161c:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
   31620:	e13ffc17 	ldw	r4,-16(fp)
   31624:	00314c80 	call	314c8 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
   31628:	e0fffa04 	addi	r3,fp,-24
   3162c:	00800044 	movi	r2,1
   31630:	d8800215 	stw	r2,8(sp)
   31634:	d8000115 	stw	zero,4(sp)
   31638:	d8000015 	stw	zero,0(sp)
   3163c:	180f883a 	mov	r7,r3
   31640:	e1bff917 	ldw	r6,-28(fp)
   31644:	000b883a 	mov	r5,zero
   31648:	e13ffc17 	ldw	r4,-16(fp)
   3164c:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
   31650:	e0bfff17 	ldw	r2,-4(fp)
   31654:	d8000215 	stw	zero,8(sp)
   31658:	d8000115 	stw	zero,4(sp)
   3165c:	d8000015 	stw	zero,0(sp)
   31660:	e1fffe17 	ldw	r7,-8(fp)
   31664:	100d883a 	mov	r6,r2
   31668:	000b883a 	mov	r5,zero
   3166c:	e13ffc17 	ldw	r4,-16(fp)
   31670:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
   31674:	e13ffc17 	ldw	r4,-16(fp)
   31678:	003129c0 	call	3129c <epcs_await_wip_released>

  if(four_bytes_mode)
   3167c:	e0800217 	ldw	r2,8(fp)
   31680:	10000226 	beq	r2,zero,3168c <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
   31684:	e13ffc17 	ldw	r4,-16(fp)
   31688:	00317e80 	call	317e8 <epcs_exit_4_bytes_mode>
  }

  return length;
   3168c:	e0bfff17 	ldw	r2,-4(fp)
}
   31690:	e037883a 	mov	sp,fp
   31694:	dfc00117 	ldw	ra,4(sp)
   31698:	df000017 	ldw	fp,0(sp)
   3169c:	dec00204 	addi	sp,sp,8
   316a0:	f800283a 	ret

000316a4 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
   316a4:	defff804 	addi	sp,sp,-32
   316a8:	dfc00715 	stw	ra,28(sp)
   316ac:	df000615 	stw	fp,24(sp)
   316b0:	df000604 	addi	fp,sp,24
   316b4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
   316b8:	00bfeac4 	movi	r2,-85
   316bc:	e0bffd05 	stb	r2,-12(fp)
   316c0:	e03ffd45 	stb	zero,-11(fp)
   316c4:	e03ffd85 	stb	zero,-10(fp)
   316c8:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
   316cc:	d8000215 	stw	zero,8(sp)
   316d0:	e0bffe04 	addi	r2,fp,-8
   316d4:	d8800115 	stw	r2,4(sp)
   316d8:	00800044 	movi	r2,1
   316dc:	d8800015 	stw	r2,0(sp)
   316e0:	e1fffd04 	addi	r7,fp,-12
   316e4:	01800104 	movi	r6,4
   316e8:	000b883a 	mov	r5,zero
   316ec:	e13fff17 	ldw	r4,-4(fp)
   316f0:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
   316f4:	e0bffe03 	ldbu	r2,-8(fp)
}
   316f8:	e037883a 	mov	sp,fp
   316fc:	dfc00117 	ldw	ra,4(sp)
   31700:	df000017 	ldw	fp,0(sp)
   31704:	dec00204 	addi	sp,sp,8
   31708:	f800283a 	ret

0003170c <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
   3170c:	defff904 	addi	sp,sp,-28
   31710:	dfc00615 	stw	ra,24(sp)
   31714:	df000515 	stw	fp,20(sp)
   31718:	df000504 	addi	fp,sp,20
   3171c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
   31720:	00bfe7c4 	movi	r2,-97
   31724:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
   31728:	d8000215 	stw	zero,8(sp)
   3172c:	e0bffe44 	addi	r2,fp,-7
   31730:	d8800115 	stw	r2,4(sp)
   31734:	008000c4 	movi	r2,3
   31738:	d8800015 	stw	r2,0(sp)
   3173c:	e1fffe04 	addi	r7,fp,-8
   31740:	01800044 	movi	r6,1
   31744:	000b883a 	mov	r5,zero
   31748:	e13fff17 	ldw	r4,-4(fp)
   3174c:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
   31750:	e0bffe43 	ldbu	r2,-7(fp)
   31754:	10803fcc 	andi	r2,r2,255
   31758:	1006943a 	slli	r3,r2,16
   3175c:	e0bffe83 	ldbu	r2,-6(fp)
   31760:	10803fcc 	andi	r2,r2,255
   31764:	1004923a 	slli	r2,r2,8
   31768:	1886b03a 	or	r3,r3,r2
   3176c:	e0bffec3 	ldbu	r2,-5(fp)
   31770:	10803fcc 	andi	r2,r2,255
   31774:	1884b03a 	or	r2,r3,r2
}
   31778:	e037883a 	mov	sp,fp
   3177c:	dfc00117 	ldw	ra,4(sp)
   31780:	df000017 	ldw	fp,0(sp)
   31784:	dec00204 	addi	sp,sp,8
   31788:	f800283a 	ret

0003178c <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
   3178c:	defff904 	addi	sp,sp,-28
   31790:	dfc00615 	stw	ra,24(sp)
   31794:	df000515 	stw	fp,20(sp)
   31798:	df000504 	addi	fp,sp,20
   3179c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
   317a0:	00bfedc4 	movi	r2,-73
   317a4:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
   317a8:	e13fff17 	ldw	r4,-4(fp)
   317ac:	00314c80 	call	314c8 <epcs_write_enable>

  alt_avalon_spi_command(
   317b0:	d8000215 	stw	zero,8(sp)
   317b4:	d8000115 	stw	zero,4(sp)
   317b8:	d8000015 	stw	zero,0(sp)
   317bc:	e1fffe04 	addi	r7,fp,-8
   317c0:	01800044 	movi	r6,1
   317c4:	000b883a 	mov	r5,zero
   317c8:	e13fff17 	ldw	r4,-4(fp)
   317cc:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
   317d0:	0001883a 	nop
}
   317d4:	e037883a 	mov	sp,fp
   317d8:	dfc00117 	ldw	ra,4(sp)
   317dc:	df000017 	ldw	fp,0(sp)
   317e0:	dec00204 	addi	sp,sp,8
   317e4:	f800283a 	ret

000317e8 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
   317e8:	defff904 	addi	sp,sp,-28
   317ec:	dfc00615 	stw	ra,24(sp)
   317f0:	df000515 	stw	fp,20(sp)
   317f4:	df000504 	addi	fp,sp,20
   317f8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
   317fc:	00bffa44 	movi	r2,-23
   31800:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
   31804:	e13fff17 	ldw	r4,-4(fp)
   31808:	00314c80 	call	314c8 <epcs_write_enable>

  alt_avalon_spi_command(
   3180c:	d8000215 	stw	zero,8(sp)
   31810:	d8000115 	stw	zero,4(sp)
   31814:	d8000015 	stw	zero,0(sp)
   31818:	e1fffe04 	addi	r7,fp,-8
   3181c:	01800044 	movi	r6,1
   31820:	000b883a 	mov	r5,zero
   31824:	e13fff17 	ldw	r4,-4(fp)
   31828:	0030f1c0 	call	30f1c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
   3182c:	0001883a 	nop
}
   31830:	e037883a 	mov	sp,fp
   31834:	dfc00117 	ldw	ra,4(sp)
   31838:	df000017 	ldw	fp,0(sp)
   3183c:	dec00204 	addi	sp,sp,8
   31840:	f800283a 	ret

00031844 <I2C_init>:
      clk = freuqency of the clock driving this component  ( in Hz)
      speed = SCL speed ie 100K, 400K ...            (in Hz)
15-OCT-07 initial release
*****************************************************************/
void I2C_init(alt_u32 base,alt_u32 clk,alt_u32 speed)
{
   31844:	defffa04 	addi	sp,sp,-24
   31848:	dfc00515 	stw	ra,20(sp)
   3184c:	df000415 	stw	fp,16(sp)
   31850:	df000404 	addi	fp,sp,16
   31854:	e13ffd15 	stw	r4,-12(fp)
   31858:	e17ffe15 	stw	r5,-8(fp)
   3185c:	e1bfff15 	stw	r6,-4(fp)
  alt_u32 prescale = (clk/( 5 * speed))-1;
   31860:	e0bfff17 	ldw	r2,-4(fp)
   31864:	10800164 	muli	r2,r2,5
   31868:	100b883a 	mov	r5,r2
   3186c:	e13ffe17 	ldw	r4,-8(fp)
   31870:	0027dec0 	call	27dec <__udivsi3>
   31874:	10bfffc4 	addi	r2,r2,-1
   31878:	e0bffc15 	stw	r2,-16(fp)
#ifdef  I2C_DEBUG
        printf(" Initializing  I2C at 0x%x, \n\twith clock speed 0x%x \n\tand SCL speed 0x%x \n\tand prescale 0x%x\n",base,clk,speed,prescale);
#endif
  IOWR_I2C_OPENCORES_CTR(base, 0x00); /* turn off the core*/
   3187c:	e0bffd17 	ldw	r2,-12(fp)
   31880:	10800204 	addi	r2,r2,8
   31884:	0007883a 	mov	r3,zero
   31888:	10c00035 	stwio	r3,0(r2)

  IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_IACK_MSK); /* clearn any pening IRQ*/
   3188c:	e0bffd17 	ldw	r2,-12(fp)
   31890:	10800404 	addi	r2,r2,16
   31894:	1007883a 	mov	r3,r2
   31898:	00800044 	movi	r2,1
   3189c:	18800035 	stwio	r2,0(r3)

  IOWR_I2C_OPENCORES_PRERLO(base, (0xff & prescale));  /* load low presacle bit*/
   318a0:	e0bffd17 	ldw	r2,-12(fp)
   318a4:	e0fffc17 	ldw	r3,-16(fp)
   318a8:	18c03fcc 	andi	r3,r3,255
   318ac:	10c00035 	stwio	r3,0(r2)

  IOWR_I2C_OPENCORES_PRERHI(base, (0xff & (prescale>>8)));  /* load upper prescale bit */
   318b0:	e0bffd17 	ldw	r2,-12(fp)
   318b4:	10800104 	addi	r2,r2,4
   318b8:	1007883a 	mov	r3,r2
   318bc:	e0bffc17 	ldw	r2,-16(fp)
   318c0:	1004d23a 	srli	r2,r2,8
   318c4:	10803fcc 	andi	r2,r2,255
   318c8:	18800035 	stwio	r2,0(r3)

  IOWR_I2C_OPENCORES_CTR(base, I2C_OPENCORES_CTR_EN_MSK); /* turn on the core*/
   318cc:	e0bffd17 	ldw	r2,-12(fp)
   318d0:	10800204 	addi	r2,r2,8
   318d4:	1007883a 	mov	r3,r2
   318d8:	00802004 	movi	r2,128
   318dc:	18800035 	stwio	r2,0(r3)

}
   318e0:	0001883a 	nop
   318e4:	e037883a 	mov	sp,fp
   318e8:	dfc00117 	ldw	ra,4(sp)
   318ec:	df000017 	ldw	fp,0(sp)
   318f0:	dec00204 	addi	sp,sp,8
   318f4:	f800283a 	ret

000318f8 <I2C_start>:
       0 if address is acknowledged
       1 if address was not acknowledged
15-OCT-07 initial release
*****************************************************************/
int I2C_start(alt_u32 base, alt_u32 add, alt_u32 read)
{
   318f8:	defffc04 	addi	sp,sp,-16
   318fc:	df000315 	stw	fp,12(sp)
   31900:	df000304 	addi	fp,sp,12
   31904:	e13ffd15 	stw	r4,-12(fp)
   31908:	e17ffe15 	stw	r5,-8(fp)
   3190c:	e1bfff15 	stw	r6,-4(fp)
#ifdef  I2C_DEBUG
        printf(" Start  I2C at 0x%x, \n\twith address 0x%x \n\tand read 0x%x \n\tand prescale 0x%x\n",base,add,read);
#endif

          /* transmit the address and the read/write bit*/
  IOWR_I2C_OPENCORES_TXR(base, ((add) + (0x1 & read)));
   31910:	e0bffd17 	ldw	r2,-12(fp)
   31914:	10800304 	addi	r2,r2,12
   31918:	1009883a 	mov	r4,r2
   3191c:	e0bfff17 	ldw	r2,-4(fp)
   31920:	10c0004c 	andi	r3,r2,1
   31924:	e0bffe17 	ldw	r2,-8(fp)
   31928:	1885883a 	add	r2,r3,r2
   3192c:	20800035 	stwio	r2,0(r4)

          /* set start and write  bits which will start the transaction*/
  IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_STA_MSK | I2C_OPENCORES_CR_WR_MSK );
   31930:	e0bffd17 	ldw	r2,-12(fp)
   31934:	10800404 	addi	r2,r2,16
   31938:	1007883a 	mov	r3,r2
   3193c:	00802404 	movi	r2,144
   31940:	18800035 	stwio	r2,0(r3)

          /* wait for the trnasaction to be over.*/
  while( IORD_I2C_OPENCORES_SR(base) & I2C_OPENCORES_SR_TIP_MSK);
   31944:	0001883a 	nop
   31948:	e0bffd17 	ldw	r2,-12(fp)
   3194c:	10800404 	addi	r2,r2,16
   31950:	10800037 	ldwio	r2,0(r2)
   31954:	1080008c 	andi	r2,r2,2
   31958:	103ffb1e 	bne	r2,zero,31948 <__reset+0xfff91948>

         /* now check to see if the address was acknowledged */
   if(IORD_I2C_OPENCORES_SR(base) & I2C_OPENCORES_SR_RXNACK_MSK)
   3195c:	e0bffd17 	ldw	r2,-12(fp)
   31960:	10800404 	addi	r2,r2,16
   31964:	10800037 	ldwio	r2,0(r2)
   31968:	1080200c 	andi	r2,r2,128
   3196c:	10000226 	beq	r2,zero,31978 <I2C_start+0x80>
   {
#ifdef  I2C_DEBUG
        printf("\tNOACK\n");
#endif
        return (I2C_NOACK);
   31970:	00800044 	movi	r2,1
   31974:	00000106 	br	3197c <I2C_start+0x84>
   else
   {
#ifdef  I2C_DEBUG
        printf("\tACK\n");
#endif
       return (I2C_ACK);
   31978:	0005883a 	mov	r2,zero
   }
}
   3197c:	e037883a 	mov	sp,fp
   31980:	df000017 	ldw	fp,0(sp)
   31984:	dec00104 	addi	sp,sp,4
   31988:	f800283a 	ret

0003198c <I2C_read>:
return value
       byte read back.
15-OCT-07 initial release
*****************************************************************/
alt_u32 I2C_read(alt_u32 base,alt_u32 last)
{
   3198c:	defffd04 	addi	sp,sp,-12
   31990:	df000215 	stw	fp,8(sp)
   31994:	df000204 	addi	fp,sp,8
   31998:	e13ffe15 	stw	r4,-8(fp)
   3199c:	e17fff15 	stw	r5,-4(fp)
#ifdef  I2C_DEBUG
        printf(" Read I2C at 0x%x, \n\twith last0x%x\n",base,last);
#endif
  if( last)
   319a0:	e0bfff17 	ldw	r2,-4(fp)
   319a4:	10000626 	beq	r2,zero,319c0 <I2C_read+0x34>
  {
               /* start a read and no ack and stop bit*/
           IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_RD_MSK |
   319a8:	e0bffe17 	ldw	r2,-8(fp)
   319ac:	10800404 	addi	r2,r2,16
   319b0:	1007883a 	mov	r3,r2
   319b4:	00801a04 	movi	r2,104
   319b8:	18800035 	stwio	r2,0(r3)
   319bc:	00000506 	br	319d4 <I2C_read+0x48>
               I2C_OPENCORES_CR_NACK_MSK | I2C_OPENCORES_CR_STO_MSK);
  }
  else
  {
          /* start read*/
          IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_RD_MSK );
   319c0:	e0bffe17 	ldw	r2,-8(fp)
   319c4:	10800404 	addi	r2,r2,16
   319c8:	1007883a 	mov	r3,r2
   319cc:	00800804 	movi	r2,32
   319d0:	18800035 	stwio	r2,0(r3)
  }
          /* wait for the trnasaction to be over.*/
  while( IORD_I2C_OPENCORES_SR(base) & I2C_OPENCORES_SR_TIP_MSK);
   319d4:	0001883a 	nop
   319d8:	e0bffe17 	ldw	r2,-8(fp)
   319dc:	10800404 	addi	r2,r2,16
   319e0:	10800037 	ldwio	r2,0(r2)
   319e4:	1080008c 	andi	r2,r2,2
   319e8:	103ffb1e 	bne	r2,zero,319d8 <__reset+0xfff919d8>

         /* now read the data */
        return (IORD_I2C_OPENCORES_RXR(base));
   319ec:	e0bffe17 	ldw	r2,-8(fp)
   319f0:	10800304 	addi	r2,r2,12
   319f4:	10800037 	ldwio	r2,0(r2)

}
   319f8:	e037883a 	mov	sp,fp
   319fc:	df000017 	ldw	fp,0(sp)
   31a00:	dec00104 	addi	sp,sp,4
   31a04:	f800283a 	ret

00031a08 <I2C_write>:
       0 if address is acknowledged
       1 if address was not acknowledged
15-OCT-07 initial release
*****************************************************************/
alt_u32 I2C_write(alt_u32 base,alt_u8 data, alt_u32 last)
{
   31a08:	defffc04 	addi	sp,sp,-16
   31a0c:	df000315 	stw	fp,12(sp)
   31a10:	df000304 	addi	fp,sp,12
   31a14:	e13ffd15 	stw	r4,-12(fp)
   31a18:	2805883a 	mov	r2,r5
   31a1c:	e1bfff15 	stw	r6,-4(fp)
   31a20:	e0bffe05 	stb	r2,-8(fp)
  #ifdef  I2C_DEBUG
        printf(" Read I2C at 0x%x, \n\twith data 0x%x,\n\twith last0x%x\n",base,data,last);
#endif
                 /* transmit the data*/
  IOWR_I2C_OPENCORES_TXR(base, data);
   31a24:	e0bffd17 	ldw	r2,-12(fp)
   31a28:	10800304 	addi	r2,r2,12
   31a2c:	1007883a 	mov	r3,r2
   31a30:	e0bffe03 	ldbu	r2,-8(fp)
   31a34:	18800035 	stwio	r2,0(r3)

  if( last)
   31a38:	e0bfff17 	ldw	r2,-4(fp)
   31a3c:	10000626 	beq	r2,zero,31a58 <I2C_write+0x50>
  {
               /* start a read and no ack and stop bit*/
           IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_WR_MSK |
   31a40:	e0bffd17 	ldw	r2,-12(fp)
   31a44:	10800404 	addi	r2,r2,16
   31a48:	1007883a 	mov	r3,r2
   31a4c:	00801404 	movi	r2,80
   31a50:	18800035 	stwio	r2,0(r3)
   31a54:	00000506 	br	31a6c <I2C_write+0x64>
               I2C_OPENCORES_CR_STO_MSK);
  }
  else
  {
          /* start read*/
          IOWR_I2C_OPENCORES_CR(base, I2C_OPENCORES_CR_WR_MSK );
   31a58:	e0bffd17 	ldw	r2,-12(fp)
   31a5c:	10800404 	addi	r2,r2,16
   31a60:	1007883a 	mov	r3,r2
   31a64:	00800404 	movi	r2,16
   31a68:	18800035 	stwio	r2,0(r3)
  }
           /* wait for the trnasaction to be over.*/
  while( IORD_I2C_OPENCORES_SR(base) & I2C_OPENCORES_SR_TIP_MSK);
   31a6c:	0001883a 	nop
   31a70:	e0bffd17 	ldw	r2,-12(fp)
   31a74:	10800404 	addi	r2,r2,16
   31a78:	10800037 	ldwio	r2,0(r2)
   31a7c:	1080008c 	andi	r2,r2,2
   31a80:	103ffb1e 	bne	r2,zero,31a70 <__reset+0xfff91a70>

         /* now check to see if the address was acknowledged */
   if(IORD_I2C_OPENCORES_SR(base) & I2C_OPENCORES_SR_RXNACK_MSK)
   31a84:	e0bffd17 	ldw	r2,-12(fp)
   31a88:	10800404 	addi	r2,r2,16
   31a8c:	10800037 	ldwio	r2,0(r2)
   31a90:	1080200c 	andi	r2,r2,128
   31a94:	10000226 	beq	r2,zero,31aa0 <I2C_write+0x98>
   {
#ifdef  I2C_DEBUG
        printf("\tNOACK\n");
#endif
        return (I2C_NOACK);
   31a98:	00800044 	movi	r2,1
   31a9c:	00000106 	br	31aa4 <I2C_write+0x9c>
   else
   {
#ifdef  I2C_DEBUG
        printf("\tACK\n");
#endif
       return (I2C_ACK);
   31aa0:	0005883a 	mov	r2,zero
   }

}
   31aa4:	e037883a 	mov	sp,fp
   31aa8:	df000017 	ldw	fp,0(sp)
   31aac:	dec00104 	addi	sp,sp,4
   31ab0:	f800283a 	ret

00031ab4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   31ab4:	defff504 	addi	sp,sp,-44
   31ab8:	df000a15 	stw	fp,40(sp)
   31abc:	df000a04 	addi	fp,sp,40
   31ac0:	e13ffc15 	stw	r4,-16(fp)
   31ac4:	e17ffd15 	stw	r5,-12(fp)
   31ac8:	e1bffe15 	stw	r6,-8(fp)
   31acc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   31ad0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   31ad4:	d0a03b17 	ldw	r2,-32532(gp)
  
  if (alt_ticks_per_second ())
   31ad8:	10003c26 	beq	r2,zero,31bcc <alt_alarm_start+0x118>
  {
    if (alarm)
   31adc:	e0bffc17 	ldw	r2,-16(fp)
   31ae0:	10003826 	beq	r2,zero,31bc4 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
   31ae4:	e0bffc17 	ldw	r2,-16(fp)
   31ae8:	e0fffe17 	ldw	r3,-8(fp)
   31aec:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   31af0:	e0bffc17 	ldw	r2,-16(fp)
   31af4:	e0ffff17 	ldw	r3,-4(fp)
   31af8:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   31afc:	0005303a 	rdctl	r2,status
   31b00:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   31b04:	e0fff917 	ldw	r3,-28(fp)
   31b08:	00bfff84 	movi	r2,-2
   31b0c:	1884703a 	and	r2,r3,r2
   31b10:	1001703a 	wrctl	status,r2
  
  return context;
   31b14:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
   31b18:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   31b1c:	d0a03c17 	ldw	r2,-32528(gp)
      
      current_nticks = alt_nticks();
   31b20:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   31b24:	e0fffd17 	ldw	r3,-12(fp)
   31b28:	e0bff617 	ldw	r2,-40(fp)
   31b2c:	1885883a 	add	r2,r3,r2
   31b30:	10c00044 	addi	r3,r2,1
   31b34:	e0bffc17 	ldw	r2,-16(fp)
   31b38:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   31b3c:	e0bffc17 	ldw	r2,-16(fp)
   31b40:	10c00217 	ldw	r3,8(r2)
   31b44:	e0bff617 	ldw	r2,-40(fp)
   31b48:	1880042e 	bgeu	r3,r2,31b5c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
   31b4c:	e0bffc17 	ldw	r2,-16(fp)
   31b50:	00c00044 	movi	r3,1
   31b54:	10c00405 	stb	r3,16(r2)
   31b58:	00000206 	br	31b64 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
   31b5c:	e0bffc17 	ldw	r2,-16(fp)
   31b60:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   31b64:	e0bffc17 	ldw	r2,-16(fp)
   31b68:	d0e01804 	addi	r3,gp,-32672
   31b6c:	e0fffa15 	stw	r3,-24(fp)
   31b70:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   31b74:	e0bffb17 	ldw	r2,-20(fp)
   31b78:	e0fffa17 	ldw	r3,-24(fp)
   31b7c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   31b80:	e0bffa17 	ldw	r2,-24(fp)
   31b84:	10c00017 	ldw	r3,0(r2)
   31b88:	e0bffb17 	ldw	r2,-20(fp)
   31b8c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   31b90:	e0bffa17 	ldw	r2,-24(fp)
   31b94:	10800017 	ldw	r2,0(r2)
   31b98:	e0fffb17 	ldw	r3,-20(fp)
   31b9c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   31ba0:	e0bffa17 	ldw	r2,-24(fp)
   31ba4:	e0fffb17 	ldw	r3,-20(fp)
   31ba8:	10c00015 	stw	r3,0(r2)
   31bac:	e0bff817 	ldw	r2,-32(fp)
   31bb0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   31bb4:	e0bff717 	ldw	r2,-36(fp)
   31bb8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   31bbc:	0005883a 	mov	r2,zero
   31bc0:	00000306 	br	31bd0 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
   31bc4:	00bffa84 	movi	r2,-22
   31bc8:	00000106 	br	31bd0 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
   31bcc:	00bfde84 	movi	r2,-134
  }
}
   31bd0:	e037883a 	mov	sp,fp
   31bd4:	df000017 	ldw	fp,0(sp)
   31bd8:	dec00104 	addi	sp,sp,4
   31bdc:	f800283a 	ret

00031be0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   31be0:	defffe04 	addi	sp,sp,-8
   31be4:	dfc00115 	stw	ra,4(sp)
   31be8:	df000015 	stw	fp,0(sp)
   31bec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   31bf0:	d0a00f17 	ldw	r2,-32708(gp)
   31bf4:	10000326 	beq	r2,zero,31c04 <alt_get_errno+0x24>
   31bf8:	d0a00f17 	ldw	r2,-32708(gp)
   31bfc:	103ee83a 	callr	r2
   31c00:	00000106 	br	31c08 <alt_get_errno+0x28>
   31c04:	d0a03604 	addi	r2,gp,-32552
}
   31c08:	e037883a 	mov	sp,fp
   31c0c:	dfc00117 	ldw	ra,4(sp)
   31c10:	df000017 	ldw	fp,0(sp)
   31c14:	dec00204 	addi	sp,sp,8
   31c18:	f800283a 	ret

00031c1c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   31c1c:	defffa04 	addi	sp,sp,-24
   31c20:	dfc00515 	stw	ra,20(sp)
   31c24:	df000415 	stw	fp,16(sp)
   31c28:	df000404 	addi	fp,sp,16
   31c2c:	e13ffe15 	stw	r4,-8(fp)
   31c30:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   31c34:	e0bffe17 	ldw	r2,-8(fp)
   31c38:	10000326 	beq	r2,zero,31c48 <alt_dev_llist_insert+0x2c>
   31c3c:	e0bffe17 	ldw	r2,-8(fp)
   31c40:	10800217 	ldw	r2,8(r2)
   31c44:	1000061e 	bne	r2,zero,31c60 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   31c48:	0031be00 	call	31be0 <alt_get_errno>
   31c4c:	1007883a 	mov	r3,r2
   31c50:	00800584 	movi	r2,22
   31c54:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   31c58:	00bffa84 	movi	r2,-22
   31c5c:	00001306 	br	31cac <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   31c60:	e0bffe17 	ldw	r2,-8(fp)
   31c64:	e0ffff17 	ldw	r3,-4(fp)
   31c68:	e0fffc15 	stw	r3,-16(fp)
   31c6c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   31c70:	e0bffd17 	ldw	r2,-12(fp)
   31c74:	e0fffc17 	ldw	r3,-16(fp)
   31c78:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   31c7c:	e0bffc17 	ldw	r2,-16(fp)
   31c80:	10c00017 	ldw	r3,0(r2)
   31c84:	e0bffd17 	ldw	r2,-12(fp)
   31c88:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   31c8c:	e0bffc17 	ldw	r2,-16(fp)
   31c90:	10800017 	ldw	r2,0(r2)
   31c94:	e0fffd17 	ldw	r3,-12(fp)
   31c98:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   31c9c:	e0bffc17 	ldw	r2,-16(fp)
   31ca0:	e0fffd17 	ldw	r3,-12(fp)
   31ca4:	10c00015 	stw	r3,0(r2)

  return 0;  
   31ca8:	0005883a 	mov	r2,zero
}
   31cac:	e037883a 	mov	sp,fp
   31cb0:	dfc00117 	ldw	ra,4(sp)
   31cb4:	df000017 	ldw	fp,0(sp)
   31cb8:	dec00204 	addi	sp,sp,8
   31cbc:	f800283a 	ret

00031cc0 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
   31cc0:	defffd04 	addi	sp,sp,-12
   31cc4:	dfc00215 	stw	ra,8(sp)
   31cc8:	df000115 	stw	fp,4(sp)
   31ccc:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   31cd0:	008000f4 	movhi	r2,3
   31cd4:	108a5a04 	addi	r2,r2,10600
   31cd8:	e0bfff15 	stw	r2,-4(fp)
   31cdc:	00000606 	br	31cf8 <_do_ctors+0x38>
        (*ctor) (); 
   31ce0:	e0bfff17 	ldw	r2,-4(fp)
   31ce4:	10800017 	ldw	r2,0(r2)
   31ce8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   31cec:	e0bfff17 	ldw	r2,-4(fp)
   31cf0:	10bfff04 	addi	r2,r2,-4
   31cf4:	e0bfff15 	stw	r2,-4(fp)
   31cf8:	e0ffff17 	ldw	r3,-4(fp)
   31cfc:	008000f4 	movhi	r2,3
   31d00:	108a5a04 	addi	r2,r2,10600
   31d04:	18bff62e 	bgeu	r3,r2,31ce0 <__reset+0xfff91ce0>
        (*ctor) (); 
}
   31d08:	0001883a 	nop
   31d0c:	e037883a 	mov	sp,fp
   31d10:	dfc00117 	ldw	ra,4(sp)
   31d14:	df000017 	ldw	fp,0(sp)
   31d18:	dec00204 	addi	sp,sp,8
   31d1c:	f800283a 	ret

00031d20 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
   31d20:	defffd04 	addi	sp,sp,-12
   31d24:	dfc00215 	stw	ra,8(sp)
   31d28:	df000115 	stw	fp,4(sp)
   31d2c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   31d30:	008000f4 	movhi	r2,3
   31d34:	108a5a04 	addi	r2,r2,10600
   31d38:	e0bfff15 	stw	r2,-4(fp)
   31d3c:	00000606 	br	31d58 <_do_dtors+0x38>
        (*dtor) (); 
   31d40:	e0bfff17 	ldw	r2,-4(fp)
   31d44:	10800017 	ldw	r2,0(r2)
   31d48:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   31d4c:	e0bfff17 	ldw	r2,-4(fp)
   31d50:	10bfff04 	addi	r2,r2,-4
   31d54:	e0bfff15 	stw	r2,-4(fp)
   31d58:	e0ffff17 	ldw	r3,-4(fp)
   31d5c:	008000f4 	movhi	r2,3
   31d60:	108a5b04 	addi	r2,r2,10604
   31d64:	18bff62e 	bgeu	r3,r2,31d40 <__reset+0xfff91d40>
        (*dtor) (); 
}
   31d68:	0001883a 	nop
   31d6c:	e037883a 	mov	sp,fp
   31d70:	dfc00117 	ldw	ra,4(sp)
   31d74:	df000017 	ldw	fp,0(sp)
   31d78:	dec00204 	addi	sp,sp,8
   31d7c:	f800283a 	ret

00031d80 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   31d80:	defffa04 	addi	sp,sp,-24
   31d84:	dfc00515 	stw	ra,20(sp)
   31d88:	df000415 	stw	fp,16(sp)
   31d8c:	df000404 	addi	fp,sp,16
   31d90:	e13ffe15 	stw	r4,-8(fp)
   31d94:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   31d98:	e0bfff17 	ldw	r2,-4(fp)
   31d9c:	10800017 	ldw	r2,0(r2)
   31da0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   31da4:	e13ffe17 	ldw	r4,-8(fp)
   31da8:	002b9f00 	call	2b9f0 <strlen>
   31dac:	10800044 	addi	r2,r2,1
   31db0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   31db4:	00000d06 	br	31dec <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   31db8:	e0bffc17 	ldw	r2,-16(fp)
   31dbc:	10800217 	ldw	r2,8(r2)
   31dc0:	e0fffd17 	ldw	r3,-12(fp)
   31dc4:	180d883a 	mov	r6,r3
   31dc8:	e17ffe17 	ldw	r5,-8(fp)
   31dcc:	1009883a 	mov	r4,r2
   31dd0:	00326200 	call	32620 <memcmp>
   31dd4:	1000021e 	bne	r2,zero,31de0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   31dd8:	e0bffc17 	ldw	r2,-16(fp)
   31ddc:	00000706 	br	31dfc <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   31de0:	e0bffc17 	ldw	r2,-16(fp)
   31de4:	10800017 	ldw	r2,0(r2)
   31de8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   31dec:	e0fffc17 	ldw	r3,-16(fp)
   31df0:	e0bfff17 	ldw	r2,-4(fp)
   31df4:	18bff01e 	bne	r3,r2,31db8 <__reset+0xfff91db8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   31df8:	0005883a 	mov	r2,zero
}
   31dfc:	e037883a 	mov	sp,fp
   31e00:	dfc00117 	ldw	ra,4(sp)
   31e04:	df000017 	ldw	fp,0(sp)
   31e08:	dec00204 	addi	sp,sp,8
   31e0c:	f800283a 	ret

00031e10 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   31e10:	defffc04 	addi	sp,sp,-16
   31e14:	dfc00315 	stw	ra,12(sp)
   31e18:	df000215 	stw	fp,8(sp)
   31e1c:	df000204 	addi	fp,sp,8
   31e20:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   31e24:	d1601604 	addi	r5,gp,-32680
   31e28:	e13fff17 	ldw	r4,-4(fp)
   31e2c:	0031d800 	call	31d80 <alt_find_dev>
   31e30:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   31e34:	e0bffe17 	ldw	r2,-8(fp)
   31e38:	10000926 	beq	r2,zero,31e60 <alt_flash_open_dev+0x50>
   31e3c:	e0bffe17 	ldw	r2,-8(fp)
   31e40:	10800317 	ldw	r2,12(r2)
   31e44:	10000626 	beq	r2,zero,31e60 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   31e48:	e0bffe17 	ldw	r2,-8(fp)
   31e4c:	10800317 	ldw	r2,12(r2)
   31e50:	e17fff17 	ldw	r5,-4(fp)
   31e54:	e13ffe17 	ldw	r4,-8(fp)
   31e58:	103ee83a 	callr	r2
   31e5c:	00000106 	br	31e64 <alt_flash_open_dev+0x54>
  }

  return dev;
   31e60:	e0bffe17 	ldw	r2,-8(fp)
}
   31e64:	e037883a 	mov	sp,fp
   31e68:	dfc00117 	ldw	ra,4(sp)
   31e6c:	df000017 	ldw	fp,0(sp)
   31e70:	dec00204 	addi	sp,sp,8
   31e74:	f800283a 	ret

00031e78 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   31e78:	defffd04 	addi	sp,sp,-12
   31e7c:	dfc00215 	stw	ra,8(sp)
   31e80:	df000115 	stw	fp,4(sp)
   31e84:	df000104 	addi	fp,sp,4
   31e88:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   31e8c:	e0bfff17 	ldw	r2,-4(fp)
   31e90:	10000826 	beq	r2,zero,31eb4 <alt_flash_close_dev+0x3c>
   31e94:	e0bfff17 	ldw	r2,-4(fp)
   31e98:	10800417 	ldw	r2,16(r2)
   31e9c:	10000526 	beq	r2,zero,31eb4 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
   31ea0:	e0bfff17 	ldw	r2,-4(fp)
   31ea4:	10800417 	ldw	r2,16(r2)
   31ea8:	e13fff17 	ldw	r4,-4(fp)
   31eac:	103ee83a 	callr	r2
  }
  return;
   31eb0:	0001883a 	nop
   31eb4:	0001883a 	nop
}
   31eb8:	e037883a 	mov	sp,fp
   31ebc:	dfc00117 	ldw	ra,4(sp)
   31ec0:	df000017 	ldw	fp,0(sp)
   31ec4:	dec00204 	addi	sp,sp,8
   31ec8:	f800283a 	ret

00031ecc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   31ecc:	defff904 	addi	sp,sp,-28
   31ed0:	dfc00615 	stw	ra,24(sp)
   31ed4:	df000515 	stw	fp,20(sp)
   31ed8:	df000504 	addi	fp,sp,20
   31edc:	e13ffc15 	stw	r4,-16(fp)
   31ee0:	e17ffd15 	stw	r5,-12(fp)
   31ee4:	e1bffe15 	stw	r6,-8(fp)
   31ee8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   31eec:	e1bfff17 	ldw	r6,-4(fp)
   31ef0:	e17ffe17 	ldw	r5,-8(fp)
   31ef4:	e13ffd17 	ldw	r4,-12(fp)
   31ef8:	003210c0 	call	3210c <open>
   31efc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   31f00:	e0bffb17 	ldw	r2,-20(fp)
   31f04:	10001c16 	blt	r2,zero,31f78 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   31f08:	008000f4 	movhi	r2,3
   31f0c:	108e3a04 	addi	r2,r2,14568
   31f10:	e0fffb17 	ldw	r3,-20(fp)
   31f14:	18c00324 	muli	r3,r3,12
   31f18:	10c5883a 	add	r2,r2,r3
   31f1c:	10c00017 	ldw	r3,0(r2)
   31f20:	e0bffc17 	ldw	r2,-16(fp)
   31f24:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   31f28:	008000f4 	movhi	r2,3
   31f2c:	108e3a04 	addi	r2,r2,14568
   31f30:	e0fffb17 	ldw	r3,-20(fp)
   31f34:	18c00324 	muli	r3,r3,12
   31f38:	10c5883a 	add	r2,r2,r3
   31f3c:	10800104 	addi	r2,r2,4
   31f40:	10c00017 	ldw	r3,0(r2)
   31f44:	e0bffc17 	ldw	r2,-16(fp)
   31f48:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   31f4c:	008000f4 	movhi	r2,3
   31f50:	108e3a04 	addi	r2,r2,14568
   31f54:	e0fffb17 	ldw	r3,-20(fp)
   31f58:	18c00324 	muli	r3,r3,12
   31f5c:	10c5883a 	add	r2,r2,r3
   31f60:	10800204 	addi	r2,r2,8
   31f64:	10c00017 	ldw	r3,0(r2)
   31f68:	e0bffc17 	ldw	r2,-16(fp)
   31f6c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   31f70:	e13ffb17 	ldw	r4,-20(fp)
   31f74:	002e8d00 	call	2e8d0 <alt_release_fd>
  }
} 
   31f78:	0001883a 	nop
   31f7c:	e037883a 	mov	sp,fp
   31f80:	dfc00117 	ldw	ra,4(sp)
   31f84:	df000017 	ldw	fp,0(sp)
   31f88:	dec00204 	addi	sp,sp,8
   31f8c:	f800283a 	ret

00031f90 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   31f90:	defffb04 	addi	sp,sp,-20
   31f94:	dfc00415 	stw	ra,16(sp)
   31f98:	df000315 	stw	fp,12(sp)
   31f9c:	df000304 	addi	fp,sp,12
   31fa0:	e13ffd15 	stw	r4,-12(fp)
   31fa4:	e17ffe15 	stw	r5,-8(fp)
   31fa8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   31fac:	01c07fc4 	movi	r7,511
   31fb0:	01800044 	movi	r6,1
   31fb4:	e17ffd17 	ldw	r5,-12(fp)
   31fb8:	010000f4 	movhi	r4,3
   31fbc:	210e3d04 	addi	r4,r4,14580
   31fc0:	0031ecc0 	call	31ecc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   31fc4:	01c07fc4 	movi	r7,511
   31fc8:	000d883a 	mov	r6,zero
   31fcc:	e17ffe17 	ldw	r5,-8(fp)
   31fd0:	010000f4 	movhi	r4,3
   31fd4:	210e3a04 	addi	r4,r4,14568
   31fd8:	0031ecc0 	call	31ecc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   31fdc:	01c07fc4 	movi	r7,511
   31fe0:	01800044 	movi	r6,1
   31fe4:	e17fff17 	ldw	r5,-4(fp)
   31fe8:	010000f4 	movhi	r4,3
   31fec:	210e4004 	addi	r4,r4,14592
   31ff0:	0031ecc0 	call	31ecc <alt_open_fd>
}  
   31ff4:	0001883a 	nop
   31ff8:	e037883a 	mov	sp,fp
   31ffc:	dfc00117 	ldw	ra,4(sp)
   32000:	df000017 	ldw	fp,0(sp)
   32004:	dec00204 	addi	sp,sp,8
   32008:	f800283a 	ret

0003200c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3200c:	defffe04 	addi	sp,sp,-8
   32010:	dfc00115 	stw	ra,4(sp)
   32014:	df000015 	stw	fp,0(sp)
   32018:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3201c:	d0a00f17 	ldw	r2,-32708(gp)
   32020:	10000326 	beq	r2,zero,32030 <alt_get_errno+0x24>
   32024:	d0a00f17 	ldw	r2,-32708(gp)
   32028:	103ee83a 	callr	r2
   3202c:	00000106 	br	32034 <alt_get_errno+0x28>
   32030:	d0a03604 	addi	r2,gp,-32552
}
   32034:	e037883a 	mov	sp,fp
   32038:	dfc00117 	ldw	ra,4(sp)
   3203c:	df000017 	ldw	fp,0(sp)
   32040:	dec00204 	addi	sp,sp,8
   32044:	f800283a 	ret

00032048 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   32048:	defffd04 	addi	sp,sp,-12
   3204c:	df000215 	stw	fp,8(sp)
   32050:	df000204 	addi	fp,sp,8
   32054:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   32058:	e0bfff17 	ldw	r2,-4(fp)
   3205c:	10800217 	ldw	r2,8(r2)
   32060:	10d00034 	orhi	r3,r2,16384
   32064:	e0bfff17 	ldw	r2,-4(fp)
   32068:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   3206c:	e03ffe15 	stw	zero,-8(fp)
   32070:	00001d06 	br	320e8 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   32074:	008000f4 	movhi	r2,3
   32078:	108e3a04 	addi	r2,r2,14568
   3207c:	e0fffe17 	ldw	r3,-8(fp)
   32080:	18c00324 	muli	r3,r3,12
   32084:	10c5883a 	add	r2,r2,r3
   32088:	10c00017 	ldw	r3,0(r2)
   3208c:	e0bfff17 	ldw	r2,-4(fp)
   32090:	10800017 	ldw	r2,0(r2)
   32094:	1880111e 	bne	r3,r2,320dc <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   32098:	008000f4 	movhi	r2,3
   3209c:	108e3a04 	addi	r2,r2,14568
   320a0:	e0fffe17 	ldw	r3,-8(fp)
   320a4:	18c00324 	muli	r3,r3,12
   320a8:	10c5883a 	add	r2,r2,r3
   320ac:	10800204 	addi	r2,r2,8
   320b0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   320b4:	1000090e 	bge	r2,zero,320dc <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   320b8:	e0bffe17 	ldw	r2,-8(fp)
   320bc:	10c00324 	muli	r3,r2,12
   320c0:	008000f4 	movhi	r2,3
   320c4:	108e3a04 	addi	r2,r2,14568
   320c8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   320cc:	e0bfff17 	ldw	r2,-4(fp)
   320d0:	18800226 	beq	r3,r2,320dc <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   320d4:	00bffcc4 	movi	r2,-13
   320d8:	00000806 	br	320fc <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   320dc:	e0bffe17 	ldw	r2,-8(fp)
   320e0:	10800044 	addi	r2,r2,1
   320e4:	e0bffe15 	stw	r2,-8(fp)
   320e8:	d0a00e17 	ldw	r2,-32712(gp)
   320ec:	1007883a 	mov	r3,r2
   320f0:	e0bffe17 	ldw	r2,-8(fp)
   320f4:	18bfdf2e 	bgeu	r3,r2,32074 <__reset+0xfff92074>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   320f8:	0005883a 	mov	r2,zero
}
   320fc:	e037883a 	mov	sp,fp
   32100:	df000017 	ldw	fp,0(sp)
   32104:	dec00104 	addi	sp,sp,4
   32108:	f800283a 	ret

0003210c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   3210c:	defff604 	addi	sp,sp,-40
   32110:	dfc00915 	stw	ra,36(sp)
   32114:	df000815 	stw	fp,32(sp)
   32118:	df000804 	addi	fp,sp,32
   3211c:	e13ffd15 	stw	r4,-12(fp)
   32120:	e17ffe15 	stw	r5,-8(fp)
   32124:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   32128:	00bfffc4 	movi	r2,-1
   3212c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   32130:	00bffb44 	movi	r2,-19
   32134:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   32138:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   3213c:	d1600c04 	addi	r5,gp,-32720
   32140:	e13ffd17 	ldw	r4,-12(fp)
   32144:	0031d800 	call	31d80 <alt_find_dev>
   32148:	e0bff815 	stw	r2,-32(fp)
   3214c:	e0bff817 	ldw	r2,-32(fp)
   32150:	1000051e 	bne	r2,zero,32168 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   32154:	e13ffd17 	ldw	r4,-12(fp)
   32158:	00324280 	call	32428 <alt_find_file>
   3215c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   32160:	00800044 	movi	r2,1
   32164:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   32168:	e0bff817 	ldw	r2,-32(fp)
   3216c:	10002926 	beq	r2,zero,32214 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
   32170:	e13ff817 	ldw	r4,-32(fp)
   32174:	00325300 	call	32530 <alt_get_fd>
   32178:	e0bff915 	stw	r2,-28(fp)
   3217c:	e0bff917 	ldw	r2,-28(fp)
   32180:	1000030e 	bge	r2,zero,32190 <open+0x84>
    {
      status = index;
   32184:	e0bff917 	ldw	r2,-28(fp)
   32188:	e0bffa15 	stw	r2,-24(fp)
   3218c:	00002306 	br	3221c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
   32190:	e0bff917 	ldw	r2,-28(fp)
   32194:	10c00324 	muli	r3,r2,12
   32198:	008000f4 	movhi	r2,3
   3219c:	108e3a04 	addi	r2,r2,14568
   321a0:	1885883a 	add	r2,r3,r2
   321a4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   321a8:	e0fffe17 	ldw	r3,-8(fp)
   321ac:	00900034 	movhi	r2,16384
   321b0:	10bfffc4 	addi	r2,r2,-1
   321b4:	1886703a 	and	r3,r3,r2
   321b8:	e0bffc17 	ldw	r2,-16(fp)
   321bc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   321c0:	e0bffb17 	ldw	r2,-20(fp)
   321c4:	1000051e 	bne	r2,zero,321dc <open+0xd0>
   321c8:	e13ffc17 	ldw	r4,-16(fp)
   321cc:	00320480 	call	32048 <alt_file_locked>
   321d0:	e0bffa15 	stw	r2,-24(fp)
   321d4:	e0bffa17 	ldw	r2,-24(fp)
   321d8:	10001016 	blt	r2,zero,3221c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   321dc:	e0bff817 	ldw	r2,-32(fp)
   321e0:	10800317 	ldw	r2,12(r2)
   321e4:	10000826 	beq	r2,zero,32208 <open+0xfc>
   321e8:	e0bff817 	ldw	r2,-32(fp)
   321ec:	10800317 	ldw	r2,12(r2)
   321f0:	e1ffff17 	ldw	r7,-4(fp)
   321f4:	e1bffe17 	ldw	r6,-8(fp)
   321f8:	e17ffd17 	ldw	r5,-12(fp)
   321fc:	e13ffc17 	ldw	r4,-16(fp)
   32200:	103ee83a 	callr	r2
   32204:	00000106 	br	3220c <open+0x100>
   32208:	0005883a 	mov	r2,zero
   3220c:	e0bffa15 	stw	r2,-24(fp)
   32210:	00000206 	br	3221c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
   32214:	00bffb44 	movi	r2,-19
   32218:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   3221c:	e0bffa17 	ldw	r2,-24(fp)
   32220:	1000090e 	bge	r2,zero,32248 <open+0x13c>
  {
    alt_release_fd (index);  
   32224:	e13ff917 	ldw	r4,-28(fp)
   32228:	002e8d00 	call	2e8d0 <alt_release_fd>
    ALT_ERRNO = -status;
   3222c:	003200c0 	call	3200c <alt_get_errno>
   32230:	1007883a 	mov	r3,r2
   32234:	e0bffa17 	ldw	r2,-24(fp)
   32238:	0085c83a 	sub	r2,zero,r2
   3223c:	18800015 	stw	r2,0(r3)
    return -1;
   32240:	00bfffc4 	movi	r2,-1
   32244:	00000106 	br	3224c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   32248:	e0bff917 	ldw	r2,-28(fp)
}
   3224c:	e037883a 	mov	sp,fp
   32250:	dfc00117 	ldw	ra,4(sp)
   32254:	df000017 	ldw	fp,0(sp)
   32258:	dec00204 	addi	sp,sp,8
   3225c:	f800283a 	ret

00032260 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   32260:	defffa04 	addi	sp,sp,-24
   32264:	df000515 	stw	fp,20(sp)
   32268:	df000504 	addi	fp,sp,20
   3226c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   32270:	0005303a 	rdctl	r2,status
   32274:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   32278:	e0fffc17 	ldw	r3,-16(fp)
   3227c:	00bfff84 	movi	r2,-2
   32280:	1884703a 	and	r2,r3,r2
   32284:	1001703a 	wrctl	status,r2
  
  return context;
   32288:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   3228c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
   32290:	e0bfff17 	ldw	r2,-4(fp)
   32294:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   32298:	e0bffd17 	ldw	r2,-12(fp)
   3229c:	10800017 	ldw	r2,0(r2)
   322a0:	e0fffd17 	ldw	r3,-12(fp)
   322a4:	18c00117 	ldw	r3,4(r3)
   322a8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   322ac:	e0bffd17 	ldw	r2,-12(fp)
   322b0:	10800117 	ldw	r2,4(r2)
   322b4:	e0fffd17 	ldw	r3,-12(fp)
   322b8:	18c00017 	ldw	r3,0(r3)
   322bc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   322c0:	e0bffd17 	ldw	r2,-12(fp)
   322c4:	e0fffd17 	ldw	r3,-12(fp)
   322c8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   322cc:	e0bffd17 	ldw	r2,-12(fp)
   322d0:	e0fffd17 	ldw	r3,-12(fp)
   322d4:	10c00015 	stw	r3,0(r2)
   322d8:	e0bffb17 	ldw	r2,-20(fp)
   322dc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   322e0:	e0bffe17 	ldw	r2,-8(fp)
   322e4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   322e8:	0001883a 	nop
   322ec:	e037883a 	mov	sp,fp
   322f0:	df000017 	ldw	fp,0(sp)
   322f4:	dec00104 	addi	sp,sp,4
   322f8:	f800283a 	ret

000322fc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   322fc:	defffb04 	addi	sp,sp,-20
   32300:	dfc00415 	stw	ra,16(sp)
   32304:	df000315 	stw	fp,12(sp)
   32308:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   3230c:	d0a01817 	ldw	r2,-32672(gp)
   32310:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   32314:	d0a03c17 	ldw	r2,-32528(gp)
   32318:	10800044 	addi	r2,r2,1
   3231c:	d0a03c15 	stw	r2,-32528(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   32320:	00002e06 	br	323dc <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   32324:	e0bffd17 	ldw	r2,-12(fp)
   32328:	10800017 	ldw	r2,0(r2)
   3232c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   32330:	e0bffd17 	ldw	r2,-12(fp)
   32334:	10800403 	ldbu	r2,16(r2)
   32338:	10803fcc 	andi	r2,r2,255
   3233c:	10000426 	beq	r2,zero,32350 <alt_tick+0x54>
   32340:	d0a03c17 	ldw	r2,-32528(gp)
   32344:	1000021e 	bne	r2,zero,32350 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   32348:	e0bffd17 	ldw	r2,-12(fp)
   3234c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   32350:	e0bffd17 	ldw	r2,-12(fp)
   32354:	10800217 	ldw	r2,8(r2)
   32358:	d0e03c17 	ldw	r3,-32528(gp)
   3235c:	18801d36 	bltu	r3,r2,323d4 <alt_tick+0xd8>
   32360:	e0bffd17 	ldw	r2,-12(fp)
   32364:	10800403 	ldbu	r2,16(r2)
   32368:	10803fcc 	andi	r2,r2,255
   3236c:	1000191e 	bne	r2,zero,323d4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   32370:	e0bffd17 	ldw	r2,-12(fp)
   32374:	10800317 	ldw	r2,12(r2)
   32378:	e0fffd17 	ldw	r3,-12(fp)
   3237c:	18c00517 	ldw	r3,20(r3)
   32380:	1809883a 	mov	r4,r3
   32384:	103ee83a 	callr	r2
   32388:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   3238c:	e0bfff17 	ldw	r2,-4(fp)
   32390:	1000031e 	bne	r2,zero,323a0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   32394:	e13ffd17 	ldw	r4,-12(fp)
   32398:	00322600 	call	32260 <alt_alarm_stop>
   3239c:	00000d06 	br	323d4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   323a0:	e0bffd17 	ldw	r2,-12(fp)
   323a4:	10c00217 	ldw	r3,8(r2)
   323a8:	e0bfff17 	ldw	r2,-4(fp)
   323ac:	1887883a 	add	r3,r3,r2
   323b0:	e0bffd17 	ldw	r2,-12(fp)
   323b4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   323b8:	e0bffd17 	ldw	r2,-12(fp)
   323bc:	10c00217 	ldw	r3,8(r2)
   323c0:	d0a03c17 	ldw	r2,-32528(gp)
   323c4:	1880032e 	bgeu	r3,r2,323d4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   323c8:	e0bffd17 	ldw	r2,-12(fp)
   323cc:	00c00044 	movi	r3,1
   323d0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   323d4:	e0bffe17 	ldw	r2,-8(fp)
   323d8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   323dc:	e0fffd17 	ldw	r3,-12(fp)
   323e0:	d0a01804 	addi	r2,gp,-32672
   323e4:	18bfcf1e 	bne	r3,r2,32324 <__reset+0xfff92324>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   323e8:	0001883a 	nop
}
   323ec:	0001883a 	nop
   323f0:	e037883a 	mov	sp,fp
   323f4:	dfc00117 	ldw	ra,4(sp)
   323f8:	df000017 	ldw	fp,0(sp)
   323fc:	dec00204 	addi	sp,sp,8
   32400:	f800283a 	ret

00032404 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   32404:	deffff04 	addi	sp,sp,-4
   32408:	df000015 	stw	fp,0(sp)
   3240c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   32410:	000170fa 	wrctl	ienable,zero
}
   32414:	0001883a 	nop
   32418:	e037883a 	mov	sp,fp
   3241c:	df000017 	ldw	fp,0(sp)
   32420:	dec00104 	addi	sp,sp,4
   32424:	f800283a 	ret

00032428 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   32428:	defffb04 	addi	sp,sp,-20
   3242c:	dfc00415 	stw	ra,16(sp)
   32430:	df000315 	stw	fp,12(sp)
   32434:	df000304 	addi	fp,sp,12
   32438:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   3243c:	d0a00a17 	ldw	r2,-32728(gp)
   32440:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   32444:	00003106 	br	3250c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   32448:	e0bffd17 	ldw	r2,-12(fp)
   3244c:	10800217 	ldw	r2,8(r2)
   32450:	1009883a 	mov	r4,r2
   32454:	002b9f00 	call	2b9f0 <strlen>
   32458:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   3245c:	e0bffd17 	ldw	r2,-12(fp)
   32460:	10c00217 	ldw	r3,8(r2)
   32464:	e0bffe17 	ldw	r2,-8(fp)
   32468:	10bfffc4 	addi	r2,r2,-1
   3246c:	1885883a 	add	r2,r3,r2
   32470:	10800003 	ldbu	r2,0(r2)
   32474:	10803fcc 	andi	r2,r2,255
   32478:	1080201c 	xori	r2,r2,128
   3247c:	10bfe004 	addi	r2,r2,-128
   32480:	10800bd8 	cmpnei	r2,r2,47
   32484:	1000031e 	bne	r2,zero,32494 <alt_find_file+0x6c>
    {
      len -= 1;
   32488:	e0bffe17 	ldw	r2,-8(fp)
   3248c:	10bfffc4 	addi	r2,r2,-1
   32490:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   32494:	e0bffe17 	ldw	r2,-8(fp)
   32498:	e0ffff17 	ldw	r3,-4(fp)
   3249c:	1885883a 	add	r2,r3,r2
   324a0:	10800003 	ldbu	r2,0(r2)
   324a4:	10803fcc 	andi	r2,r2,255
   324a8:	1080201c 	xori	r2,r2,128
   324ac:	10bfe004 	addi	r2,r2,-128
   324b0:	10800be0 	cmpeqi	r2,r2,47
   324b4:	1000081e 	bne	r2,zero,324d8 <alt_find_file+0xb0>
   324b8:	e0bffe17 	ldw	r2,-8(fp)
   324bc:	e0ffff17 	ldw	r3,-4(fp)
   324c0:	1885883a 	add	r2,r3,r2
   324c4:	10800003 	ldbu	r2,0(r2)
   324c8:	10803fcc 	andi	r2,r2,255
   324cc:	1080201c 	xori	r2,r2,128
   324d0:	10bfe004 	addi	r2,r2,-128
   324d4:	10000a1e 	bne	r2,zero,32500 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   324d8:	e0bffd17 	ldw	r2,-12(fp)
   324dc:	10800217 	ldw	r2,8(r2)
   324e0:	e0fffe17 	ldw	r3,-8(fp)
   324e4:	180d883a 	mov	r6,r3
   324e8:	e17fff17 	ldw	r5,-4(fp)
   324ec:	1009883a 	mov	r4,r2
   324f0:	00326200 	call	32620 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   324f4:	1000021e 	bne	r2,zero,32500 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   324f8:	e0bffd17 	ldw	r2,-12(fp)
   324fc:	00000706 	br	3251c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   32500:	e0bffd17 	ldw	r2,-12(fp)
   32504:	10800017 	ldw	r2,0(r2)
   32508:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   3250c:	e0fffd17 	ldw	r3,-12(fp)
   32510:	d0a00a04 	addi	r2,gp,-32728
   32514:	18bfcc1e 	bne	r3,r2,32448 <__reset+0xfff92448>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   32518:	0005883a 	mov	r2,zero
}
   3251c:	e037883a 	mov	sp,fp
   32520:	dfc00117 	ldw	ra,4(sp)
   32524:	df000017 	ldw	fp,0(sp)
   32528:	dec00204 	addi	sp,sp,8
   3252c:	f800283a 	ret

00032530 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   32530:	defffc04 	addi	sp,sp,-16
   32534:	df000315 	stw	fp,12(sp)
   32538:	df000304 	addi	fp,sp,12
   3253c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   32540:	00bffa04 	movi	r2,-24
   32544:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   32548:	e03ffd15 	stw	zero,-12(fp)
   3254c:	00001906 	br	325b4 <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
   32550:	008000f4 	movhi	r2,3
   32554:	108e3a04 	addi	r2,r2,14568
   32558:	e0fffd17 	ldw	r3,-12(fp)
   3255c:	18c00324 	muli	r3,r3,12
   32560:	10c5883a 	add	r2,r2,r3
   32564:	10800017 	ldw	r2,0(r2)
   32568:	10000f1e 	bne	r2,zero,325a8 <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
   3256c:	008000f4 	movhi	r2,3
   32570:	108e3a04 	addi	r2,r2,14568
   32574:	e0fffd17 	ldw	r3,-12(fp)
   32578:	18c00324 	muli	r3,r3,12
   3257c:	10c5883a 	add	r2,r2,r3
   32580:	e0ffff17 	ldw	r3,-4(fp)
   32584:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   32588:	d0e00e17 	ldw	r3,-32712(gp)
   3258c:	e0bffd17 	ldw	r2,-12(fp)
   32590:	1880020e 	bge	r3,r2,3259c <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
   32594:	e0bffd17 	ldw	r2,-12(fp)
   32598:	d0a00e15 	stw	r2,-32712(gp)
      }
      rc = i;
   3259c:	e0bffd17 	ldw	r2,-12(fp)
   325a0:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   325a4:	00000606 	br	325c0 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   325a8:	e0bffd17 	ldw	r2,-12(fp)
   325ac:	10800044 	addi	r2,r2,1
   325b0:	e0bffd15 	stw	r2,-12(fp)
   325b4:	e0bffd17 	ldw	r2,-12(fp)
   325b8:	10800810 	cmplti	r2,r2,32
   325bc:	103fe41e 	bne	r2,zero,32550 <__reset+0xfff92550>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   325c0:	e0bffe17 	ldw	r2,-8(fp)
}
   325c4:	e037883a 	mov	sp,fp
   325c8:	df000017 	ldw	fp,0(sp)
   325cc:	dec00104 	addi	sp,sp,4
   325d0:	f800283a 	ret

000325d4 <atexit>:
   325d4:	200b883a 	mov	r5,r4
   325d8:	000f883a 	mov	r7,zero
   325dc:	000d883a 	mov	r6,zero
   325e0:	0009883a 	mov	r4,zero
   325e4:	003269c1 	jmpi	3269c <__register_exitproc>

000325e8 <exit>:
   325e8:	defffe04 	addi	sp,sp,-8
   325ec:	000b883a 	mov	r5,zero
   325f0:	dc000015 	stw	r16,0(sp)
   325f4:	dfc00115 	stw	ra,4(sp)
   325f8:	2021883a 	mov	r16,r4
   325fc:	00327b40 	call	327b4 <__call_exitprocs>
   32600:	008000f4 	movhi	r2,3
   32604:	10931704 	addi	r2,r2,19548
   32608:	11000017 	ldw	r4,0(r2)
   3260c:	20800f17 	ldw	r2,60(r4)
   32610:	10000126 	beq	r2,zero,32618 <exit+0x30>
   32614:	103ee83a 	callr	r2
   32618:	8009883a 	mov	r4,r16
   3261c:	00329340 	call	32934 <_exit>

00032620 <memcmp>:
   32620:	01c000c4 	movi	r7,3
   32624:	3980192e 	bgeu	r7,r6,3268c <memcmp+0x6c>
   32628:	2144b03a 	or	r2,r4,r5
   3262c:	11c4703a 	and	r2,r2,r7
   32630:	10000f26 	beq	r2,zero,32670 <memcmp+0x50>
   32634:	20800003 	ldbu	r2,0(r4)
   32638:	28c00003 	ldbu	r3,0(r5)
   3263c:	10c0151e 	bne	r2,r3,32694 <memcmp+0x74>
   32640:	31bfff84 	addi	r6,r6,-2
   32644:	01ffffc4 	movi	r7,-1
   32648:	00000406 	br	3265c <memcmp+0x3c>
   3264c:	20800003 	ldbu	r2,0(r4)
   32650:	28c00003 	ldbu	r3,0(r5)
   32654:	31bfffc4 	addi	r6,r6,-1
   32658:	10c00e1e 	bne	r2,r3,32694 <memcmp+0x74>
   3265c:	21000044 	addi	r4,r4,1
   32660:	29400044 	addi	r5,r5,1
   32664:	31fff91e 	bne	r6,r7,3264c <__reset+0xfff9264c>
   32668:	0005883a 	mov	r2,zero
   3266c:	f800283a 	ret
   32670:	20c00017 	ldw	r3,0(r4)
   32674:	28800017 	ldw	r2,0(r5)
   32678:	18bfee1e 	bne	r3,r2,32634 <__reset+0xfff92634>
   3267c:	31bfff04 	addi	r6,r6,-4
   32680:	21000104 	addi	r4,r4,4
   32684:	29400104 	addi	r5,r5,4
   32688:	39bff936 	bltu	r7,r6,32670 <__reset+0xfff92670>
   3268c:	303fe91e 	bne	r6,zero,32634 <__reset+0xfff92634>
   32690:	003ff506 	br	32668 <__reset+0xfff92668>
   32694:	10c5c83a 	sub	r2,r2,r3
   32698:	f800283a 	ret

0003269c <__register_exitproc>:
   3269c:	defffa04 	addi	sp,sp,-24
   326a0:	dc000315 	stw	r16,12(sp)
   326a4:	040000f4 	movhi	r16,3
   326a8:	84131704 	addi	r16,r16,19548
   326ac:	80c00017 	ldw	r3,0(r16)
   326b0:	dc400415 	stw	r17,16(sp)
   326b4:	dfc00515 	stw	ra,20(sp)
   326b8:	18805217 	ldw	r2,328(r3)
   326bc:	2023883a 	mov	r17,r4
   326c0:	10003726 	beq	r2,zero,327a0 <__register_exitproc+0x104>
   326c4:	10c00117 	ldw	r3,4(r2)
   326c8:	010007c4 	movi	r4,31
   326cc:	20c00e16 	blt	r4,r3,32708 <__register_exitproc+0x6c>
   326d0:	1a000044 	addi	r8,r3,1
   326d4:	8800221e 	bne	r17,zero,32760 <__register_exitproc+0xc4>
   326d8:	18c00084 	addi	r3,r3,2
   326dc:	18c7883a 	add	r3,r3,r3
   326e0:	18c7883a 	add	r3,r3,r3
   326e4:	12000115 	stw	r8,4(r2)
   326e8:	10c7883a 	add	r3,r2,r3
   326ec:	19400015 	stw	r5,0(r3)
   326f0:	0005883a 	mov	r2,zero
   326f4:	dfc00517 	ldw	ra,20(sp)
   326f8:	dc400417 	ldw	r17,16(sp)
   326fc:	dc000317 	ldw	r16,12(sp)
   32700:	dec00604 	addi	sp,sp,24
   32704:	f800283a 	ret
   32708:	00800034 	movhi	r2,0
   3270c:	10800004 	addi	r2,r2,0
   32710:	10002626 	beq	r2,zero,327ac <__register_exitproc+0x110>
   32714:	01006404 	movi	r4,400
   32718:	d9400015 	stw	r5,0(sp)
   3271c:	d9800115 	stw	r6,4(sp)
   32720:	d9c00215 	stw	r7,8(sp)
   32724:	00000000 	call	0 <__alt_mem_onchip_memory2_nios2-0x20000>
   32728:	d9400017 	ldw	r5,0(sp)
   3272c:	d9800117 	ldw	r6,4(sp)
   32730:	d9c00217 	ldw	r7,8(sp)
   32734:	10001d26 	beq	r2,zero,327ac <__register_exitproc+0x110>
   32738:	81000017 	ldw	r4,0(r16)
   3273c:	10000115 	stw	zero,4(r2)
   32740:	02000044 	movi	r8,1
   32744:	22405217 	ldw	r9,328(r4)
   32748:	0007883a 	mov	r3,zero
   3274c:	12400015 	stw	r9,0(r2)
   32750:	20805215 	stw	r2,328(r4)
   32754:	10006215 	stw	zero,392(r2)
   32758:	10006315 	stw	zero,396(r2)
   3275c:	883fde26 	beq	r17,zero,326d8 <__reset+0xfff926d8>
   32760:	18c9883a 	add	r4,r3,r3
   32764:	2109883a 	add	r4,r4,r4
   32768:	1109883a 	add	r4,r2,r4
   3276c:	21802215 	stw	r6,136(r4)
   32770:	01800044 	movi	r6,1
   32774:	12406217 	ldw	r9,392(r2)
   32778:	30cc983a 	sll	r6,r6,r3
   3277c:	4992b03a 	or	r9,r9,r6
   32780:	12406215 	stw	r9,392(r2)
   32784:	21c04215 	stw	r7,264(r4)
   32788:	01000084 	movi	r4,2
   3278c:	893fd21e 	bne	r17,r4,326d8 <__reset+0xfff926d8>
   32790:	11006317 	ldw	r4,396(r2)
   32794:	218cb03a 	or	r6,r4,r6
   32798:	11806315 	stw	r6,396(r2)
   3279c:	003fce06 	br	326d8 <__reset+0xfff926d8>
   327a0:	18805304 	addi	r2,r3,332
   327a4:	18805215 	stw	r2,328(r3)
   327a8:	003fc606 	br	326c4 <__reset+0xfff926c4>
   327ac:	00bfffc4 	movi	r2,-1
   327b0:	003fd006 	br	326f4 <__reset+0xfff926f4>

000327b4 <__call_exitprocs>:
   327b4:	defff504 	addi	sp,sp,-44
   327b8:	df000915 	stw	fp,36(sp)
   327bc:	dd400615 	stw	r21,24(sp)
   327c0:	dc800315 	stw	r18,12(sp)
   327c4:	dfc00a15 	stw	ra,40(sp)
   327c8:	ddc00815 	stw	r23,32(sp)
   327cc:	dd800715 	stw	r22,28(sp)
   327d0:	dd000515 	stw	r20,20(sp)
   327d4:	dcc00415 	stw	r19,16(sp)
   327d8:	dc400215 	stw	r17,8(sp)
   327dc:	dc000115 	stw	r16,4(sp)
   327e0:	d9000015 	stw	r4,0(sp)
   327e4:	2839883a 	mov	fp,r5
   327e8:	04800044 	movi	r18,1
   327ec:	057fffc4 	movi	r21,-1
   327f0:	008000f4 	movhi	r2,3
   327f4:	10931704 	addi	r2,r2,19548
   327f8:	12000017 	ldw	r8,0(r2)
   327fc:	45005217 	ldw	r20,328(r8)
   32800:	44c05204 	addi	r19,r8,328
   32804:	a0001c26 	beq	r20,zero,32878 <__call_exitprocs+0xc4>
   32808:	a0800117 	ldw	r2,4(r20)
   3280c:	15ffffc4 	addi	r23,r2,-1
   32810:	b8000d16 	blt	r23,zero,32848 <__call_exitprocs+0x94>
   32814:	14000044 	addi	r16,r2,1
   32818:	8421883a 	add	r16,r16,r16
   3281c:	8421883a 	add	r16,r16,r16
   32820:	84402004 	addi	r17,r16,128
   32824:	a463883a 	add	r17,r20,r17
   32828:	a421883a 	add	r16,r20,r16
   3282c:	e0001e26 	beq	fp,zero,328a8 <__call_exitprocs+0xf4>
   32830:	80804017 	ldw	r2,256(r16)
   32834:	e0801c26 	beq	fp,r2,328a8 <__call_exitprocs+0xf4>
   32838:	bdffffc4 	addi	r23,r23,-1
   3283c:	843fff04 	addi	r16,r16,-4
   32840:	8c7fff04 	addi	r17,r17,-4
   32844:	bd7ff91e 	bne	r23,r21,3282c <__reset+0xfff9282c>
   32848:	00800034 	movhi	r2,0
   3284c:	10800004 	addi	r2,r2,0
   32850:	10000926 	beq	r2,zero,32878 <__call_exitprocs+0xc4>
   32854:	a0800117 	ldw	r2,4(r20)
   32858:	1000301e 	bne	r2,zero,3291c <__call_exitprocs+0x168>
   3285c:	a0800017 	ldw	r2,0(r20)
   32860:	10003226 	beq	r2,zero,3292c <__call_exitprocs+0x178>
   32864:	a009883a 	mov	r4,r20
   32868:	98800015 	stw	r2,0(r19)
   3286c:	00000000 	call	0 <__alt_mem_onchip_memory2_nios2-0x20000>
   32870:	9d000017 	ldw	r20,0(r19)
   32874:	a03fe41e 	bne	r20,zero,32808 <__reset+0xfff92808>
   32878:	dfc00a17 	ldw	ra,40(sp)
   3287c:	df000917 	ldw	fp,36(sp)
   32880:	ddc00817 	ldw	r23,32(sp)
   32884:	dd800717 	ldw	r22,28(sp)
   32888:	dd400617 	ldw	r21,24(sp)
   3288c:	dd000517 	ldw	r20,20(sp)
   32890:	dcc00417 	ldw	r19,16(sp)
   32894:	dc800317 	ldw	r18,12(sp)
   32898:	dc400217 	ldw	r17,8(sp)
   3289c:	dc000117 	ldw	r16,4(sp)
   328a0:	dec00b04 	addi	sp,sp,44
   328a4:	f800283a 	ret
   328a8:	a0800117 	ldw	r2,4(r20)
   328ac:	80c00017 	ldw	r3,0(r16)
   328b0:	10bfffc4 	addi	r2,r2,-1
   328b4:	15c01426 	beq	r2,r23,32908 <__call_exitprocs+0x154>
   328b8:	80000015 	stw	zero,0(r16)
   328bc:	183fde26 	beq	r3,zero,32838 <__reset+0xfff92838>
   328c0:	95c8983a 	sll	r4,r18,r23
   328c4:	a0806217 	ldw	r2,392(r20)
   328c8:	a5800117 	ldw	r22,4(r20)
   328cc:	2084703a 	and	r2,r4,r2
   328d0:	10000b26 	beq	r2,zero,32900 <__call_exitprocs+0x14c>
   328d4:	a0806317 	ldw	r2,396(r20)
   328d8:	2088703a 	and	r4,r4,r2
   328dc:	20000c1e 	bne	r4,zero,32910 <__call_exitprocs+0x15c>
   328e0:	89400017 	ldw	r5,0(r17)
   328e4:	d9000017 	ldw	r4,0(sp)
   328e8:	183ee83a 	callr	r3
   328ec:	a0800117 	ldw	r2,4(r20)
   328f0:	15bfbf1e 	bne	r2,r22,327f0 <__reset+0xfff927f0>
   328f4:	98800017 	ldw	r2,0(r19)
   328f8:	153fcf26 	beq	r2,r20,32838 <__reset+0xfff92838>
   328fc:	003fbc06 	br	327f0 <__reset+0xfff927f0>
   32900:	183ee83a 	callr	r3
   32904:	003ff906 	br	328ec <__reset+0xfff928ec>
   32908:	a5c00115 	stw	r23,4(r20)
   3290c:	003feb06 	br	328bc <__reset+0xfff928bc>
   32910:	89000017 	ldw	r4,0(r17)
   32914:	183ee83a 	callr	r3
   32918:	003ff406 	br	328ec <__reset+0xfff928ec>
   3291c:	a0800017 	ldw	r2,0(r20)
   32920:	a027883a 	mov	r19,r20
   32924:	1029883a 	mov	r20,r2
   32928:	003fb606 	br	32804 <__reset+0xfff92804>
   3292c:	0005883a 	mov	r2,zero
   32930:	003ffb06 	br	32920 <__reset+0xfff92920>

00032934 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   32934:	defffd04 	addi	sp,sp,-12
   32938:	df000215 	stw	fp,8(sp)
   3293c:	df000204 	addi	fp,sp,8
   32940:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   32944:	0001883a 	nop
   32948:	e0bfff17 	ldw	r2,-4(fp)
   3294c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   32950:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   32954:	10000226 	beq	r2,zero,32960 <_exit+0x2c>
    ALT_SIM_FAIL();
   32958:	002af070 	cmpltui	zero,zero,43969
   3295c:	00000106 	br	32964 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   32960:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   32964:	003fff06 	br	32964 <__reset+0xfff92964>
   32968:	00027b34 	movhi	zero,2540
